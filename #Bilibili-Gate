// ==UserScript==
// @name         Bilibili-Gate
// @namespace    https://magicdawn.fun
// @version      0.32.8
// @author       magicdawn
// @description  Bilibili 自定义首页
// @license      MIT
// @icon         https://www.bilibili.com/favicon.ico
// @homepageURL  https://greasyfork.org/zh-CN/scripts/443530-bilibili-gate
// @supportURL   https://github.com/magicdawn/bilibili-gate/issues
// @match        https://www.bilibili.com/
// @match        https://www.bilibili.com/?*
// @match        https://www.bilibili.com/index.html
// @match        https://www.bilibili.com/index.html?*
// @match        https://www.bilibili.com/video/*
// @match        https://www.bilibili.com/list/watchlater?*
// @match        https://www.bilibili.com/bangumi/play/*
// @match        https://space.bilibili.com/*
// @match        https://search.bilibili.com/*
// @require      https://registry.npmmirror.com/axios/0.27.2/files/dist/axios.min.js
// @require      https://registry.npmmirror.com/react/18.3.1/files/umd/react.production.min.js
// @require      https://registry.npmmirror.com/react-dom/18.3.1/files/umd/react-dom.production.min.js
// @require      https://registry.npmmirror.com/ua-parser-js/1.0.39/files/dist/ua-parser.min.js
// @require      https://registry.npmmirror.com/framer-motion/12.10.2/files/dist/framer-motion.js
// @require      https://registry.npmmirror.com/localforage/1.10.0/files/dist/localforage.min.js
// @require      https://registry.npmmirror.com/dayjs/1.11.13/files/dayjs.min.js
// @require      https://registry.npmmirror.com/dayjs/1.11.13/files/plugin/duration.js
// @require      https://registry.npmmirror.com/@ant-design/cssinjs/1.23.0/files/dist/umd/cssinjs.min.js
// @require      https://registry.npmmirror.com/antd/5.25.0/files/dist/antd-with-locales.min.js
// @tag          bilibili
// @connect      app.bilibili.com
// @grant        GM.deleteValue
// @grant        GM.getValue
// @grant        GM.listValues
// @grant        GM.openInTab
// @grant        GM.registerMenuCommand
// @grant        GM.setClipboard
// @grant        GM.setValue
// @grant        GM.xmlHttpRequest
// @grant        GM_addStyle
// @grant        GM_addValueChangeListener
// @grant        GM_download
// @grant        unsafeWindow
// @run-at       document-end
// @downloadURL https://update.greasyfork.org/scripts/443530/Bilibili-Gate.user.js
// @updateURL https://update.greasyfork.org/scripts/443530/Bilibili-Gate.meta.js
// ==/UserScript==

(t=>{if(typeof GM_addStyle=="function"){GM_addStyle(t);return}const n=document.createElement("style");n.textContent=t,document.head.append(n)})(` @charset "UTF-8";
:root {
  --bilibili-gate--font: "Alibaba PuHuiTi 3.0", "PingFang SC", HarmonyOS_Regular, "Helvetica Neue", "Microsoft YaHei", sans-serif;
}

.bilibili-gate-color-primary {
  color: var(--bilibili-gate--color-primary);
}

:root {
  --bilibili-gate--border-color: oklch(from var(--bilibili-gate--bg) calc(l - 0.05) c h);
  --bilibili-gate--bg--lv1: oklch(from var(--bilibili-gate--bg) calc(l - 0.04) c h);
  --bilibili-gate--bg--lv2: oklch(from var(--bilibili-gate--bg) calc(l - 0.08) c h);
  --bilibili-gate--bg--lv3: oklch(from var(--bilibili-gate--bg) calc(l - 0.12) c h);
}
:root.bilibili-gate-dark {
  --bilibili-gate--border-color: oklch(from var(--bilibili-gate--bg) calc(l + 0.07) c h);
  --bilibili-gate--bg--lv1: oklch(from var(--bilibili-gate--bg) calc(l + 0.03) c h);
  --bilibili-gate--bg--lv2: oklch(from var(--bilibili-gate--bg) calc(l + 0.08) c h);
  --bilibili-gate--bg--lv3: oklch(from var(--bilibili-gate--bg) calc(l + 0.12) c h);
}

.bilibili-gate-root {
  font-family: var(--custom-font-family--options--font-family, var(--bilibili-gate--font)) !important;
  --back-top-right: 24px;
}
.bilibili-gate-root .bili-video-card a:not(.disable-hover):hover {
  color: var(--bilibili-gate--color-primary) !important;
}
.bilibili-gate-root .ant-btn > span.ant-btn-icon {
  line-height: 0;
}

@media (max-width: 1440px) {
  .bilibili-gate-root {
    --back-top-right: 16px;
  }
}
.primary-btn:disabled:active, .primary-btn:disabled:hover {
  cursor: wait;
  background-color: inherit;
}

.ant-btn {
  font-size: 13px;
}
.ant-btn:disabled {
  cursor: wait;
}

.ant-radio-button-wrapper-disabled {
  cursor: wait;
}

body .ant-tooltip a {
  color: #1677ff;
  transition: color 0.3s;
}
body .ant-tooltip a:visited {
  color: #1677ff;
}
body .ant-tooltip a:hover {
  color: #69b1ff;
}
body .ant-tooltip a:active {
  color: #0958d9;
}

body button:where(.ant-switch):focus, body button:where(.ant-switch):active {
  background-color: rgba(0, 0, 0, 0.25);
  outline: unset;
}

/**
B\u7AD9\u81EA\u5E26 css, \u5F71\u54CD\u4E86 solid button :focus \u6837\u5F0F
body button:focus, body button:active {
  background-color: transparent;
  outline: none;
}
 */
body .ant-btn.ant-btn-variant-solid:focus, body .ant-btn.ant-btn-variant-solid:active {
  color: var(--ant-button-primary-color);
  background: var(--ant-color-primary);
}
._video-grid_b2rnv_2 {
  display: grid;
  position: relative;
  width: 100%;
  grid-gap: 20px 12px;
  grid-template-columns: repeat(var(--col), minmax(0, 1fr));
  --bilibili-gate--video-card--border-radius: 15px;
}

/**
 * bili-feed4
 * \u53D6\u81EA .battle-feed-area .battle-feed-body
 */
._video-grid-bili-feed4_b2rnv_15 {
  grid-gap: 20px 20px;
}
._video-grid-bili-feed4_b2rnv_15 .ant-divider-horizontal.ant-divider-with-text {
  margin-bottom: -15px;
  margin-top: -15px;
}
._video-grid-bili-feed4_b2rnv_15 .ant-divider-horizontal.ant-divider-with-text:first-of-type {
  margin-top: 0;
}

@media (max-width: 1399px) {
  ._video-grid-bili-feed4_b2rnv_15 {
    --col: 4;
  }
  ._video-grid-bili-feed4_b2rnv_15._limit-one-line_b2rnv_30 > *:nth-of-type(1n + 5) {
    display: none !important;
  }
  ._video-grid-bili-feed4_b2rnv_15._limit-two-lines_b2rnv_33 > *:nth-of-type(1n + 9) {
    display: none !important;
  }
}
@media (min-width: 1400px) {
  ._video-grid-bili-feed4_b2rnv_15 {
    --col: 5;
  }
  ._video-grid-bili-feed4_b2rnv_15._limit-one-line_b2rnv_30 > *:nth-of-type(1n + 6) {
    display: none !important;
  }
  ._video-grid-bili-feed4_b2rnv_15._limit-two-lines_b2rnv_33 > *:nth-of-type(1n + 11) {
    display: none !important;
  }
}
/**
 * @container \u5BB9\u5668
 */
._video-grid-container_b2rnv_51 {
  container-type: inline-size;
}
._video-grid-container_b2rnv_51._virtual-grid-enabled_b2rnv_54 .virtuoso-grid-item {
  padding-bottom: var(--row-gap);
}
._video-grid-container_b2rnv_51._virtual-grid-enabled_b2rnv_54 .virtuoso-grid-item .bili-video-card {
  margin-bottom: 0;
  height: 100%;
}

._video-grid-custom_b2rnv_62 {
  --col: 4;
  column-gap: 20px;
  row-gap: 0;
  --row-gap: clamp(20px, 1.4vw, 40px);
}
._video-grid-custom_b2rnv_62 .bili-video-card {
  margin-bottom: var(--row-gap);
}
._video-grid-custom_b2rnv_62 .ant-divider-horizontal.ant-divider-with-text {
  margin-bottom: 5px;
  margin-top: calc(10px - var(--row-gap));
}
._video-grid-custom_b2rnv_62 .ant-divider-horizontal.ant-divider-with-text:first-of-type {
  margin-top: 0;
}

@container (width >= 1276px) {
  ._video-grid_b2rnv_2._video-grid-custom_b2rnv_62 {
    --col: 5;
  }
}
@container (inline-size >= 2080px) {
  ._video-grid_b2rnv_2._video-grid-custom_b2rnv_62 {
    --col: 6;
  }
}
@container (inline-size >= 2465px) {
  ._video-grid_b2rnv_2._video-grid-custom_b2rnv_62 {
    --col: 7;
  }
}
@container (inline-size >= 2860px) {
  ._video-grid_b2rnv_2._video-grid-custom_b2rnv_62 {
    --col: 8;
  }
}
@container (inline-size >= 3265px) {
  ._video-grid_b2rnv_2._video-grid-custom_b2rnv_62 {
    --col: 9;
  }
}
@container (inline-size >= 3680px) {
  ._video-grid_b2rnv_2._video-grid-custom_b2rnv_62 {
    --col: 10;
  }
}
/**
 * \u53CC\u5217\u6A21\u5F0F
 */
._narrow-mode_b2rnv_112 {
  --col: 2 !important;
}*,::before,::after{--un-rotate:0;--un-rotate-x:0;--un-rotate-y:0;--un-rotate-z:0;--un-scale-x:1;--un-scale-y:1;--un-scale-z:1;--un-skew-x:0;--un-skew-y:0;--un-translate-x:0;--un-translate-y:0;--un-translate-z:0;--un-ring-offset-shadow:0 0 rgb(0 0 0 / 0);--un-ring-shadow:0 0 rgb(0 0 0 / 0);--un-shadow-inset: ;--un-shadow:0 0 rgb(0 0 0 / 0);--un-ring-inset: ;--un-ring-offset-width:0px;--un-ring-offset-color:#fff;--un-ring-width:0px;--un-ring-color:rgb(147 197 253 / 0.5);--un-blur: ;--un-brightness: ;--un-contrast: ;--un-drop-shadow: ;--un-grayscale: ;--un-hue-rotate: ;--un-invert: ;--un-saturate: ;--un-sepia: ;}::backdrop{--un-rotate:0;--un-rotate-x:0;--un-rotate-y:0;--un-rotate-z:0;--un-scale-x:1;--un-scale-y:1;--un-scale-z:1;--un-skew-x:0;--un-skew-y:0;--un-translate-x:0;--un-translate-y:0;--un-translate-z:0;--un-ring-offset-shadow:0 0 rgb(0 0 0 / 0);--un-ring-shadow:0 0 rgb(0 0 0 / 0);--un-shadow-inset: ;--un-shadow:0 0 rgb(0 0 0 / 0);--un-ring-inset: ;--un-ring-offset-width:0px;--un-ring-offset-color:#fff;--un-ring-width:0px;--un-ring-color:rgb(147 197 253 / 0.5);--un-blur: ;--un-brightness: ;--un-contrast: ;--un-drop-shadow: ;--un-grayscale: ;--un-hue-rotate: ;--un-invert: ;--un-saturate: ;--un-sepia: ;}.icon-only-round-button{width:32px;height:32px;display:flex;align-items:center;justify-content:center;border-radius:50%;padding:0;}.inline-icon-only-round-button{width:32px;height:32px;display:inline-flex;align-items:center;justify-content:center;border-radius:50%;padding:0;}.flex-center{display:flex;align-items:center;justify-content:center;}.flex-v-center{display:flex;align-items:center;}.inline-flex-center{display:inline-flex;align-items:center;justify-content:center;}.\\[refresh\\:scroll\\]{refresh:scroll;}.visible{visibility:visible;}.invisible{visibility:hidden;}.absolute{position:absolute;}.fixed{position:fixed;}.position-relative,.relative{position:relative;}.sticky{position:sticky;}.static{position:static;}.inset-0{inset:0;}.bottom-0{bottom:0;}.left-0{left:0;}.right-0{right:0;}.right-10px{right:10px;}.top-\\[-0\\.5px\\]{top:-0.5px;}.top-\\[-1px\\]{top:-1px;}.top-0\\.5px{top:0.5px;}.top-10px{top:10px;}.top-1px{top:1px;}.top-4px{top:4px;}.grid{display:grid;}.grid-col-span-full{grid-column:1/-1;}.grid-cols-\\[repeat\\(2\\,max-content\\)_1fr\\]{grid-template-columns:repeat(2,max-content) 1fr;}.grid-cols-2{grid-template-columns:repeat(2,minmax(0,1fr));}.grid-cols-5{grid-template-columns:repeat(5,minmax(0,1fr));}.m13{margin:52px;}.m14{margin:56px;}.m15{margin:60px;}.m16{margin:64px;}.m16\\.52{margin:66.08px;}.m160{margin:640px;}.m19{margin:76px;}.m19\\.833{margin:79.332px;}.m239\\.82{margin:959.28px;}.m24{margin:96px;}.m29\\.756{margin:119.024px;}.m33{margin:132px;}.m434\\.8{margin:1739.2px;}.m5{margin:20px;}.m8{margin:32px;}.m9{margin:36px;}.mx-0{margin-left:0;margin-right:0;}.mx-4px{margin-left:4px;margin-right:4px;}.mx-5px{margin-left:5px;margin-right:5px;}.mx-auto{margin-left:auto;margin-right:auto;}.my-0{margin-top:0;margin-bottom:0;}.my-2px{margin-top:2px;margin-bottom:2px;}.my-5px{margin-top:5px;margin-bottom:5px;}.my-7px{margin-top:7px;margin-bottom:7px;}.mb-0{margin-bottom:0;}.mb-10px{margin-bottom:10px;}.mb-20px{margin-bottom:20px;}.mb-2px{margin-bottom:2px;}.mb-40px{margin-bottom:40px;}.mb-5px{margin-bottom:5px;}.mb-8px{margin-bottom:8px;}.ml-10px{margin-left:10px;}.ml-12px{margin-left:12px;}.ml-15px{margin-left:15px;}.ml-1px{margin-left:1px;}.ml-20px{margin-left:20px;}.ml-2px{margin-left:2px;}.ml-30px{margin-left:30px;}.ml-4px{margin-left:4px;}.ml-5px{margin-left:5px;}.ml-6px{margin-left:6px;}.ml-8px{margin-left:8px;}.mr-0\\!{margin-right:0 !important;}.mr-10px{margin-right:10px;}.mr-24px{margin-right:24px;}.mr-2px{margin-right:2px;}.mr-4px{margin-right:4px;}.mr-5px{margin-right:5px;}.mr-6px{margin-right:6px;}.ms{margin-inline-start:16px;}.mt--1px{margin-top:-1px;}.mt--2px{margin-top:-2px;}.mt-10px{margin-top:10px;}.mt-15px{margin-top:15px;}.mt-20px{margin-top:20px;}.mt-2px{margin-top:2px;}.mt-3px{margin-top:3px;}.mt-4px{margin-top:4px;}.mt-6px{margin-top:6px;}.mt-8px{margin-top:8px;}.first\\:mt-0:first-child{margin-top:0;}.first\\:mt-0px:first-child{margin-top:0;}.box-content{box-sizing:content-box;}.block{display:block;}.inline-block{display:inline-block;}.contents{display:contents;}.hidden{display:none;}.aspect-1{aspect-ratio:1;}.aspect-ratio-10\\/16{aspect-ratio:10/16;}.size-12px{width:12px;height:12px;}.size-13px{width:13px;height:13px;}.size-14px{width:14px;height:14px;}.size-15px{width:15px;height:15px;}.size-16px{width:16px;height:16px;}.size-17px{width:17px;height:17px;}.size-18px{width:18px;height:18px;}.size-20px{width:20px;height:20px;}.size-25px{width:25px;height:25px;}.size-26px{width:26px;height:26px;}.size-28px{width:28px;height:28px;}.size-30px{width:30px;height:30px;}.size-32px{width:32px;height:32px;}.size-40px{width:40px;height:40px;}.size-full{width:100%;height:100%;}.h-0{height:0;}.h-100\\%,.h-full{height:100%;}.h-16px{height:16px;}.h-22px{height:22px;}.h-24px{height:24px;}.h-2px{height:2px;}.h-auto{height:auto;}.max-h-250px{max-height:250px;}.max-h-50vh{max-height:50vh;}.max-w-130px{max-width:130px;}.max-w-280px{max-width:280px;}.max-w-350px{max-width:350px;}.max-w-500px{max-width:500px;}.min-h-100vh{min-height:100vh;}.min-h-25px{min-height:25px;}.min-w-130px{min-width:130px;}.min-w-24px{min-width:24px;}.min-w-300px{min-width:300px;}.min-w-60px{min-width:60px;}.min-w-80px{min-width:80px;}.min-w-95px{min-width:95px;}.w-0{width:0;}.w-100\\%,.w-full{width:100%;}.w-114px{width:114px;}.w-130px{width:130px;}.w-150px{width:150px;}.w-160px{width:160px;}.w-34px{width:34px;}.flex{display:flex;}.inline-flex{display:inline-flex;}.flex-1{flex:1 1 0%;}.flex-none{flex:none;}.flex-shrink,.flex-shrink-1{flex-shrink:1;}.flex-shrink-0{flex-shrink:0;}.flex-basis-100\\%{flex-basis:100%;}.flex-row{flex-direction:row;}.flex-row-reverse{flex-direction:row-reverse;}.flex-col{flex-direction:column;}.flex-wrap{flex-wrap:wrap;}.rotate-0{--un-rotate-x:0;--un-rotate-y:0;--un-rotate-z:0;--un-rotate:0;transform:translateX(var(--un-translate-x)) translateY(var(--un-translate-y)) translateZ(var(--un-translate-z)) rotate(var(--un-rotate)) rotateX(var(--un-rotate-x)) rotateY(var(--un-rotate-y)) rotateZ(var(--un-rotate-z)) skewX(var(--un-skew-x)) skewY(var(--un-skew-y)) scaleX(var(--un-scale-x)) scaleY(var(--un-scale-y)) scaleZ(var(--un-scale-z));}.rotate-180{--un-rotate-x:0;--un-rotate-y:0;--un-rotate-z:0;--un-rotate:180deg;transform:translateX(var(--un-translate-x)) translateY(var(--un-translate-y)) translateZ(var(--un-translate-z)) rotate(var(--un-rotate)) rotateX(var(--un-rotate-x)) rotateY(var(--un-rotate-y)) rotateZ(var(--un-rotate-z)) skewX(var(--un-skew-x)) skewY(var(--un-skew-y)) scaleX(var(--un-scale-x)) scaleY(var(--un-scale-y)) scaleZ(var(--un-scale-z));}.rotate-z-0{--un-rotate:0;--un-rotate-z:0;transform:translateX(var(--un-translate-x)) translateY(var(--un-translate-y)) translateZ(var(--un-translate-z)) rotate(var(--un-rotate)) rotateX(var(--un-rotate-x)) rotateY(var(--un-rotate-y)) rotateZ(var(--un-rotate-z)) skewX(var(--un-skew-x)) skewY(var(--un-skew-y)) scaleX(var(--un-scale-x)) scaleY(var(--un-scale-y)) scaleZ(var(--un-scale-z));}.rotate-z-180deg{--un-rotate:0;--un-rotate-z:180deg;transform:translateX(var(--un-translate-x)) translateY(var(--un-translate-y)) translateZ(var(--un-translate-z)) rotate(var(--un-rotate)) rotateX(var(--un-rotate-x)) rotateY(var(--un-rotate-y)) rotateZ(var(--un-rotate-z)) skewX(var(--un-skew-x)) skewY(var(--un-skew-y)) scaleX(var(--un-scale-x)) scaleY(var(--un-scale-y)) scaleZ(var(--un-scale-z));}.transform{transform:translateX(var(--un-translate-x)) translateY(var(--un-translate-y)) translateZ(var(--un-translate-z)) rotate(var(--un-rotate)) rotateX(var(--un-rotate-x)) rotateY(var(--un-rotate-y)) rotateZ(var(--un-rotate-z)) skewX(var(--un-skew-x)) skewY(var(--un-skew-y)) scaleX(var(--un-scale-x)) scaleY(var(--un-scale-y)) scaleZ(var(--un-scale-z));}@keyframes spin{from{transform:rotate(0deg)}to{transform:rotate(360deg)}}.animate-spin{animation:spin 1s linear infinite;}.cursor-\\[edit\\]{cursor:edit;}.cursor-pointer{cursor:pointer;}.cursor-text{cursor:text;}.resize{resize:both;}.list-circle{list-style-type:circle;}.content-start{align-content:flex-start;}.items-start{align-items:flex-start;}.items-center{align-items:center;}.justify-start{justify-content:flex-start;}.justify-center{justify-content:center;}.justify-between{justify-content:space-between;}.justify-left{justify-content:left;}.gap-0{gap:0;}.gap-10px{gap:10px;}.gap-1px{gap:1px;}.gap-4px{gap:4px;}.gap-8px{gap:8px;}.gap-x-10px{column-gap:10px;}.gap-x-12px{column-gap:12px;}.gap-x-15px{column-gap:15px;}.gap-x-20px{column-gap:20px;}.gap-x-2px{column-gap:2px;}.gap-x-30px{column-gap:30px;}.gap-x-40px{column-gap:40px;}.gap-x-4px{column-gap:4px;}.gap-x-5px{column-gap:5px;}.gap-x-6px{column-gap:6px;}.gap-x-8px{column-gap:8px;}.gap-y-10px{row-gap:10px;}.gap-y-15px{row-gap:15px;}.gap-y-2px{row-gap:2px;}.gap-y-3px{row-gap:3px;}.gap-y-4px{row-gap:4px;}.gap-y-5px{row-gap:5px;}.gap-y-6px{row-gap:6px;}.gap-y-8px{row-gap:8px;}.overflow-hidden{overflow:hidden;}.overflow-y-auto{overflow-y:auto;}.overflow-y-scroll{overflow-y:scroll;}.text-ellipsis{text-overflow:ellipsis;}.whitespace-nowrap{white-space:nowrap;}.whitespace-pre-wrap{white-space:pre-wrap;}.break-normal{overflow-wrap:normal;word-break:normal;}.b-1px,.border{border-width:1px;}.b-2px{border-width:2px;}.b-\\#444{--un-border-opacity:1;border-color:rgb(68 68 68 / var(--un-border-opacity));}.b-gate-border{border-color:var(--bilibili-gate--border-color);}.b-gate-primary{border-color:var(--bilibili-gate--color-primary);}.b-transparent{border-color:transparent;}.hover\\:b-gate-primary:hover{border-color:var(--bilibili-gate--color-primary);}.rounded{border-radius:4px;}.rounded-15px{border-radius:15px;}.rounded-20px{border-radius:20px;}.rounded-2px{border-radius:2px;}.rounded-5px{border-radius:5px;}.rounded-6px{border-radius:6px;}.rounded-8px{border-radius:8px;}.rounded-full{border-radius:9999px;}.b-solid{border-style:solid;}.bg-\\[rgb\\(33_33_33_\\/_0\\.7\\)\\]{--un-bg-opacity:0.7;background-color:rgb(33 33 33 / var(--un-bg-opacity)) /* rgb(33 33 33 / 0.7) */;}.bg-black\\/10{background-color:rgb(0 0 0 / 0.1) /* #000 */;}.bg-gate-primary{background-color:var(--bilibili-gate--color-primary) /* var(--bilibili-gate--color-primary) */;}.fill-gate-primary{fill:var(--bilibili-gate--color-primary) /* var(--bilibili-gate--color-primary) */;}.fill-none{fill:none;}.object-cover{object-fit:cover;}.object-contain{object-fit:contain;}.p-0{padding:0;}.p-10px{padding:10px;}.p-1px{padding:1px;}.p-20px{padding:20px;}.p-8px{padding:8px;}.px,.px-16px{padding-left:16px;padding-right:16px;}.px-0{padding-left:0;padding-right:0;}.px-2px{padding-left:2px;padding-right:2px;}.px-4px{padding-left:4px;padding-right:4px;}.px-5px{padding-left:5px;padding-right:5px;}.px-6px{padding-left:6px;padding-right:6px;}.py-0{padding-top:0;padding-bottom:0;}.py-10px{padding-top:10px;padding-bottom:10px;}.py-12px{padding-top:12px;padding-bottom:12px;}.py-1px{padding-top:1px;padding-bottom:1px;}.py-2px{padding-top:2px;padding-bottom:2px;}.py-30px{padding-top:30px;padding-bottom:30px;}.py-5px{padding-top:5px;padding-bottom:5px;}.py-8px{padding-top:8px;padding-bottom:8px;}.pb-2px{padding-bottom:2px;}.pb1257{padding-bottom:5028px;}.pl-16px{padding-left:16px;}.pl-2px{padding-left:2px;}.pl-4px{padding-left:4px;}.pl-5px{padding-left:5px;}.pl-6px{padding-left:6px;}.pr-10px{padding-right:10px;}.pr-15px{padding-right:15px;}.pr-6px{padding-right:6px;}.ps{padding-inline-start:16px;}.pt-5px{padding-top:5px;}.first\\:pt-0:first-child{padding-top:0;}.text-center{text-align:center;}.text-20px,.text-size-20px{font-size:20px;}.font-size-11px,.text-size-11px{font-size:11px;}.text-size-0{font-size:0;}.text-size-1\\.3em{font-size:1.3em;}.text-size-1\\.5em{font-size:1.5em;}.text-size-10px{font-size:10px;}.text-size-120\\%{font-size:120%;}.text-size-12px{font-size:12px;}.text-size-13px{font-size:13px;}.text-size-14px{font-size:14px;}.text-size-16px{font-size:16px;}.color-gate-primary,.text-gate-primary{color:var(--bilibili-gate--color-primary) /* var(--bilibili-gate--color-primary) */;}.color-white,.text-white{--un-text-opacity:1;color:rgb(255 255 255 / var(--un-text-opacity)) /* #fff */;}.hover\\:color-gate-primary:hover{color:var(--bilibili-gate--color-primary) /* var(--bilibili-gate--color-primary) */;}.font-normal{font-weight:400;}.line-height-\\[0\\]{line-height:0;}.line-height-\\[1\\]{line-height:1;}.line-height-\\[17px\\]{line-height:17px;}.line-height-\\[unset\\],.line-height-unset{line-height:unset;}.line-height-16px{line-height:16px;}.line-height-18px{line-height:18px;}.tab{-moz-tab-size:4;-o-tab-size:4;tab-size:4;}.shadow{--un-shadow:var(--un-shadow-inset) 0 1px 3px 0 var(--un-shadow-color, rgb(0 0 0 / 0.1)),var(--un-shadow-inset) 0 1px 2px -1px var(--un-shadow-color, rgb(0 0 0 / 0.1));box-shadow:var(--un-ring-offset-shadow), var(--un-ring-shadow), var(--un-shadow);}.ring-1px{--un-ring-width:1px;--un-ring-offset-shadow:var(--un-ring-inset) 0 0 0 var(--un-ring-offset-width) var(--un-ring-offset-color);--un-ring-shadow:var(--un-ring-inset) 0 0 0 calc(var(--un-ring-width) + var(--un-ring-offset-width)) var(--un-ring-color);box-shadow:var(--un-ring-offset-shadow), var(--un-ring-shadow), var(--un-shadow);}.ring-gate-border{--un-ring-color:var(--bilibili-gate--border-color) /* var(--bilibili-gate--border-color) */;}.filter{filter:var(--un-blur) var(--un-brightness) var(--un-contrast) var(--un-drop-shadow) var(--un-grayscale) var(--un-hue-rotate) var(--un-invert) var(--un-saturate) var(--un-sepia);}.transition{transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,backdrop-filter;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transition-duration:150ms;}.transition-300{transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,backdrop-filter;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transition-duration:300ms;}.transition-transform{transition-property:transform;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transition-duration:150ms;}.ease,.ease-in-out{transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);}.ease-out{transition-timing-function:cubic-bezier(0, 0, 0.2, 1);}@media (min-width: 1280px){.xl\\:gap-x-8px{column-gap:8px;}}body .bili-video-card__skeleton--cover, body .bili-video-card__skeleton--text, body .bili-video-card__skeleton--light, body .bili-video-card__skeleton--avatar {
  background: linear-gradient(135deg, rgba(0, 0, 0, 0.06) 25%, rgba(0, 0, 0, 0.15) 37%, rgba(0, 0, 0, 0.06) 63%);
}
html.bilibili-gate-dark .bili-video-card__skeleton--avatar {
  background-color: #444;
}
.bili-video-card__skeleton--text.tiny {
  margin-top: 4px;
  width: 15%;
}

._skeleton-active_g6pzk_15 .bili-video-card__skeleton--cover,
._skeleton-active_g6pzk_15 .bili-video-card__skeleton--text,
._skeleton-active_g6pzk_15 .bili-video-card__skeleton--light,
._skeleton-active_g6pzk_15 .bili-video-card__skeleton--avatar {
  background-size: 400% 100%;
  animation-name: _ant-skeleton-loading_g6pzk_1;
  animation-duration: 2s;
  animation-timing-function: ease;
  animation-iteration-count: infinite;
}

@keyframes _ant-skeleton-loading_g6pzk_1 {
  0% {
    background-position: 100% 50%;
  }
  80%, 100% {
    background-position: 0 50%;
  }
} `);

(async function (dayjs, duration, H, UAParser, antd, axios, cssinjs, zhCN, require$$0, framerMotion, localforage) {
  'use strict';

  function _interopNamespaceDefault(e) {
    const n = Object.create(null, { [Symbol.toStringTag]: { value: 'Module' } });
    if (e) {
      for (const k in e) {
        if (k !== 'default') {
          const d = Object.getOwnPropertyDescriptor(e, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: true,
            get: () => e[k]
          });
        }
      }
    }
    n.default = e;
    return Object.freeze(n);
  }

  const H__namespace = /*#__PURE__*/_interopNamespaceDefault(H);

  var __defProp = Object.defineProperty;
  var __typeError = (msg) => {
    throw TypeError(msg);
  };
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
  var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
  var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
  var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), member.set(obj, value), value);
  var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
  var __privateWrapper = (obj, member, setter, getter) => ({
    set _(value) {
      __privateSet(obj, member, value);
    },
    get _() {
      return __privateGet(obj, member, getter);
    }
  });
  var _a, _head, _tail, _size, _size2, _cache, _oldCache, _maxSize, _maxAge, _onEviction, _QuickLRU_instances, emitEvictions_fn, deleteIfExpired_fn, getOrDeleteIfExpired_fn, getItemValue_fn, peek_fn, set_fn, moveToRecent_fn, entriesAscending_fn, _b, _c, _d, _e;
  var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  function getDefaultExportFromCjs(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
  }
  var fails;
  var hasRequiredFails;
  function requireFails() {
    if (hasRequiredFails) return fails;
    hasRequiredFails = 1;
    fails = function(exec) {
      try {
        return !!exec();
      } catch (error) {
        return true;
      }
    };
    return fails;
  }
  var isCallable;
  var hasRequiredIsCallable;
  function requireIsCallable() {
    if (hasRequiredIsCallable) return isCallable;
    hasRequiredIsCallable = 1;
    var documentAll = typeof document == "object" && document.all;
    isCallable = typeof documentAll == "undefined" && documentAll !== void 0 ? function(argument) {
      return typeof argument == "function" || argument === documentAll;
    } : function(argument) {
      return typeof argument == "function";
    };
    return isCallable;
  }
  var isForced_1;
  var hasRequiredIsForced;
  function requireIsForced() {
    if (hasRequiredIsForced) return isForced_1;
    hasRequiredIsForced = 1;
    var fails2 = /* @__PURE__ */ requireFails();
    var isCallable2 = /* @__PURE__ */ requireIsCallable();
    var replacement = /#|\.prototype\./;
    var isForced2 = function(feature, detection) {
      var value = data2[normalize(feature)];
      return value === POLYFILL ? true : value === NATIVE ? false : isCallable2(detection) ? fails2(detection) : !!detection;
    };
    var normalize = isForced2.normalize = function(string) {
      return String(string).replace(replacement, ".").toLowerCase();
    };
    var data2 = isForced2.data = {};
    var NATIVE = isForced2.NATIVE = "N";
    var POLYFILL = isForced2.POLYFILL = "P";
    isForced_1 = isForced2;
    return isForced_1;
  }
  var isForcedExports = /* @__PURE__ */ requireIsForced();
  const isForced = /* @__PURE__ */ getDefaultExportFromCjs(isForcedExports);
  Symbol.dispose || (Symbol.dispose = Symbol.for("Symbol.dispose"));
  Symbol.asyncDispose || (Symbol.asyncDispose = Symbol.for("Symbol.asyncDispose"));
  function forceUsePolyfill(globalName) {
    isForced.data[globalName.toLowerCase()] = isForced.POLYFILL;
  }
  forceUsePolyfill("DisposableStack");
  forceUsePolyfill("AsyncDisposableStack");
  var es_error_cause = {};
  var globalThis_1;
  var hasRequiredGlobalThis;
  function requireGlobalThis() {
    if (hasRequiredGlobalThis) return globalThis_1;
    hasRequiredGlobalThis = 1;
    var check = function(it) {
      return it && it.Math === Math && it;
    };
    globalThis_1 = // eslint-disable-next-line es/no-global-this -- safe
    check(typeof globalThis == "object" && globalThis) || check(typeof window == "object" && window) || // eslint-disable-next-line no-restricted-globals -- safe
    check(typeof self == "object" && self) || check(typeof commonjsGlobal == "object" && commonjsGlobal) || check(typeof globalThis_1 == "object" && globalThis_1) || // eslint-disable-next-line no-new-func -- fallback
    /* @__PURE__ */ function() {
      return this;
    }() || Function("return this")();
    return globalThis_1;
  }
  var functionBindNative;
  var hasRequiredFunctionBindNative;
  function requireFunctionBindNative() {
    if (hasRequiredFunctionBindNative) return functionBindNative;
    hasRequiredFunctionBindNative = 1;
    var fails2 = /* @__PURE__ */ requireFails();
    functionBindNative = !fails2(function() {
      var test = (function() {
      }).bind();
      return typeof test != "function" || test.hasOwnProperty("prototype");
    });
    return functionBindNative;
  }
  var functionApply;
  var hasRequiredFunctionApply;
  function requireFunctionApply() {
    if (hasRequiredFunctionApply) return functionApply;
    hasRequiredFunctionApply = 1;
    var NATIVE_BIND = /* @__PURE__ */ requireFunctionBindNative();
    var FunctionPrototype = Function.prototype;
    var apply = FunctionPrototype.apply;
    var call = FunctionPrototype.call;
    functionApply = typeof Reflect == "object" && Reflect.apply || (NATIVE_BIND ? call.bind(apply) : function() {
      return call.apply(apply, arguments);
    });
    return functionApply;
  }
  var functionUncurryThis;
  var hasRequiredFunctionUncurryThis;
  function requireFunctionUncurryThis() {
    if (hasRequiredFunctionUncurryThis) return functionUncurryThis;
    hasRequiredFunctionUncurryThis = 1;
    var NATIVE_BIND = /* @__PURE__ */ requireFunctionBindNative();
    var FunctionPrototype = Function.prototype;
    var call = FunctionPrototype.call;
    var uncurryThisWithBind = NATIVE_BIND && FunctionPrototype.bind.bind(call, call);
    functionUncurryThis = NATIVE_BIND ? uncurryThisWithBind : function(fn) {
      return function() {
        return call.apply(fn, arguments);
      };
    };
    return functionUncurryThis;
  }
  var classofRaw;
  var hasRequiredClassofRaw;
  function requireClassofRaw() {
    if (hasRequiredClassofRaw) return classofRaw;
    hasRequiredClassofRaw = 1;
    var uncurryThis = /* @__PURE__ */ requireFunctionUncurryThis();
    var toString2 = uncurryThis({}.toString);
    var stringSlice = uncurryThis("".slice);
    classofRaw = function(it) {
      return stringSlice(toString2(it), 8, -1);
    };
    return classofRaw;
  }
  var functionUncurryThisClause;
  var hasRequiredFunctionUncurryThisClause;
  function requireFunctionUncurryThisClause() {
    if (hasRequiredFunctionUncurryThisClause) return functionUncurryThisClause;
    hasRequiredFunctionUncurryThisClause = 1;
    var classofRaw2 = /* @__PURE__ */ requireClassofRaw();
    var uncurryThis = /* @__PURE__ */ requireFunctionUncurryThis();
    functionUncurryThisClause = function(fn) {
      if (classofRaw2(fn) === "Function") return uncurryThis(fn);
    };
    return functionUncurryThisClause;
  }
  var objectGetOwnPropertyDescriptor = {};
  var descriptors;
  var hasRequiredDescriptors;
  function requireDescriptors() {
    if (hasRequiredDescriptors) return descriptors;
    hasRequiredDescriptors = 1;
    var fails2 = /* @__PURE__ */ requireFails();
    descriptors = !fails2(function() {
      return Object.defineProperty({}, 1, { get: function() {
        return 7;
      } })[1] !== 7;
    });
    return descriptors;
  }
  var functionCall;
  var hasRequiredFunctionCall;
  function requireFunctionCall() {
    if (hasRequiredFunctionCall) return functionCall;
    hasRequiredFunctionCall = 1;
    var NATIVE_BIND = /* @__PURE__ */ requireFunctionBindNative();
    var call = Function.prototype.call;
    functionCall = NATIVE_BIND ? call.bind(call) : function() {
      return call.apply(call, arguments);
    };
    return functionCall;
  }
  var objectPropertyIsEnumerable = {};
  var hasRequiredObjectPropertyIsEnumerable;
  function requireObjectPropertyIsEnumerable() {
    if (hasRequiredObjectPropertyIsEnumerable) return objectPropertyIsEnumerable;
    hasRequiredObjectPropertyIsEnumerable = 1;
    var $propertyIsEnumerable = {}.propertyIsEnumerable;
    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);
    objectPropertyIsEnumerable.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
      var descriptor = getOwnPropertyDescriptor(this, V);
      return !!descriptor && descriptor.enumerable;
    } : $propertyIsEnumerable;
    return objectPropertyIsEnumerable;
  }
  var createPropertyDescriptor;
  var hasRequiredCreatePropertyDescriptor;
  function requireCreatePropertyDescriptor() {
    if (hasRequiredCreatePropertyDescriptor) return createPropertyDescriptor;
    hasRequiredCreatePropertyDescriptor = 1;
    createPropertyDescriptor = function(bitmap, value) {
      return {
        enumerable: !(bitmap & 1),
        configurable: !(bitmap & 2),
        writable: !(bitmap & 4),
        value
      };
    };
    return createPropertyDescriptor;
  }
  var indexedObject;
  var hasRequiredIndexedObject;
  function requireIndexedObject() {
    if (hasRequiredIndexedObject) return indexedObject;
    hasRequiredIndexedObject = 1;
    var uncurryThis = /* @__PURE__ */ requireFunctionUncurryThis();
    var fails2 = /* @__PURE__ */ requireFails();
    var classof2 = /* @__PURE__ */ requireClassofRaw();
    var $Object = Object;
    var split = uncurryThis("".split);
    indexedObject = fails2(function() {
      return !$Object("z").propertyIsEnumerable(0);
    }) ? function(it) {
      return classof2(it) === "String" ? split(it, "") : $Object(it);
    } : $Object;
    return indexedObject;
  }
  var isNullOrUndefined;
  var hasRequiredIsNullOrUndefined;
  function requireIsNullOrUndefined() {
    if (hasRequiredIsNullOrUndefined) return isNullOrUndefined;
    hasRequiredIsNullOrUndefined = 1;
    isNullOrUndefined = function(it) {
      return it === null || it === void 0;
    };
    return isNullOrUndefined;
  }
  var requireObjectCoercible;
  var hasRequiredRequireObjectCoercible;
  function requireRequireObjectCoercible() {
    if (hasRequiredRequireObjectCoercible) return requireObjectCoercible;
    hasRequiredRequireObjectCoercible = 1;
    var isNullOrUndefined2 = /* @__PURE__ */ requireIsNullOrUndefined();
    var $TypeError = TypeError;
    requireObjectCoercible = function(it) {
      if (isNullOrUndefined2(it)) throw new $TypeError("Can't call method on " + it);
      return it;
    };
    return requireObjectCoercible;
  }
  var toIndexedObject;
  var hasRequiredToIndexedObject;
  function requireToIndexedObject() {
    if (hasRequiredToIndexedObject) return toIndexedObject;
    hasRequiredToIndexedObject = 1;
    var IndexedObject = /* @__PURE__ */ requireIndexedObject();
    var requireObjectCoercible2 = /* @__PURE__ */ requireRequireObjectCoercible();
    toIndexedObject = function(it) {
      return IndexedObject(requireObjectCoercible2(it));
    };
    return toIndexedObject;
  }
  var isObject$3;
  var hasRequiredIsObject$1;
  function requireIsObject$1() {
    if (hasRequiredIsObject$1) return isObject$3;
    hasRequiredIsObject$1 = 1;
    var isCallable2 = /* @__PURE__ */ requireIsCallable();
    isObject$3 = function(it) {
      return typeof it == "object" ? it !== null : isCallable2(it);
    };
    return isObject$3;
  }
  var path;
  var hasRequiredPath;
  function requirePath() {
    if (hasRequiredPath) return path;
    hasRequiredPath = 1;
    path = {};
    return path;
  }
  var getBuiltIn;
  var hasRequiredGetBuiltIn;
  function requireGetBuiltIn() {
    if (hasRequiredGetBuiltIn) return getBuiltIn;
    hasRequiredGetBuiltIn = 1;
    var path2 = /* @__PURE__ */ requirePath();
    var globalThis2 = /* @__PURE__ */ requireGlobalThis();
    var isCallable2 = /* @__PURE__ */ requireIsCallable();
    var aFunction = function(variable) {
      return isCallable2(variable) ? variable : void 0;
    };
    getBuiltIn = function(namespace, method) {
      return arguments.length < 2 ? aFunction(path2[namespace]) || aFunction(globalThis2[namespace]) : path2[namespace] && path2[namespace][method] || globalThis2[namespace] && globalThis2[namespace][method];
    };
    return getBuiltIn;
  }
  var objectIsPrototypeOf;
  var hasRequiredObjectIsPrototypeOf;
  function requireObjectIsPrototypeOf() {
    if (hasRequiredObjectIsPrototypeOf) return objectIsPrototypeOf;
    hasRequiredObjectIsPrototypeOf = 1;
    var uncurryThis = /* @__PURE__ */ requireFunctionUncurryThis();
    objectIsPrototypeOf = uncurryThis({}.isPrototypeOf);
    return objectIsPrototypeOf;
  }
  var environmentUserAgent;
  var hasRequiredEnvironmentUserAgent;
  function requireEnvironmentUserAgent() {
    if (hasRequiredEnvironmentUserAgent) return environmentUserAgent;
    hasRequiredEnvironmentUserAgent = 1;
    var globalThis2 = /* @__PURE__ */ requireGlobalThis();
    var navigator2 = globalThis2.navigator;
    var userAgent = navigator2 && navigator2.userAgent;
    environmentUserAgent = userAgent ? String(userAgent) : "";
    return environmentUserAgent;
  }
  var environmentV8Version;
  var hasRequiredEnvironmentV8Version;
  function requireEnvironmentV8Version() {
    if (hasRequiredEnvironmentV8Version) return environmentV8Version;
    hasRequiredEnvironmentV8Version = 1;
    var globalThis2 = /* @__PURE__ */ requireGlobalThis();
    var userAgent = /* @__PURE__ */ requireEnvironmentUserAgent();
    var process2 = globalThis2.process;
    var Deno = globalThis2.Deno;
    var versions = process2 && process2.versions || Deno && Deno.version;
    var v8 = versions && versions.v8;
    var match2, version;
    if (v8) {
      match2 = v8.split(".");
      version = match2[0] > 0 && match2[0] < 4 ? 1 : +(match2[0] + match2[1]);
    }
    if (!version && userAgent) {
      match2 = userAgent.match(/Edge\/(\d+)/);
      if (!match2 || match2[1] >= 74) {
        match2 = userAgent.match(/Chrome\/(\d+)/);
        if (match2) version = +match2[1];
      }
    }
    environmentV8Version = version;
    return environmentV8Version;
  }
  var symbolConstructorDetection;
  var hasRequiredSymbolConstructorDetection;
  function requireSymbolConstructorDetection() {
    if (hasRequiredSymbolConstructorDetection) return symbolConstructorDetection;
    hasRequiredSymbolConstructorDetection = 1;
    var V8_VERSION = /* @__PURE__ */ requireEnvironmentV8Version();
    var fails2 = /* @__PURE__ */ requireFails();
    var globalThis2 = /* @__PURE__ */ requireGlobalThis();
    var $String = globalThis2.String;
    symbolConstructorDetection = !!Object.getOwnPropertySymbols && !fails2(function() {
      var symbol = Symbol("symbol detection");
      return !$String(symbol) || !(Object(symbol) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
      !Symbol.sham && V8_VERSION && V8_VERSION < 41;
    });
    return symbolConstructorDetection;
  }
  var useSymbolAsUid;
  var hasRequiredUseSymbolAsUid;
  function requireUseSymbolAsUid() {
    if (hasRequiredUseSymbolAsUid) return useSymbolAsUid;
    hasRequiredUseSymbolAsUid = 1;
    var NATIVE_SYMBOL = /* @__PURE__ */ requireSymbolConstructorDetection();
    useSymbolAsUid = NATIVE_SYMBOL && !Symbol.sham && typeof Symbol.iterator == "symbol";
    return useSymbolAsUid;
  }
  var isSymbol$1;
  var hasRequiredIsSymbol$1;
  function requireIsSymbol$1() {
    if (hasRequiredIsSymbol$1) return isSymbol$1;
    hasRequiredIsSymbol$1 = 1;
    var getBuiltIn2 = /* @__PURE__ */ requireGetBuiltIn();
    var isCallable2 = /* @__PURE__ */ requireIsCallable();
    var isPrototypeOf = /* @__PURE__ */ requireObjectIsPrototypeOf();
    var USE_SYMBOL_AS_UID = /* @__PURE__ */ requireUseSymbolAsUid();
    var $Object = Object;
    isSymbol$1 = USE_SYMBOL_AS_UID ? function(it) {
      return typeof it == "symbol";
    } : function(it) {
      var $Symbol = getBuiltIn2("Symbol");
      return isCallable2($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));
    };
    return isSymbol$1;
  }
  var tryToString;
  var hasRequiredTryToString;
  function requireTryToString() {
    if (hasRequiredTryToString) return tryToString;
    hasRequiredTryToString = 1;
    var $String = String;
    tryToString = function(argument) {
      try {
        return $String(argument);
      } catch (error) {
        return "Object";
      }
    };
    return tryToString;
  }
  var aCallable;
  var hasRequiredACallable;
  function requireACallable() {
    if (hasRequiredACallable) return aCallable;
    hasRequiredACallable = 1;
    var isCallable2 = /* @__PURE__ */ requireIsCallable();
    var tryToString2 = /* @__PURE__ */ requireTryToString();
    var $TypeError = TypeError;
    aCallable = function(argument) {
      if (isCallable2(argument)) return argument;
      throw new $TypeError(tryToString2(argument) + " is not a function");
    };
    return aCallable;
  }
  var getMethod;
  var hasRequiredGetMethod;
  function requireGetMethod() {
    if (hasRequiredGetMethod) return getMethod;
    hasRequiredGetMethod = 1;
    var aCallable2 = /* @__PURE__ */ requireACallable();
    var isNullOrUndefined2 = /* @__PURE__ */ requireIsNullOrUndefined();
    getMethod = function(V, P) {
      var func = V[P];
      return isNullOrUndefined2(func) ? void 0 : aCallable2(func);
    };
    return getMethod;
  }
  var ordinaryToPrimitive;
  var hasRequiredOrdinaryToPrimitive;
  function requireOrdinaryToPrimitive() {
    if (hasRequiredOrdinaryToPrimitive) return ordinaryToPrimitive;
    hasRequiredOrdinaryToPrimitive = 1;
    var call = /* @__PURE__ */ requireFunctionCall();
    var isCallable2 = /* @__PURE__ */ requireIsCallable();
    var isObject2 = /* @__PURE__ */ requireIsObject$1();
    var $TypeError = TypeError;
    ordinaryToPrimitive = function(input, pref) {
      var fn, val;
      if (pref === "string" && isCallable2(fn = input.toString) && !isObject2(val = call(fn, input))) return val;
      if (isCallable2(fn = input.valueOf) && !isObject2(val = call(fn, input))) return val;
      if (pref !== "string" && isCallable2(fn = input.toString) && !isObject2(val = call(fn, input))) return val;
      throw new $TypeError("Can't convert object to primitive value");
    };
    return ordinaryToPrimitive;
  }
  var sharedStore = { exports: {} };
  var isPure;
  var hasRequiredIsPure;
  function requireIsPure() {
    if (hasRequiredIsPure) return isPure;
    hasRequiredIsPure = 1;
    isPure = true;
    return isPure;
  }
  var defineGlobalProperty;
  var hasRequiredDefineGlobalProperty;
  function requireDefineGlobalProperty() {
    if (hasRequiredDefineGlobalProperty) return defineGlobalProperty;
    hasRequiredDefineGlobalProperty = 1;
    var globalThis2 = /* @__PURE__ */ requireGlobalThis();
    var defineProperty = Object.defineProperty;
    defineGlobalProperty = function(key, value) {
      try {
        defineProperty(globalThis2, key, { value, configurable: true, writable: true });
      } catch (error) {
        globalThis2[key] = value;
      }
      return value;
    };
    return defineGlobalProperty;
  }
  var hasRequiredSharedStore;
  function requireSharedStore() {
    if (hasRequiredSharedStore) return sharedStore.exports;
    hasRequiredSharedStore = 1;
    var IS_PURE = /* @__PURE__ */ requireIsPure();
    var globalThis2 = /* @__PURE__ */ requireGlobalThis();
    var defineGlobalProperty2 = /* @__PURE__ */ requireDefineGlobalProperty();
    var SHARED = "__core-js_shared__";
    var store2 = sharedStore.exports = globalThis2[SHARED] || defineGlobalProperty2(SHARED, {});
    (store2.versions || (store2.versions = [])).push({
      version: "3.42.0",
      mode: IS_PURE ? "pure" : "global",
      copyright: "© 2014-2025 Denis Pushkarev (zloirock.ru)",
      license: "https://github.com/zloirock/core-js/blob/v3.42.0/LICENSE",
      source: "https://github.com/zloirock/core-js"
    });
    return sharedStore.exports;
  }
  var shared;
  var hasRequiredShared;
  function requireShared() {
    if (hasRequiredShared) return shared;
    hasRequiredShared = 1;
    var store2 = /* @__PURE__ */ requireSharedStore();
    shared = function(key, value) {
      return store2[key] || (store2[key] = value || {});
    };
    return shared;
  }
  var toObject;
  var hasRequiredToObject;
  function requireToObject() {
    if (hasRequiredToObject) return toObject;
    hasRequiredToObject = 1;
    var requireObjectCoercible2 = /* @__PURE__ */ requireRequireObjectCoercible();
    var $Object = Object;
    toObject = function(argument) {
      return $Object(requireObjectCoercible2(argument));
    };
    return toObject;
  }
  var hasOwnProperty_1;
  var hasRequiredHasOwnProperty;
  function requireHasOwnProperty() {
    if (hasRequiredHasOwnProperty) return hasOwnProperty_1;
    hasRequiredHasOwnProperty = 1;
    var uncurryThis = /* @__PURE__ */ requireFunctionUncurryThis();
    var toObject2 = /* @__PURE__ */ requireToObject();
    var hasOwnProperty = uncurryThis({}.hasOwnProperty);
    hasOwnProperty_1 = Object.hasOwn || function hasOwn2(it, key) {
      return hasOwnProperty(toObject2(it), key);
    };
    return hasOwnProperty_1;
  }
  var uid;
  var hasRequiredUid;
  function requireUid() {
    if (hasRequiredUid) return uid;
    hasRequiredUid = 1;
    var uncurryThis = /* @__PURE__ */ requireFunctionUncurryThis();
    var id = 0;
    var postfix = Math.random();
    var toString2 = uncurryThis(1 .toString);
    uid = function(key) {
      return "Symbol(" + (key === void 0 ? "" : key) + ")_" + toString2(++id + postfix, 36);
    };
    return uid;
  }
  var wellKnownSymbol;
  var hasRequiredWellKnownSymbol;
  function requireWellKnownSymbol() {
    if (hasRequiredWellKnownSymbol) return wellKnownSymbol;
    hasRequiredWellKnownSymbol = 1;
    var globalThis2 = /* @__PURE__ */ requireGlobalThis();
    var shared2 = /* @__PURE__ */ requireShared();
    var hasOwn2 = /* @__PURE__ */ requireHasOwnProperty();
    var uid2 = /* @__PURE__ */ requireUid();
    var NATIVE_SYMBOL = /* @__PURE__ */ requireSymbolConstructorDetection();
    var USE_SYMBOL_AS_UID = /* @__PURE__ */ requireUseSymbolAsUid();
    var Symbol2 = globalThis2.Symbol;
    var WellKnownSymbolsStore = shared2("wks");
    var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol2["for"] || Symbol2 : Symbol2 && Symbol2.withoutSetter || uid2;
    wellKnownSymbol = function(name) {
      if (!hasOwn2(WellKnownSymbolsStore, name)) {
        WellKnownSymbolsStore[name] = NATIVE_SYMBOL && hasOwn2(Symbol2, name) ? Symbol2[name] : createWellKnownSymbol("Symbol." + name);
      }
      return WellKnownSymbolsStore[name];
    };
    return wellKnownSymbol;
  }
  var toPrimitive;
  var hasRequiredToPrimitive;
  function requireToPrimitive() {
    if (hasRequiredToPrimitive) return toPrimitive;
    hasRequiredToPrimitive = 1;
    var call = /* @__PURE__ */ requireFunctionCall();
    var isObject2 = /* @__PURE__ */ requireIsObject$1();
    var isSymbol2 = /* @__PURE__ */ requireIsSymbol$1();
    var getMethod2 = /* @__PURE__ */ requireGetMethod();
    var ordinaryToPrimitive2 = /* @__PURE__ */ requireOrdinaryToPrimitive();
    var wellKnownSymbol2 = /* @__PURE__ */ requireWellKnownSymbol();
    var $TypeError = TypeError;
    var TO_PRIMITIVE = wellKnownSymbol2("toPrimitive");
    toPrimitive = function(input, pref) {
      if (!isObject2(input) || isSymbol2(input)) return input;
      var exoticToPrim = getMethod2(input, TO_PRIMITIVE);
      var result;
      if (exoticToPrim) {
        if (pref === void 0) pref = "default";
        result = call(exoticToPrim, input, pref);
        if (!isObject2(result) || isSymbol2(result)) return result;
        throw new $TypeError("Can't convert object to primitive value");
      }
      if (pref === void 0) pref = "number";
      return ordinaryToPrimitive2(input, pref);
    };
    return toPrimitive;
  }
  var toPropertyKey;
  var hasRequiredToPropertyKey;
  function requireToPropertyKey() {
    if (hasRequiredToPropertyKey) return toPropertyKey;
    hasRequiredToPropertyKey = 1;
    var toPrimitive2 = /* @__PURE__ */ requireToPrimitive();
    var isSymbol2 = /* @__PURE__ */ requireIsSymbol$1();
    toPropertyKey = function(argument) {
      var key = toPrimitive2(argument, "string");
      return isSymbol2(key) ? key : key + "";
    };
    return toPropertyKey;
  }
  var documentCreateElement;
  var hasRequiredDocumentCreateElement;
  function requireDocumentCreateElement() {
    if (hasRequiredDocumentCreateElement) return documentCreateElement;
    hasRequiredDocumentCreateElement = 1;
    var globalThis2 = /* @__PURE__ */ requireGlobalThis();
    var isObject2 = /* @__PURE__ */ requireIsObject$1();
    var document2 = globalThis2.document;
    var EXISTS = isObject2(document2) && isObject2(document2.createElement);
    documentCreateElement = function(it) {
      return EXISTS ? document2.createElement(it) : {};
    };
    return documentCreateElement;
  }
  var ie8DomDefine;
  var hasRequiredIe8DomDefine;
  function requireIe8DomDefine() {
    if (hasRequiredIe8DomDefine) return ie8DomDefine;
    hasRequiredIe8DomDefine = 1;
    var DESCRIPTORS = /* @__PURE__ */ requireDescriptors();
    var fails2 = /* @__PURE__ */ requireFails();
    var createElement = /* @__PURE__ */ requireDocumentCreateElement();
    ie8DomDefine = !DESCRIPTORS && !fails2(function() {
      return Object.defineProperty(createElement("div"), "a", {
        get: function() {
          return 7;
        }
      }).a !== 7;
    });
    return ie8DomDefine;
  }
  var hasRequiredObjectGetOwnPropertyDescriptor;
  function requireObjectGetOwnPropertyDescriptor() {
    if (hasRequiredObjectGetOwnPropertyDescriptor) return objectGetOwnPropertyDescriptor;
    hasRequiredObjectGetOwnPropertyDescriptor = 1;
    var DESCRIPTORS = /* @__PURE__ */ requireDescriptors();
    var call = /* @__PURE__ */ requireFunctionCall();
    var propertyIsEnumerableModule = /* @__PURE__ */ requireObjectPropertyIsEnumerable();
    var createPropertyDescriptor2 = /* @__PURE__ */ requireCreatePropertyDescriptor();
    var toIndexedObject2 = /* @__PURE__ */ requireToIndexedObject();
    var toPropertyKey2 = /* @__PURE__ */ requireToPropertyKey();
    var hasOwn2 = /* @__PURE__ */ requireHasOwnProperty();
    var IE8_DOM_DEFINE = /* @__PURE__ */ requireIe8DomDefine();
    var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    objectGetOwnPropertyDescriptor.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
      O = toIndexedObject2(O);
      P = toPropertyKey2(P);
      if (IE8_DOM_DEFINE) try {
        return $getOwnPropertyDescriptor(O, P);
      } catch (error) {
      }
      if (hasOwn2(O, P)) return createPropertyDescriptor2(!call(propertyIsEnumerableModule.f, O, P), O[P]);
    };
    return objectGetOwnPropertyDescriptor;
  }
  var functionBindContext;
  var hasRequiredFunctionBindContext;
  function requireFunctionBindContext() {
    if (hasRequiredFunctionBindContext) return functionBindContext;
    hasRequiredFunctionBindContext = 1;
    var uncurryThis = /* @__PURE__ */ requireFunctionUncurryThisClause();
    var aCallable2 = /* @__PURE__ */ requireACallable();
    var NATIVE_BIND = /* @__PURE__ */ requireFunctionBindNative();
    var bind2 = uncurryThis(uncurryThis.bind);
    functionBindContext = function(fn, that) {
      aCallable2(fn);
      return that === void 0 ? fn : NATIVE_BIND ? bind2(fn, that) : function() {
        return fn.apply(that, arguments);
      };
    };
    return functionBindContext;
  }
  var objectDefineProperty = {};
  var v8PrototypeDefineBug;
  var hasRequiredV8PrototypeDefineBug;
  function requireV8PrototypeDefineBug() {
    if (hasRequiredV8PrototypeDefineBug) return v8PrototypeDefineBug;
    hasRequiredV8PrototypeDefineBug = 1;
    var DESCRIPTORS = /* @__PURE__ */ requireDescriptors();
    var fails2 = /* @__PURE__ */ requireFails();
    v8PrototypeDefineBug = DESCRIPTORS && fails2(function() {
      return Object.defineProperty(function() {
      }, "prototype", {
        value: 42,
        writable: false
      }).prototype !== 42;
    });
    return v8PrototypeDefineBug;
  }
  var anObject;
  var hasRequiredAnObject;
  function requireAnObject() {
    if (hasRequiredAnObject) return anObject;
    hasRequiredAnObject = 1;
    var isObject2 = /* @__PURE__ */ requireIsObject$1();
    var $String = String;
    var $TypeError = TypeError;
    anObject = function(argument) {
      if (isObject2(argument)) return argument;
      throw new $TypeError($String(argument) + " is not an object");
    };
    return anObject;
  }
  var hasRequiredObjectDefineProperty;
  function requireObjectDefineProperty() {
    if (hasRequiredObjectDefineProperty) return objectDefineProperty;
    hasRequiredObjectDefineProperty = 1;
    var DESCRIPTORS = /* @__PURE__ */ requireDescriptors();
    var IE8_DOM_DEFINE = /* @__PURE__ */ requireIe8DomDefine();
    var V8_PROTOTYPE_DEFINE_BUG = /* @__PURE__ */ requireV8PrototypeDefineBug();
    var anObject2 = /* @__PURE__ */ requireAnObject();
    var toPropertyKey2 = /* @__PURE__ */ requireToPropertyKey();
    var $TypeError = TypeError;
    var $defineProperty = Object.defineProperty;
    var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var ENUMERABLE = "enumerable";
    var CONFIGURABLE = "configurable";
    var WRITABLE = "writable";
    objectDefineProperty.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {
      anObject2(O);
      P = toPropertyKey2(P);
      anObject2(Attributes);
      if (typeof O === "function" && P === "prototype" && "value" in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
        var current = $getOwnPropertyDescriptor(O, P);
        if (current && current[WRITABLE]) {
          O[P] = Attributes.value;
          Attributes = {
            configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],
            enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
            writable: false
          };
        }
      }
      return $defineProperty(O, P, Attributes);
    } : $defineProperty : function defineProperty(O, P, Attributes) {
      anObject2(O);
      P = toPropertyKey2(P);
      anObject2(Attributes);
      if (IE8_DOM_DEFINE) try {
        return $defineProperty(O, P, Attributes);
      } catch (error) {
      }
      if ("get" in Attributes || "set" in Attributes) throw new $TypeError("Accessors not supported");
      if ("value" in Attributes) O[P] = Attributes.value;
      return O;
    };
    return objectDefineProperty;
  }
  var createNonEnumerableProperty;
  var hasRequiredCreateNonEnumerableProperty;
  function requireCreateNonEnumerableProperty() {
    if (hasRequiredCreateNonEnumerableProperty) return createNonEnumerableProperty;
    hasRequiredCreateNonEnumerableProperty = 1;
    var DESCRIPTORS = /* @__PURE__ */ requireDescriptors();
    var definePropertyModule = /* @__PURE__ */ requireObjectDefineProperty();
    var createPropertyDescriptor2 = /* @__PURE__ */ requireCreatePropertyDescriptor();
    createNonEnumerableProperty = DESCRIPTORS ? function(object, key, value) {
      return definePropertyModule.f(object, key, createPropertyDescriptor2(1, value));
    } : function(object, key, value) {
      object[key] = value;
      return object;
    };
    return createNonEnumerableProperty;
  }
  var _export;
  var hasRequired_export;
  function require_export() {
    if (hasRequired_export) return _export;
    hasRequired_export = 1;
    var globalThis2 = /* @__PURE__ */ requireGlobalThis();
    var apply = /* @__PURE__ */ requireFunctionApply();
    var uncurryThis = /* @__PURE__ */ requireFunctionUncurryThisClause();
    var isCallable2 = /* @__PURE__ */ requireIsCallable();
    var getOwnPropertyDescriptor = requireObjectGetOwnPropertyDescriptor().f;
    var isForced2 = /* @__PURE__ */ requireIsForced();
    var path2 = /* @__PURE__ */ requirePath();
    var bind2 = /* @__PURE__ */ requireFunctionBindContext();
    var createNonEnumerableProperty2 = /* @__PURE__ */ requireCreateNonEnumerableProperty();
    var hasOwn2 = /* @__PURE__ */ requireHasOwnProperty();
    var wrapConstructor = function(NativeConstructor) {
      var Wrapper = function(a2, b, c2) {
        if (this instanceof Wrapper) {
          switch (arguments.length) {
            case 0:
              return new NativeConstructor();
            case 1:
              return new NativeConstructor(a2);
            case 2:
              return new NativeConstructor(a2, b);
          }
          return new NativeConstructor(a2, b, c2);
        }
        return apply(NativeConstructor, this, arguments);
      };
      Wrapper.prototype = NativeConstructor.prototype;
      return Wrapper;
    };
    _export = function(options, source) {
      var TARGET = options.target;
      var GLOBAL = options.global;
      var STATIC = options.stat;
      var PROTO = options.proto;
      var nativeSource = GLOBAL ? globalThis2 : STATIC ? globalThis2[TARGET] : globalThis2[TARGET] && globalThis2[TARGET].prototype;
      var target = GLOBAL ? path2 : path2[TARGET] || createNonEnumerableProperty2(path2, TARGET, {})[TARGET];
      var targetPrototype = target.prototype;
      var FORCED, USE_NATIVE, VIRTUAL_PROTOTYPE;
      var key, sourceProperty, targetProperty, nativeProperty, resultProperty, descriptor;
      for (key in source) {
        FORCED = isForced2(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options.forced);
        USE_NATIVE = !FORCED && nativeSource && hasOwn2(nativeSource, key);
        targetProperty = target[key];
        if (USE_NATIVE) if (options.dontCallGetSet) {
          descriptor = getOwnPropertyDescriptor(nativeSource, key);
          nativeProperty = descriptor && descriptor.value;
        } else nativeProperty = nativeSource[key];
        sourceProperty = USE_NATIVE && nativeProperty ? nativeProperty : source[key];
        if (!FORCED && !PROTO && typeof targetProperty == typeof sourceProperty) continue;
        if (options.bind && USE_NATIVE) resultProperty = bind2(sourceProperty, globalThis2);
        else if (options.wrap && USE_NATIVE) resultProperty = wrapConstructor(sourceProperty);
        else if (PROTO && isCallable2(sourceProperty)) resultProperty = uncurryThis(sourceProperty);
        else resultProperty = sourceProperty;
        if (options.sham || sourceProperty && sourceProperty.sham || targetProperty && targetProperty.sham) {
          createNonEnumerableProperty2(resultProperty, "sham", true);
        }
        createNonEnumerableProperty2(target, key, resultProperty);
        if (PROTO) {
          VIRTUAL_PROTOTYPE = TARGET + "Prototype";
          if (!hasOwn2(path2, VIRTUAL_PROTOTYPE)) {
            createNonEnumerableProperty2(path2, VIRTUAL_PROTOTYPE, {});
          }
          createNonEnumerableProperty2(path2[VIRTUAL_PROTOTYPE], key, sourceProperty);
          if (options.real && targetPrototype && (FORCED || !targetPrototype[key])) {
            createNonEnumerableProperty2(targetPrototype, key, sourceProperty);
          }
        }
      }
    };
    return _export;
  }
  var functionUncurryThisAccessor;
  var hasRequiredFunctionUncurryThisAccessor;
  function requireFunctionUncurryThisAccessor() {
    if (hasRequiredFunctionUncurryThisAccessor) return functionUncurryThisAccessor;
    hasRequiredFunctionUncurryThisAccessor = 1;
    var uncurryThis = /* @__PURE__ */ requireFunctionUncurryThis();
    var aCallable2 = /* @__PURE__ */ requireACallable();
    functionUncurryThisAccessor = function(object, key, method) {
      try {
        return uncurryThis(aCallable2(Object.getOwnPropertyDescriptor(object, key)[method]));
      } catch (error) {
      }
    };
    return functionUncurryThisAccessor;
  }
  var isPossiblePrototype;
  var hasRequiredIsPossiblePrototype;
  function requireIsPossiblePrototype() {
    if (hasRequiredIsPossiblePrototype) return isPossiblePrototype;
    hasRequiredIsPossiblePrototype = 1;
    var isObject2 = /* @__PURE__ */ requireIsObject$1();
    isPossiblePrototype = function(argument) {
      return isObject2(argument) || argument === null;
    };
    return isPossiblePrototype;
  }
  var aPossiblePrototype;
  var hasRequiredAPossiblePrototype;
  function requireAPossiblePrototype() {
    if (hasRequiredAPossiblePrototype) return aPossiblePrototype;
    hasRequiredAPossiblePrototype = 1;
    var isPossiblePrototype2 = /* @__PURE__ */ requireIsPossiblePrototype();
    var $String = String;
    var $TypeError = TypeError;
    aPossiblePrototype = function(argument) {
      if (isPossiblePrototype2(argument)) return argument;
      throw new $TypeError("Can't set " + $String(argument) + " as a prototype");
    };
    return aPossiblePrototype;
  }
  var objectSetPrototypeOf;
  var hasRequiredObjectSetPrototypeOf;
  function requireObjectSetPrototypeOf() {
    if (hasRequiredObjectSetPrototypeOf) return objectSetPrototypeOf;
    hasRequiredObjectSetPrototypeOf = 1;
    var uncurryThisAccessor = /* @__PURE__ */ requireFunctionUncurryThisAccessor();
    var isObject2 = /* @__PURE__ */ requireIsObject$1();
    var requireObjectCoercible2 = /* @__PURE__ */ requireRequireObjectCoercible();
    var aPossiblePrototype2 = /* @__PURE__ */ requireAPossiblePrototype();
    objectSetPrototypeOf = Object.setPrototypeOf || ("__proto__" in {} ? function() {
      var CORRECT_SETTER = false;
      var test = {};
      var setter;
      try {
        setter = uncurryThisAccessor(Object.prototype, "__proto__", "set");
        setter(test, []);
        CORRECT_SETTER = test instanceof Array;
      } catch (error) {
      }
      return function setPrototypeOf(O, proto) {
        requireObjectCoercible2(O);
        aPossiblePrototype2(proto);
        if (!isObject2(O)) return O;
        if (CORRECT_SETTER) setter(O, proto);
        else O.__proto__ = proto;
        return O;
      };
    }() : void 0);
    return objectSetPrototypeOf;
  }
  var objectGetOwnPropertyNames = {};
  var mathTrunc;
  var hasRequiredMathTrunc;
  function requireMathTrunc() {
    if (hasRequiredMathTrunc) return mathTrunc;
    hasRequiredMathTrunc = 1;
    var ceil = Math.ceil;
    var floor = Math.floor;
    mathTrunc = Math.trunc || function trunc(x) {
      var n2 = +x;
      return (n2 > 0 ? floor : ceil)(n2);
    };
    return mathTrunc;
  }
  var toIntegerOrInfinity;
  var hasRequiredToIntegerOrInfinity;
  function requireToIntegerOrInfinity() {
    if (hasRequiredToIntegerOrInfinity) return toIntegerOrInfinity;
    hasRequiredToIntegerOrInfinity = 1;
    var trunc = /* @__PURE__ */ requireMathTrunc();
    toIntegerOrInfinity = function(argument) {
      var number = +argument;
      return number !== number || number === 0 ? 0 : trunc(number);
    };
    return toIntegerOrInfinity;
  }
  var toAbsoluteIndex;
  var hasRequiredToAbsoluteIndex;
  function requireToAbsoluteIndex() {
    if (hasRequiredToAbsoluteIndex) return toAbsoluteIndex;
    hasRequiredToAbsoluteIndex = 1;
    var toIntegerOrInfinity2 = /* @__PURE__ */ requireToIntegerOrInfinity();
    var max = Math.max;
    var min = Math.min;
    toAbsoluteIndex = function(index, length2) {
      var integer = toIntegerOrInfinity2(index);
      return integer < 0 ? max(integer + length2, 0) : min(integer, length2);
    };
    return toAbsoluteIndex;
  }
  var toLength;
  var hasRequiredToLength;
  function requireToLength() {
    if (hasRequiredToLength) return toLength;
    hasRequiredToLength = 1;
    var toIntegerOrInfinity2 = /* @__PURE__ */ requireToIntegerOrInfinity();
    var min = Math.min;
    toLength = function(argument) {
      var len = toIntegerOrInfinity2(argument);
      return len > 0 ? min(len, 9007199254740991) : 0;
    };
    return toLength;
  }
  var lengthOfArrayLike;
  var hasRequiredLengthOfArrayLike;
  function requireLengthOfArrayLike() {
    if (hasRequiredLengthOfArrayLike) return lengthOfArrayLike;
    hasRequiredLengthOfArrayLike = 1;
    var toLength2 = /* @__PURE__ */ requireToLength();
    lengthOfArrayLike = function(obj) {
      return toLength2(obj.length);
    };
    return lengthOfArrayLike;
  }
  var arrayIncludes;
  var hasRequiredArrayIncludes;
  function requireArrayIncludes() {
    if (hasRequiredArrayIncludes) return arrayIncludes;
    hasRequiredArrayIncludes = 1;
    var toIndexedObject2 = /* @__PURE__ */ requireToIndexedObject();
    var toAbsoluteIndex2 = /* @__PURE__ */ requireToAbsoluteIndex();
    var lengthOfArrayLike2 = /* @__PURE__ */ requireLengthOfArrayLike();
    var createMethod = function(IS_INCLUDES) {
      return function($this, el, fromIndex) {
        var O = toIndexedObject2($this);
        var length2 = lengthOfArrayLike2(O);
        if (length2 === 0) return !IS_INCLUDES && -1;
        var index = toAbsoluteIndex2(fromIndex, length2);
        var value;
        if (IS_INCLUDES && el !== el) while (length2 > index) {
          value = O[index++];
          if (value !== value) return true;
        }
        else for (; length2 > index; index++) {
          if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
        }
        return !IS_INCLUDES && -1;
      };
    };
    arrayIncludes = {
      // `Array.prototype.includes` method
      // https://tc39.es/ecma262/#sec-array.prototype.includes
      includes: createMethod(true),
      // `Array.prototype.indexOf` method
      // https://tc39.es/ecma262/#sec-array.prototype.indexof
      indexOf: createMethod(false)
    };
    return arrayIncludes;
  }
  var hiddenKeys;
  var hasRequiredHiddenKeys;
  function requireHiddenKeys() {
    if (hasRequiredHiddenKeys) return hiddenKeys;
    hasRequiredHiddenKeys = 1;
    hiddenKeys = {};
    return hiddenKeys;
  }
  var objectKeysInternal;
  var hasRequiredObjectKeysInternal;
  function requireObjectKeysInternal() {
    if (hasRequiredObjectKeysInternal) return objectKeysInternal;
    hasRequiredObjectKeysInternal = 1;
    var uncurryThis = /* @__PURE__ */ requireFunctionUncurryThis();
    var hasOwn2 = /* @__PURE__ */ requireHasOwnProperty();
    var toIndexedObject2 = /* @__PURE__ */ requireToIndexedObject();
    var indexOf = requireArrayIncludes().indexOf;
    var hiddenKeys2 = /* @__PURE__ */ requireHiddenKeys();
    var push = uncurryThis([].push);
    objectKeysInternal = function(object, names) {
      var O = toIndexedObject2(object);
      var i2 = 0;
      var result = [];
      var key;
      for (key in O) !hasOwn2(hiddenKeys2, key) && hasOwn2(O, key) && push(result, key);
      while (names.length > i2) if (hasOwn2(O, key = names[i2++])) {
        ~indexOf(result, key) || push(result, key);
      }
      return result;
    };
    return objectKeysInternal;
  }
  var enumBugKeys;
  var hasRequiredEnumBugKeys;
  function requireEnumBugKeys() {
    if (hasRequiredEnumBugKeys) return enumBugKeys;
    hasRequiredEnumBugKeys = 1;
    enumBugKeys = [
      "constructor",
      "hasOwnProperty",
      "isPrototypeOf",
      "propertyIsEnumerable",
      "toLocaleString",
      "toString",
      "valueOf"
    ];
    return enumBugKeys;
  }
  var hasRequiredObjectGetOwnPropertyNames;
  function requireObjectGetOwnPropertyNames() {
    if (hasRequiredObjectGetOwnPropertyNames) return objectGetOwnPropertyNames;
    hasRequiredObjectGetOwnPropertyNames = 1;
    var internalObjectKeys = /* @__PURE__ */ requireObjectKeysInternal();
    var enumBugKeys2 = /* @__PURE__ */ requireEnumBugKeys();
    var hiddenKeys2 = enumBugKeys2.concat("length", "prototype");
    objectGetOwnPropertyNames.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
      return internalObjectKeys(O, hiddenKeys2);
    };
    return objectGetOwnPropertyNames;
  }
  var objectGetOwnPropertySymbols = {};
  var hasRequiredObjectGetOwnPropertySymbols;
  function requireObjectGetOwnPropertySymbols() {
    if (hasRequiredObjectGetOwnPropertySymbols) return objectGetOwnPropertySymbols;
    hasRequiredObjectGetOwnPropertySymbols = 1;
    objectGetOwnPropertySymbols.f = Object.getOwnPropertySymbols;
    return objectGetOwnPropertySymbols;
  }
  var ownKeys;
  var hasRequiredOwnKeys;
  function requireOwnKeys() {
    if (hasRequiredOwnKeys) return ownKeys;
    hasRequiredOwnKeys = 1;
    var getBuiltIn2 = /* @__PURE__ */ requireGetBuiltIn();
    var uncurryThis = /* @__PURE__ */ requireFunctionUncurryThis();
    var getOwnPropertyNamesModule = /* @__PURE__ */ requireObjectGetOwnPropertyNames();
    var getOwnPropertySymbolsModule = /* @__PURE__ */ requireObjectGetOwnPropertySymbols();
    var anObject2 = /* @__PURE__ */ requireAnObject();
    var concat = uncurryThis([].concat);
    ownKeys = getBuiltIn2("Reflect", "ownKeys") || function ownKeys2(it) {
      var keys = getOwnPropertyNamesModule.f(anObject2(it));
      var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
      return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;
    };
    return ownKeys;
  }
  var copyConstructorProperties;
  var hasRequiredCopyConstructorProperties;
  function requireCopyConstructorProperties() {
    if (hasRequiredCopyConstructorProperties) return copyConstructorProperties;
    hasRequiredCopyConstructorProperties = 1;
    var hasOwn2 = /* @__PURE__ */ requireHasOwnProperty();
    var ownKeys2 = /* @__PURE__ */ requireOwnKeys();
    var getOwnPropertyDescriptorModule = /* @__PURE__ */ requireObjectGetOwnPropertyDescriptor();
    var definePropertyModule = /* @__PURE__ */ requireObjectDefineProperty();
    copyConstructorProperties = function(target, source, exceptions) {
      var keys = ownKeys2(source);
      var defineProperty = definePropertyModule.f;
      var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
      for (var i2 = 0; i2 < keys.length; i2++) {
        var key = keys[i2];
        if (!hasOwn2(target, key) && !(exceptions && hasOwn2(exceptions, key))) {
          defineProperty(target, key, getOwnPropertyDescriptor(source, key));
        }
      }
    };
    return copyConstructorProperties;
  }
  var proxyAccessor;
  var hasRequiredProxyAccessor;
  function requireProxyAccessor() {
    if (hasRequiredProxyAccessor) return proxyAccessor;
    hasRequiredProxyAccessor = 1;
    var defineProperty = requireObjectDefineProperty().f;
    proxyAccessor = function(Target, Source, key) {
      key in Target || defineProperty(Target, key, {
        configurable: true,
        get: function() {
          return Source[key];
        },
        set: function(it) {
          Source[key] = it;
        }
      });
    };
    return proxyAccessor;
  }
  var inheritIfRequired;
  var hasRequiredInheritIfRequired;
  function requireInheritIfRequired() {
    if (hasRequiredInheritIfRequired) return inheritIfRequired;
    hasRequiredInheritIfRequired = 1;
    var isCallable2 = /* @__PURE__ */ requireIsCallable();
    var isObject2 = /* @__PURE__ */ requireIsObject$1();
    var setPrototypeOf = /* @__PURE__ */ requireObjectSetPrototypeOf();
    inheritIfRequired = function($this, dummy, Wrapper) {
      var NewTarget, NewTargetPrototype;
      if (
        // it can work only with native `setPrototypeOf`
        setPrototypeOf && // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
        isCallable2(NewTarget = dummy.constructor) && NewTarget !== Wrapper && isObject2(NewTargetPrototype = NewTarget.prototype) && NewTargetPrototype !== Wrapper.prototype
      ) setPrototypeOf($this, NewTargetPrototype);
      return $this;
    };
    return inheritIfRequired;
  }
  var toStringTagSupport;
  var hasRequiredToStringTagSupport;
  function requireToStringTagSupport() {
    if (hasRequiredToStringTagSupport) return toStringTagSupport;
    hasRequiredToStringTagSupport = 1;
    var wellKnownSymbol2 = /* @__PURE__ */ requireWellKnownSymbol();
    var TO_STRING_TAG = wellKnownSymbol2("toStringTag");
    var test = {};
    test[TO_STRING_TAG] = "z";
    toStringTagSupport = String(test) === "[object z]";
    return toStringTagSupport;
  }
  var classof;
  var hasRequiredClassof;
  function requireClassof() {
    if (hasRequiredClassof) return classof;
    hasRequiredClassof = 1;
    var TO_STRING_TAG_SUPPORT = /* @__PURE__ */ requireToStringTagSupport();
    var isCallable2 = /* @__PURE__ */ requireIsCallable();
    var classofRaw2 = /* @__PURE__ */ requireClassofRaw();
    var wellKnownSymbol2 = /* @__PURE__ */ requireWellKnownSymbol();
    var TO_STRING_TAG = wellKnownSymbol2("toStringTag");
    var $Object = Object;
    var CORRECT_ARGUMENTS = classofRaw2(/* @__PURE__ */ function() {
      return arguments;
    }()) === "Arguments";
    var tryGet = function(it, key) {
      try {
        return it[key];
      } catch (error) {
      }
    };
    classof = TO_STRING_TAG_SUPPORT ? classofRaw2 : function(it) {
      var O, tag, result;
      return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw2(O) : (result = classofRaw2(O)) === "Object" && isCallable2(O.callee) ? "Arguments" : result;
    };
    return classof;
  }
  var toString;
  var hasRequiredToString;
  function requireToString() {
    if (hasRequiredToString) return toString;
    hasRequiredToString = 1;
    var classof2 = /* @__PURE__ */ requireClassof();
    var $String = String;
    toString = function(argument) {
      if (classof2(argument) === "Symbol") throw new TypeError("Cannot convert a Symbol value to a string");
      return $String(argument);
    };
    return toString;
  }
  var normalizeStringArgument;
  var hasRequiredNormalizeStringArgument;
  function requireNormalizeStringArgument() {
    if (hasRequiredNormalizeStringArgument) return normalizeStringArgument;
    hasRequiredNormalizeStringArgument = 1;
    var toString2 = /* @__PURE__ */ requireToString();
    normalizeStringArgument = function(argument, $default) {
      return argument === void 0 ? arguments.length < 2 ? "" : $default : toString2(argument);
    };
    return normalizeStringArgument;
  }
  var installErrorCause;
  var hasRequiredInstallErrorCause;
  function requireInstallErrorCause() {
    if (hasRequiredInstallErrorCause) return installErrorCause;
    hasRequiredInstallErrorCause = 1;
    var isObject2 = /* @__PURE__ */ requireIsObject$1();
    var createNonEnumerableProperty2 = /* @__PURE__ */ requireCreateNonEnumerableProperty();
    installErrorCause = function(O, options) {
      if (isObject2(options) && "cause" in options) {
        createNonEnumerableProperty2(O, "cause", options.cause);
      }
    };
    return installErrorCause;
  }
  var errorStackClear;
  var hasRequiredErrorStackClear;
  function requireErrorStackClear() {
    if (hasRequiredErrorStackClear) return errorStackClear;
    hasRequiredErrorStackClear = 1;
    var uncurryThis = /* @__PURE__ */ requireFunctionUncurryThis();
    var $Error = Error;
    var replace2 = uncurryThis("".replace);
    var TEST = function(arg) {
      return String(new $Error(arg).stack);
    }("zxcasd");
    var V8_OR_CHAKRA_STACK_ENTRY = /\n\s*at [^:]*:[^\n]*/;
    var IS_V8_OR_CHAKRA_STACK = V8_OR_CHAKRA_STACK_ENTRY.test(TEST);
    errorStackClear = function(stack, dropEntries) {
      if (IS_V8_OR_CHAKRA_STACK && typeof stack == "string" && !$Error.prepareStackTrace) {
        while (dropEntries--) stack = replace2(stack, V8_OR_CHAKRA_STACK_ENTRY, "");
      }
      return stack;
    };
    return errorStackClear;
  }
  var errorStackInstallable;
  var hasRequiredErrorStackInstallable;
  function requireErrorStackInstallable() {
    if (hasRequiredErrorStackInstallable) return errorStackInstallable;
    hasRequiredErrorStackInstallable = 1;
    var fails2 = /* @__PURE__ */ requireFails();
    var createPropertyDescriptor2 = /* @__PURE__ */ requireCreatePropertyDescriptor();
    errorStackInstallable = !fails2(function() {
      var error = new Error("a");
      if (!("stack" in error)) return true;
      Object.defineProperty(error, "stack", createPropertyDescriptor2(1, 7));
      return error.stack !== 7;
    });
    return errorStackInstallable;
  }
  var errorStackInstall;
  var hasRequiredErrorStackInstall;
  function requireErrorStackInstall() {
    if (hasRequiredErrorStackInstall) return errorStackInstall;
    hasRequiredErrorStackInstall = 1;
    var createNonEnumerableProperty2 = /* @__PURE__ */ requireCreateNonEnumerableProperty();
    var clearErrorStack = /* @__PURE__ */ requireErrorStackClear();
    var ERROR_STACK_INSTALLABLE = /* @__PURE__ */ requireErrorStackInstallable();
    var captureStackTrace = Error.captureStackTrace;
    errorStackInstall = function(error, C, stack, dropEntries) {
      if (ERROR_STACK_INSTALLABLE) {
        if (captureStackTrace) captureStackTrace(error, C);
        else createNonEnumerableProperty2(error, "stack", clearErrorStack(stack, dropEntries));
      }
    };
    return errorStackInstall;
  }
  var wrapErrorConstructorWithCause;
  var hasRequiredWrapErrorConstructorWithCause;
  function requireWrapErrorConstructorWithCause() {
    if (hasRequiredWrapErrorConstructorWithCause) return wrapErrorConstructorWithCause;
    hasRequiredWrapErrorConstructorWithCause = 1;
    var getBuiltIn2 = /* @__PURE__ */ requireGetBuiltIn();
    var hasOwn2 = /* @__PURE__ */ requireHasOwnProperty();
    var createNonEnumerableProperty2 = /* @__PURE__ */ requireCreateNonEnumerableProperty();
    var isPrototypeOf = /* @__PURE__ */ requireObjectIsPrototypeOf();
    var setPrototypeOf = /* @__PURE__ */ requireObjectSetPrototypeOf();
    var copyConstructorProperties2 = /* @__PURE__ */ requireCopyConstructorProperties();
    var proxyAccessor2 = /* @__PURE__ */ requireProxyAccessor();
    var inheritIfRequired2 = /* @__PURE__ */ requireInheritIfRequired();
    var normalizeStringArgument2 = /* @__PURE__ */ requireNormalizeStringArgument();
    var installErrorCause2 = /* @__PURE__ */ requireInstallErrorCause();
    var installErrorStack = /* @__PURE__ */ requireErrorStackInstall();
    var DESCRIPTORS = /* @__PURE__ */ requireDescriptors();
    var IS_PURE = /* @__PURE__ */ requireIsPure();
    wrapErrorConstructorWithCause = function(FULL_NAME, wrapper, FORCED, IS_AGGREGATE_ERROR) {
      var STACK_TRACE_LIMIT = "stackTraceLimit";
      var OPTIONS_POSITION = IS_AGGREGATE_ERROR ? 2 : 1;
      var path2 = FULL_NAME.split(".");
      var ERROR_NAME = path2[path2.length - 1];
      var OriginalError = getBuiltIn2.apply(null, path2);
      if (!OriginalError) return;
      var OriginalErrorPrototype = OriginalError.prototype;
      if (!IS_PURE && hasOwn2(OriginalErrorPrototype, "cause")) delete OriginalErrorPrototype.cause;
      if (!FORCED) return OriginalError;
      var BaseError = getBuiltIn2("Error");
      var WrappedError = wrapper(function(a2, b) {
        var message2 = normalizeStringArgument2(IS_AGGREGATE_ERROR ? b : a2, void 0);
        var result = IS_AGGREGATE_ERROR ? new OriginalError(a2) : new OriginalError();
        if (message2 !== void 0) createNonEnumerableProperty2(result, "message", message2);
        installErrorStack(result, WrappedError, result.stack, 2);
        if (this && isPrototypeOf(OriginalErrorPrototype, this)) inheritIfRequired2(result, this, WrappedError);
        if (arguments.length > OPTIONS_POSITION) installErrorCause2(result, arguments[OPTIONS_POSITION]);
        return result;
      });
      WrappedError.prototype = OriginalErrorPrototype;
      if (ERROR_NAME !== "Error") {
        if (setPrototypeOf) setPrototypeOf(WrappedError, BaseError);
        else copyConstructorProperties2(WrappedError, BaseError, { name: true });
      } else if (DESCRIPTORS && STACK_TRACE_LIMIT in OriginalError) {
        proxyAccessor2(WrappedError, OriginalError, STACK_TRACE_LIMIT);
        proxyAccessor2(WrappedError, OriginalError, "prepareStackTrace");
      }
      copyConstructorProperties2(WrappedError, OriginalError);
      if (!IS_PURE) try {
        if (OriginalErrorPrototype.name !== ERROR_NAME) {
          createNonEnumerableProperty2(OriginalErrorPrototype, "name", ERROR_NAME);
        }
        OriginalErrorPrototype.constructor = WrappedError;
      } catch (error) {
      }
      return WrappedError;
    };
    return wrapErrorConstructorWithCause;
  }
  var hasRequiredEs_error_cause;
  function requireEs_error_cause() {
    if (hasRequiredEs_error_cause) return es_error_cause;
    hasRequiredEs_error_cause = 1;
    var $ = /* @__PURE__ */ require_export();
    var globalThis2 = /* @__PURE__ */ requireGlobalThis();
    var apply = /* @__PURE__ */ requireFunctionApply();
    var wrapErrorConstructorWithCause2 = /* @__PURE__ */ requireWrapErrorConstructorWithCause();
    var WEB_ASSEMBLY = "WebAssembly";
    var WebAssembly = globalThis2[WEB_ASSEMBLY];
    var FORCED = new Error("e", { cause: 7 }).cause !== 7;
    var exportGlobalErrorCauseWrapper = function(ERROR_NAME, wrapper) {
      var O = {};
      O[ERROR_NAME] = wrapErrorConstructorWithCause2(ERROR_NAME, wrapper, FORCED);
      $({ global: true, constructor: true, arity: 1, forced: FORCED }, O);
    };
    var exportWebAssemblyErrorCauseWrapper = function(ERROR_NAME, wrapper) {
      if (WebAssembly && WebAssembly[ERROR_NAME]) {
        var O = {};
        O[ERROR_NAME] = wrapErrorConstructorWithCause2(WEB_ASSEMBLY + "." + ERROR_NAME, wrapper, FORCED);
        $({ target: WEB_ASSEMBLY, stat: true, constructor: true, arity: 1, forced: FORCED }, O);
      }
    };
    exportGlobalErrorCauseWrapper("Error", function(init) {
      return function Error2(message2) {
        return apply(init, this, arguments);
      };
    });
    exportGlobalErrorCauseWrapper("EvalError", function(init) {
      return function EvalError(message2) {
        return apply(init, this, arguments);
      };
    });
    exportGlobalErrorCauseWrapper("RangeError", function(init) {
      return function RangeError(message2) {
        return apply(init, this, arguments);
      };
    });
    exportGlobalErrorCauseWrapper("ReferenceError", function(init) {
      return function ReferenceError2(message2) {
        return apply(init, this, arguments);
      };
    });
    exportGlobalErrorCauseWrapper("SyntaxError", function(init) {
      return function SyntaxError(message2) {
        return apply(init, this, arguments);
      };
    });
    exportGlobalErrorCauseWrapper("TypeError", function(init) {
      return function TypeError2(message2) {
        return apply(init, this, arguments);
      };
    });
    exportGlobalErrorCauseWrapper("URIError", function(init) {
      return function URIError(message2) {
        return apply(init, this, arguments);
      };
    });
    exportWebAssemblyErrorCauseWrapper("CompileError", function(init) {
      return function CompileError(message2) {
        return apply(init, this, arguments);
      };
    });
    exportWebAssemblyErrorCauseWrapper("LinkError", function(init) {
      return function LinkError(message2) {
        return apply(init, this, arguments);
      };
    });
    exportWebAssemblyErrorCauseWrapper("RuntimeError", function(init) {
      return function RuntimeError(message2) {
        return apply(init, this, arguments);
      };
    });
    return es_error_cause;
  }
  var defineBuiltIn;
  var hasRequiredDefineBuiltIn;
  function requireDefineBuiltIn() {
    if (hasRequiredDefineBuiltIn) return defineBuiltIn;
    hasRequiredDefineBuiltIn = 1;
    var createNonEnumerableProperty2 = /* @__PURE__ */ requireCreateNonEnumerableProperty();
    defineBuiltIn = function(target, key, value, options) {
      if (options && options.enumerable) target[key] = value;
      else createNonEnumerableProperty2(target, key, value);
      return target;
    };
    return defineBuiltIn;
  }
  var defineBuiltInAccessor;
  var hasRequiredDefineBuiltInAccessor;
  function requireDefineBuiltInAccessor() {
    if (hasRequiredDefineBuiltInAccessor) return defineBuiltInAccessor;
    hasRequiredDefineBuiltInAccessor = 1;
    var defineProperty = /* @__PURE__ */ requireObjectDefineProperty();
    defineBuiltInAccessor = function(target, name, descriptor) {
      return defineProperty.f(target, name, descriptor);
    };
    return defineBuiltInAccessor;
  }
  var anInstance;
  var hasRequiredAnInstance;
  function requireAnInstance() {
    if (hasRequiredAnInstance) return anInstance;
    hasRequiredAnInstance = 1;
    var isPrototypeOf = /* @__PURE__ */ requireObjectIsPrototypeOf();
    var $TypeError = TypeError;
    anInstance = function(it, Prototype) {
      if (isPrototypeOf(Prototype, it)) return it;
      throw new $TypeError("Incorrect invocation");
    };
    return anInstance;
  }
  var html;
  var hasRequiredHtml;
  function requireHtml() {
    if (hasRequiredHtml) return html;
    hasRequiredHtml = 1;
    var getBuiltIn2 = /* @__PURE__ */ requireGetBuiltIn();
    html = getBuiltIn2("document", "documentElement");
    return html;
  }
  var weakMapBasicDetection;
  var hasRequiredWeakMapBasicDetection;
  function requireWeakMapBasicDetection() {
    if (hasRequiredWeakMapBasicDetection) return weakMapBasicDetection;
    hasRequiredWeakMapBasicDetection = 1;
    var globalThis2 = /* @__PURE__ */ requireGlobalThis();
    var isCallable2 = /* @__PURE__ */ requireIsCallable();
    var WeakMap2 = globalThis2.WeakMap;
    weakMapBasicDetection = isCallable2(WeakMap2) && /native code/.test(String(WeakMap2));
    return weakMapBasicDetection;
  }
  var sharedKey;
  var hasRequiredSharedKey;
  function requireSharedKey() {
    if (hasRequiredSharedKey) return sharedKey;
    hasRequiredSharedKey = 1;
    var shared2 = /* @__PURE__ */ requireShared();
    var uid2 = /* @__PURE__ */ requireUid();
    var keys = shared2("keys");
    sharedKey = function(key) {
      return keys[key] || (keys[key] = uid2(key));
    };
    return sharedKey;
  }
  var internalState;
  var hasRequiredInternalState;
  function requireInternalState() {
    if (hasRequiredInternalState) return internalState;
    hasRequiredInternalState = 1;
    var NATIVE_WEAK_MAP = /* @__PURE__ */ requireWeakMapBasicDetection();
    var globalThis2 = /* @__PURE__ */ requireGlobalThis();
    var isObject2 = /* @__PURE__ */ requireIsObject$1();
    var createNonEnumerableProperty2 = /* @__PURE__ */ requireCreateNonEnumerableProperty();
    var hasOwn2 = /* @__PURE__ */ requireHasOwnProperty();
    var shared2 = /* @__PURE__ */ requireSharedStore();
    var sharedKey2 = /* @__PURE__ */ requireSharedKey();
    var hiddenKeys2 = /* @__PURE__ */ requireHiddenKeys();
    var OBJECT_ALREADY_INITIALIZED = "Object already initialized";
    var TypeError2 = globalThis2.TypeError;
    var WeakMap2 = globalThis2.WeakMap;
    var set2, get2, has;
    var enforce = function(it) {
      return has(it) ? get2(it) : set2(it, {});
    };
    var getterFor = function(TYPE) {
      return function(it) {
        var state2;
        if (!isObject2(it) || (state2 = get2(it)).type !== TYPE) {
          throw new TypeError2("Incompatible receiver, " + TYPE + " required");
        }
        return state2;
      };
    };
    if (NATIVE_WEAK_MAP || shared2.state) {
      var store2 = shared2.state || (shared2.state = new WeakMap2());
      store2.get = store2.get;
      store2.has = store2.has;
      store2.set = store2.set;
      set2 = function(it, metadata) {
        if (store2.has(it)) throw new TypeError2(OBJECT_ALREADY_INITIALIZED);
        metadata.facade = it;
        store2.set(it, metadata);
        return metadata;
      };
      get2 = function(it) {
        return store2.get(it) || {};
      };
      has = function(it) {
        return store2.has(it);
      };
    } else {
      var STATE = sharedKey2("state");
      hiddenKeys2[STATE] = true;
      set2 = function(it, metadata) {
        if (hasOwn2(it, STATE)) throw new TypeError2(OBJECT_ALREADY_INITIALIZED);
        metadata.facade = it;
        createNonEnumerableProperty2(it, STATE, metadata);
        return metadata;
      };
      get2 = function(it) {
        return hasOwn2(it, STATE) ? it[STATE] : {};
      };
      has = function(it) {
        return hasOwn2(it, STATE);
      };
    }
    internalState = {
      set: set2,
      get: get2,
      has,
      enforce,
      getterFor
    };
    return internalState;
  }
  var esnext_suppressedError_constructor = {};
  var correctPrototypeGetter;
  var hasRequiredCorrectPrototypeGetter;
  function requireCorrectPrototypeGetter() {
    if (hasRequiredCorrectPrototypeGetter) return correctPrototypeGetter;
    hasRequiredCorrectPrototypeGetter = 1;
    var fails2 = /* @__PURE__ */ requireFails();
    correctPrototypeGetter = !fails2(function() {
      function F() {
      }
      F.prototype.constructor = null;
      return Object.getPrototypeOf(new F()) !== F.prototype;
    });
    return correctPrototypeGetter;
  }
  var objectGetPrototypeOf;
  var hasRequiredObjectGetPrototypeOf;
  function requireObjectGetPrototypeOf() {
    if (hasRequiredObjectGetPrototypeOf) return objectGetPrototypeOf;
    hasRequiredObjectGetPrototypeOf = 1;
    var hasOwn2 = /* @__PURE__ */ requireHasOwnProperty();
    var isCallable2 = /* @__PURE__ */ requireIsCallable();
    var toObject2 = /* @__PURE__ */ requireToObject();
    var sharedKey2 = /* @__PURE__ */ requireSharedKey();
    var CORRECT_PROTOTYPE_GETTER = /* @__PURE__ */ requireCorrectPrototypeGetter();
    var IE_PROTO = sharedKey2("IE_PROTO");
    var $Object = Object;
    var ObjectPrototype = $Object.prototype;
    objectGetPrototypeOf = CORRECT_PROTOTYPE_GETTER ? $Object.getPrototypeOf : function(O) {
      var object = toObject2(O);
      if (hasOwn2(object, IE_PROTO)) return object[IE_PROTO];
      var constructor = object.constructor;
      if (isCallable2(constructor) && object instanceof constructor) {
        return constructor.prototype;
      }
      return object instanceof $Object ? ObjectPrototype : null;
    };
    return objectGetPrototypeOf;
  }
  var objectDefineProperties = {};
  var objectKeys;
  var hasRequiredObjectKeys;
  function requireObjectKeys() {
    if (hasRequiredObjectKeys) return objectKeys;
    hasRequiredObjectKeys = 1;
    var internalObjectKeys = /* @__PURE__ */ requireObjectKeysInternal();
    var enumBugKeys2 = /* @__PURE__ */ requireEnumBugKeys();
    objectKeys = Object.keys || function keys(O) {
      return internalObjectKeys(O, enumBugKeys2);
    };
    return objectKeys;
  }
  var hasRequiredObjectDefineProperties;
  function requireObjectDefineProperties() {
    if (hasRequiredObjectDefineProperties) return objectDefineProperties;
    hasRequiredObjectDefineProperties = 1;
    var DESCRIPTORS = /* @__PURE__ */ requireDescriptors();
    var V8_PROTOTYPE_DEFINE_BUG = /* @__PURE__ */ requireV8PrototypeDefineBug();
    var definePropertyModule = /* @__PURE__ */ requireObjectDefineProperty();
    var anObject2 = /* @__PURE__ */ requireAnObject();
    var toIndexedObject2 = /* @__PURE__ */ requireToIndexedObject();
    var objectKeys2 = /* @__PURE__ */ requireObjectKeys();
    objectDefineProperties.f = DESCRIPTORS && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {
      anObject2(O);
      var props = toIndexedObject2(Properties);
      var keys = objectKeys2(Properties);
      var length2 = keys.length;
      var index = 0;
      var key;
      while (length2 > index) definePropertyModule.f(O, key = keys[index++], props[key]);
      return O;
    };
    return objectDefineProperties;
  }
  var objectCreate;
  var hasRequiredObjectCreate;
  function requireObjectCreate() {
    if (hasRequiredObjectCreate) return objectCreate;
    hasRequiredObjectCreate = 1;
    var anObject2 = /* @__PURE__ */ requireAnObject();
    var definePropertiesModule = /* @__PURE__ */ requireObjectDefineProperties();
    var enumBugKeys2 = /* @__PURE__ */ requireEnumBugKeys();
    var hiddenKeys2 = /* @__PURE__ */ requireHiddenKeys();
    var html2 = /* @__PURE__ */ requireHtml();
    var documentCreateElement2 = /* @__PURE__ */ requireDocumentCreateElement();
    var sharedKey2 = /* @__PURE__ */ requireSharedKey();
    var GT = ">";
    var LT = "<";
    var PROTOTYPE = "prototype";
    var SCRIPT = "script";
    var IE_PROTO = sharedKey2("IE_PROTO");
    var EmptyConstructor = function() {
    };
    var scriptTag = function(content) {
      return LT + SCRIPT + GT + content + LT + "/" + SCRIPT + GT;
    };
    var NullProtoObjectViaActiveX = function(activeXDocument2) {
      activeXDocument2.write(scriptTag(""));
      activeXDocument2.close();
      var temp = activeXDocument2.parentWindow.Object;
      activeXDocument2 = null;
      return temp;
    };
    var NullProtoObjectViaIFrame = function() {
      var iframe = documentCreateElement2("iframe");
      var JS = "java" + SCRIPT + ":";
      var iframeDocument;
      iframe.style.display = "none";
      html2.appendChild(iframe);
      iframe.src = String(JS);
      iframeDocument = iframe.contentWindow.document;
      iframeDocument.open();
      iframeDocument.write(scriptTag("document.F=Object"));
      iframeDocument.close();
      return iframeDocument.F;
    };
    var activeXDocument;
    var NullProtoObject = function() {
      try {
        activeXDocument = new ActiveXObject("htmlfile");
      } catch (error) {
      }
      NullProtoObject = typeof document != "undefined" ? document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame() : NullProtoObjectViaActiveX(activeXDocument);
      var length2 = enumBugKeys2.length;
      while (length2--) delete NullProtoObject[PROTOTYPE][enumBugKeys2[length2]];
      return NullProtoObject();
    };
    hiddenKeys2[IE_PROTO] = true;
    objectCreate = Object.create || function create(O, Properties) {
      var result;
      if (O !== null) {
        EmptyConstructor[PROTOTYPE] = anObject2(O);
        result = new EmptyConstructor();
        EmptyConstructor[PROTOTYPE] = null;
        result[IE_PROTO] = O;
      } else result = NullProtoObject();
      return Properties === void 0 ? result : definePropertiesModule.f(result, Properties);
    };
    return objectCreate;
  }
  var hasRequiredEsnext_suppressedError_constructor;
  function requireEsnext_suppressedError_constructor() {
    if (hasRequiredEsnext_suppressedError_constructor) return esnext_suppressedError_constructor;
    hasRequiredEsnext_suppressedError_constructor = 1;
    var $ = /* @__PURE__ */ require_export();
    var globalThis2 = /* @__PURE__ */ requireGlobalThis();
    var isPrototypeOf = /* @__PURE__ */ requireObjectIsPrototypeOf();
    var getPrototypeOf = /* @__PURE__ */ requireObjectGetPrototypeOf();
    var setPrototypeOf = /* @__PURE__ */ requireObjectSetPrototypeOf();
    var copyConstructorProperties2 = /* @__PURE__ */ requireCopyConstructorProperties();
    var create = /* @__PURE__ */ requireObjectCreate();
    var createNonEnumerableProperty2 = /* @__PURE__ */ requireCreateNonEnumerableProperty();
    var createPropertyDescriptor2 = /* @__PURE__ */ requireCreatePropertyDescriptor();
    var installErrorStack = /* @__PURE__ */ requireErrorStackInstall();
    var normalizeStringArgument2 = /* @__PURE__ */ requireNormalizeStringArgument();
    var wellKnownSymbol2 = /* @__PURE__ */ requireWellKnownSymbol();
    var fails2 = /* @__PURE__ */ requireFails();
    var IS_PURE = /* @__PURE__ */ requireIsPure();
    var NativeSuppressedError = globalThis2.SuppressedError;
    var TO_STRING_TAG = wellKnownSymbol2("toStringTag");
    var $Error = Error;
    var WRONG_ARITY = !!NativeSuppressedError && NativeSuppressedError.length !== 3;
    var EXTRA_ARGS_SUPPORT = !!NativeSuppressedError && fails2(function() {
      return new NativeSuppressedError(1, 2, 3, { cause: 4 }).cause === 4;
    });
    var PATCH = WRONG_ARITY || EXTRA_ARGS_SUPPORT;
    var $SuppressedError = function SuppressedError2(error, suppressed, message2) {
      var isInstance = isPrototypeOf(SuppressedErrorPrototype, this);
      var that;
      if (setPrototypeOf) {
        that = PATCH && (!isInstance || getPrototypeOf(this) === SuppressedErrorPrototype) ? new NativeSuppressedError() : setPrototypeOf(new $Error(), isInstance ? getPrototypeOf(this) : SuppressedErrorPrototype);
      } else {
        that = isInstance ? this : create(SuppressedErrorPrototype);
        createNonEnumerableProperty2(that, TO_STRING_TAG, "Error");
      }
      if (message2 !== void 0) createNonEnumerableProperty2(that, "message", normalizeStringArgument2(message2));
      installErrorStack(that, $SuppressedError, that.stack, 1);
      createNonEnumerableProperty2(that, "error", error);
      createNonEnumerableProperty2(that, "suppressed", suppressed);
      return that;
    };
    if (setPrototypeOf) setPrototypeOf($SuppressedError, $Error);
    else copyConstructorProperties2($SuppressedError, $Error, { name: true });
    var SuppressedErrorPrototype = $SuppressedError.prototype = PATCH ? NativeSuppressedError.prototype : create($Error.prototype, {
      constructor: createPropertyDescriptor2(1, $SuppressedError),
      message: createPropertyDescriptor2(1, ""),
      name: createPropertyDescriptor2(1, "SuppressedError")
    });
    if (PATCH && !IS_PURE) SuppressedErrorPrototype.constructor = $SuppressedError;
    $({ global: true, constructor: true, arity: 3, forced: PATCH }, {
      SuppressedError: $SuppressedError
    });
    return esnext_suppressedError_constructor;
  }
  var defineBuiltIns;
  var hasRequiredDefineBuiltIns;
  function requireDefineBuiltIns() {
    if (hasRequiredDefineBuiltIns) return defineBuiltIns;
    hasRequiredDefineBuiltIns = 1;
    var defineBuiltIn2 = /* @__PURE__ */ requireDefineBuiltIn();
    defineBuiltIns = function(target, src, options) {
      for (var key in src) {
        if (options && options.unsafe && target[key]) target[key] = src[key];
        else defineBuiltIn2(target, key, src[key], options);
      }
      return target;
    };
    return defineBuiltIns;
  }
  var addDisposableResource;
  var hasRequiredAddDisposableResource;
  function requireAddDisposableResource() {
    if (hasRequiredAddDisposableResource) return addDisposableResource;
    hasRequiredAddDisposableResource = 1;
    var getBuiltIn2 = /* @__PURE__ */ requireGetBuiltIn();
    var call = /* @__PURE__ */ requireFunctionCall();
    var uncurryThis = /* @__PURE__ */ requireFunctionUncurryThis();
    var bind2 = /* @__PURE__ */ requireFunctionBindContext();
    var anObject2 = /* @__PURE__ */ requireAnObject();
    var aCallable2 = /* @__PURE__ */ requireACallable();
    var isNullOrUndefined2 = /* @__PURE__ */ requireIsNullOrUndefined();
    var getMethod2 = /* @__PURE__ */ requireGetMethod();
    var wellKnownSymbol2 = /* @__PURE__ */ requireWellKnownSymbol();
    var ASYNC_DISPOSE = wellKnownSymbol2("asyncDispose");
    var DISPOSE = wellKnownSymbol2("dispose");
    var push = uncurryThis([].push);
    var getDisposeMethod = function(V, hint) {
      if (hint === "async-dispose") {
        var method = getMethod2(V, ASYNC_DISPOSE);
        if (method !== void 0) return method;
        method = getMethod2(V, DISPOSE);
        if (method === void 0) return method;
        return function() {
          var O = this;
          var Promise2 = getBuiltIn2("Promise");
          return new Promise2(function(resolve) {
            call(method, O);
            resolve(void 0);
          });
        };
      }
      return getMethod2(V, DISPOSE);
    };
    var createDisposableResource = function(V, hint, method) {
      if (arguments.length < 3 && !isNullOrUndefined2(V)) {
        method = aCallable2(getDisposeMethod(anObject2(V), hint));
      }
      return method === void 0 ? function() {
        return void 0;
      } : bind2(method, V);
    };
    addDisposableResource = function(disposable, V, hint, method) {
      var resource;
      if (arguments.length < 4) {
        if (isNullOrUndefined2(V) && hint === "sync-dispose") return;
        resource = createDisposableResource(V, hint);
      } else {
        resource = createDisposableResource(void 0, hint, method);
      }
      push(disposable.stack, resource);
    };
    return addDisposableResource;
  }
  var esnext_iterator_dispose = {};
  var iteratorsCore;
  var hasRequiredIteratorsCore;
  function requireIteratorsCore() {
    if (hasRequiredIteratorsCore) return iteratorsCore;
    hasRequiredIteratorsCore = 1;
    var fails2 = /* @__PURE__ */ requireFails();
    var isCallable2 = /* @__PURE__ */ requireIsCallable();
    var isObject2 = /* @__PURE__ */ requireIsObject$1();
    var create = /* @__PURE__ */ requireObjectCreate();
    var getPrototypeOf = /* @__PURE__ */ requireObjectGetPrototypeOf();
    var defineBuiltIn2 = /* @__PURE__ */ requireDefineBuiltIn();
    var wellKnownSymbol2 = /* @__PURE__ */ requireWellKnownSymbol();
    var IS_PURE = /* @__PURE__ */ requireIsPure();
    var ITERATOR = wellKnownSymbol2("iterator");
    var BUGGY_SAFARI_ITERATORS = false;
    var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;
    if ([].keys) {
      arrayIterator = [].keys();
      if (!("next" in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;
      else {
        PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
        if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
      }
    }
    var NEW_ITERATOR_PROTOTYPE = !isObject2(IteratorPrototype) || fails2(function() {
      var test = {};
      return IteratorPrototype[ITERATOR].call(test) !== test;
    });
    if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype = {};
    else if (IS_PURE) IteratorPrototype = create(IteratorPrototype);
    if (!isCallable2(IteratorPrototype[ITERATOR])) {
      defineBuiltIn2(IteratorPrototype, ITERATOR, function() {
        return this;
      });
    }
    iteratorsCore = {
      IteratorPrototype,
      BUGGY_SAFARI_ITERATORS
    };
    return iteratorsCore;
  }
  var hasRequiredEsnext_iterator_dispose;
  function requireEsnext_iterator_dispose() {
    if (hasRequiredEsnext_iterator_dispose) return esnext_iterator_dispose;
    hasRequiredEsnext_iterator_dispose = 1;
    var call = /* @__PURE__ */ requireFunctionCall();
    var defineBuiltIn2 = /* @__PURE__ */ requireDefineBuiltIn();
    var getMethod2 = /* @__PURE__ */ requireGetMethod();
    var hasOwn2 = /* @__PURE__ */ requireHasOwnProperty();
    var wellKnownSymbol2 = /* @__PURE__ */ requireWellKnownSymbol();
    var IteratorPrototype = requireIteratorsCore().IteratorPrototype;
    var DISPOSE = wellKnownSymbol2("dispose");
    if (!hasOwn2(IteratorPrototype, DISPOSE)) {
      defineBuiltIn2(IteratorPrototype, DISPOSE, function() {
        var $return = getMethod2(this, "return");
        if ($return) call($return, this);
      });
    }
    return esnext_iterator_dispose;
  }
  var esnext_disposableStack_constructor = {};
  var hasRequiredEsnext_disposableStack_constructor;
  function requireEsnext_disposableStack_constructor() {
    if (hasRequiredEsnext_disposableStack_constructor) return esnext_disposableStack_constructor;
    hasRequiredEsnext_disposableStack_constructor = 1;
    var $ = /* @__PURE__ */ require_export();
    var DESCRIPTORS = /* @__PURE__ */ requireDescriptors();
    var getBuiltIn2 = /* @__PURE__ */ requireGetBuiltIn();
    var aCallable2 = /* @__PURE__ */ requireACallable();
    var anInstance2 = /* @__PURE__ */ requireAnInstance();
    var defineBuiltIn2 = /* @__PURE__ */ requireDefineBuiltIn();
    var defineBuiltIns2 = /* @__PURE__ */ requireDefineBuiltIns();
    var defineBuiltInAccessor2 = /* @__PURE__ */ requireDefineBuiltInAccessor();
    var wellKnownSymbol2 = /* @__PURE__ */ requireWellKnownSymbol();
    var InternalStateModule = /* @__PURE__ */ requireInternalState();
    var addDisposableResource2 = /* @__PURE__ */ requireAddDisposableResource();
    var SuppressedError2 = getBuiltIn2("SuppressedError");
    var $ReferenceError = ReferenceError;
    var DISPOSE = wellKnownSymbol2("dispose");
    var TO_STRING_TAG = wellKnownSymbol2("toStringTag");
    var DISPOSABLE_STACK = "DisposableStack";
    var setInternalState = InternalStateModule.set;
    var getDisposableStackInternalState = InternalStateModule.getterFor(DISPOSABLE_STACK);
    var HINT = "sync-dispose";
    var DISPOSED = "disposed";
    var PENDING = "pending";
    var getPendingDisposableStackInternalState = function(stack) {
      var internalState2 = getDisposableStackInternalState(stack);
      if (internalState2.state === DISPOSED) throw new $ReferenceError(DISPOSABLE_STACK + " already disposed");
      return internalState2;
    };
    var $DisposableStack = function DisposableStack() {
      setInternalState(anInstance2(this, DisposableStackPrototype), {
        type: DISPOSABLE_STACK,
        state: PENDING,
        stack: []
      });
      if (!DESCRIPTORS) this.disposed = false;
    };
    var DisposableStackPrototype = $DisposableStack.prototype;
    defineBuiltIns2(DisposableStackPrototype, {
      dispose: function dispose() {
        var internalState2 = getDisposableStackInternalState(this);
        if (internalState2.state === DISPOSED) return;
        internalState2.state = DISPOSED;
        if (!DESCRIPTORS) this.disposed = true;
        var stack = internalState2.stack;
        var i2 = stack.length;
        var thrown = false;
        var suppressed;
        while (i2) {
          var disposeMethod = stack[--i2];
          stack[i2] = null;
          try {
            disposeMethod();
          } catch (errorResult) {
            if (thrown) {
              suppressed = new SuppressedError2(errorResult, suppressed);
            } else {
              thrown = true;
              suppressed = errorResult;
            }
          }
        }
        internalState2.stack = null;
        if (thrown) throw suppressed;
      },
      use: function use(value) {
        addDisposableResource2(getPendingDisposableStackInternalState(this), value, HINT);
        return value;
      },
      adopt: function adopt(value, onDispose) {
        var internalState2 = getPendingDisposableStackInternalState(this);
        aCallable2(onDispose);
        addDisposableResource2(internalState2, void 0, HINT, function() {
          onDispose(value);
        });
        return value;
      },
      defer: function defer(onDispose) {
        var internalState2 = getPendingDisposableStackInternalState(this);
        aCallable2(onDispose);
        addDisposableResource2(internalState2, void 0, HINT, onDispose);
      },
      move: function move() {
        var internalState2 = getPendingDisposableStackInternalState(this);
        var newDisposableStack = new $DisposableStack();
        getDisposableStackInternalState(newDisposableStack).stack = internalState2.stack;
        internalState2.stack = [];
        internalState2.state = DISPOSED;
        if (!DESCRIPTORS) this.disposed = true;
        return newDisposableStack;
      }
    });
    if (DESCRIPTORS) defineBuiltInAccessor2(DisposableStackPrototype, "disposed", {
      configurable: true,
      get: function disposed() {
        return getDisposableStackInternalState(this).state === DISPOSED;
      }
    });
    defineBuiltIn2(DisposableStackPrototype, DISPOSE, DisposableStackPrototype.dispose, { name: "dispose" });
    defineBuiltIn2(DisposableStackPrototype, TO_STRING_TAG, DISPOSABLE_STACK, { nonWritable: true });
    $({ global: true, constructor: true }, {
      DisposableStack: $DisposableStack
    });
    return esnext_disposableStack_constructor;
  }
  var disposableStack;
  var hasRequiredDisposableStack;
  function requireDisposableStack() {
    if (hasRequiredDisposableStack) return disposableStack;
    hasRequiredDisposableStack = 1;
    requireEs_error_cause();
    requireEsnext_suppressedError_constructor();
    requireEsnext_disposableStack_constructor();
    requireEsnext_iterator_dispose();
    var path2 = /* @__PURE__ */ requirePath();
    disposableStack = path2.DisposableStack;
    return disposableStack;
  }
  var disposableStackExports = /* @__PURE__ */ requireDisposableStack();
  const DisposableStackPolyfill = /* @__PURE__ */ getDefaultExportFromCjs(disposableStackExports);
  const videoGrid = "_video-grid_b2rnv_2";
  const videoGridBiliFeed4 = "_video-grid-bili-feed4_b2rnv_15";
  const limitTwoLines = "_limit-two-lines_b2rnv_33";
  const videoGridContainer = "_video-grid-container_b2rnv_51";
  const videoGridCustom = "_video-grid-custom_b2rnv_62";
  const narrowMode = "_narrow-mode_b2rnv_112";
  var browser = { exports: {} };
  var ms$1;
  var hasRequiredMs;
  function requireMs() {
    if (hasRequiredMs) return ms$1;
    hasRequiredMs = 1;
    var s2 = 1e3;
    var m = s2 * 60;
    var h = m * 60;
    var d2 = h * 24;
    var w = d2 * 7;
    var y = d2 * 365.25;
    ms$1 = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse2(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse2(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match2 = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match2) {
        return;
      }
      var n2 = parseFloat(match2[1]);
      var type = (match2[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n2 * y;
        case "weeks":
        case "week":
        case "w":
          return n2 * w;
        case "days":
        case "day":
        case "d":
          return n2 * d2;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n2 * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n2 * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n2 * s2;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n2;
        default:
          return void 0;
      }
    }
    function fmtShort(ms2) {
      var msAbs = Math.abs(ms2);
      if (msAbs >= d2) {
        return Math.round(ms2 / d2) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms2 / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms2 / m) + "m";
      }
      if (msAbs >= s2) {
        return Math.round(ms2 / s2) + "s";
      }
      return ms2 + "ms";
    }
    function fmtLong(ms2) {
      var msAbs = Math.abs(ms2);
      if (msAbs >= d2) {
        return plural(ms2, msAbs, d2, "day");
      }
      if (msAbs >= h) {
        return plural(ms2, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms2, msAbs, m, "minute");
      }
      if (msAbs >= s2) {
        return plural(ms2, msAbs, s2, "second");
      }
      return ms2 + " ms";
    }
    function plural(ms2, msAbs, n2, name) {
      var isPlural = msAbs >= n2 * 1.5;
      return Math.round(ms2 / n2) + " " + name + (isPlural ? "s" : "");
    }
    return ms$1;
  }
  var common;
  var hasRequiredCommon;
  function requireCommon() {
    if (hasRequiredCommon) return common;
    hasRequiredCommon = 1;
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = requireMs();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash2 = 0;
        for (let i2 = 0; i2 < namespace.length; i2++) {
          hash2 = (hash2 << 5) - hash2 + namespace.charCodeAt(i2);
          hash2 |= 0;
        }
        return createDebug.colors[Math.abs(hash2) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug2(...args) {
          if (!debug2.enabled) {
            return;
          }
          const self2 = debug2;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms2 = curr - (prevTime || curr);
          self2.diff = ms2;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match2, format) => {
            if (match2 === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match2 = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match2;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug2.namespace = namespace;
        debug2.useColors = createDebug.useColors();
        debug2.color = createDebug.selectColor(namespace);
        debug2.extend = extend;
        debug2.destroy = createDebug.destroy;
        Object.defineProperty(debug2, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug2);
        }
        return debug2;
      }
      function extend(namespace, delimiter2) {
        const newDebug = createDebug(this.namespace + (typeof delimiter2 === "undefined" ? ":" : delimiter2) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(" ", ",").split(",").filter(Boolean);
        for (const ns of split) {
          if (ns[0] === "-") {
            createDebug.skips.push(ns.slice(1));
          } else {
            createDebug.names.push(ns);
          }
        }
      }
      function matchesTemplate(search, template) {
        let searchIndex = 0;
        let templateIndex = 0;
        let starIndex = -1;
        let matchIndex = 0;
        while (searchIndex < search.length) {
          if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
            if (template[templateIndex] === "*") {
              starIndex = templateIndex;
              matchIndex = searchIndex;
              templateIndex++;
            } else {
              searchIndex++;
              templateIndex++;
            }
          } else if (starIndex !== -1) {
            templateIndex = starIndex + 1;
            matchIndex++;
            searchIndex = matchIndex;
          } else {
            return false;
          }
        }
        while (templateIndex < template.length && template[templateIndex] === "*") {
          templateIndex++;
        }
        return templateIndex === template.length;
      }
      function disable() {
        const namespaces = [
          ...createDebug.names,
          ...createDebug.skips.map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        for (const skip of createDebug.skips) {
          if (matchesTemplate(name, skip)) {
            return false;
          }
        }
        for (const ns of createDebug.names) {
          if (matchesTemplate(name, ns)) {
            return true;
          }
        }
        return false;
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    common = setup;
    return common;
  }
  var hasRequiredBrowser;
  function requireBrowser() {
    if (hasRequiredBrowser) return browser.exports;
    hasRequiredBrowser = 1;
    (function(module, exports) {
      var define_process_env_default = {};
      exports.formatArgs = formatArgs;
      exports.save = save;
      exports.load = load;
      exports.useColors = useColors;
      exports.storage = localstorage();
      exports.destroy = /* @__PURE__ */ (() => {
        let warned = false;
        return () => {
          if (!warned) {
            warned = true;
            console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
          }
        };
      })();
      exports.colors = [
        "#0000CC",
        "#0000FF",
        "#0033CC",
        "#0033FF",
        "#0066CC",
        "#0066FF",
        "#0099CC",
        "#0099FF",
        "#00CC00",
        "#00CC33",
        "#00CC66",
        "#00CC99",
        "#00CCCC",
        "#00CCFF",
        "#3300CC",
        "#3300FF",
        "#3333CC",
        "#3333FF",
        "#3366CC",
        "#3366FF",
        "#3399CC",
        "#3399FF",
        "#33CC00",
        "#33CC33",
        "#33CC66",
        "#33CC99",
        "#33CCCC",
        "#33CCFF",
        "#6600CC",
        "#6600FF",
        "#6633CC",
        "#6633FF",
        "#66CC00",
        "#66CC33",
        "#9900CC",
        "#9900FF",
        "#9933CC",
        "#9933FF",
        "#99CC00",
        "#99CC33",
        "#CC0000",
        "#CC0033",
        "#CC0066",
        "#CC0099",
        "#CC00CC",
        "#CC00FF",
        "#CC3300",
        "#CC3333",
        "#CC3366",
        "#CC3399",
        "#CC33CC",
        "#CC33FF",
        "#CC6600",
        "#CC6633",
        "#CC9900",
        "#CC9933",
        "#CCCC00",
        "#CCCC33",
        "#FF0000",
        "#FF0033",
        "#FF0066",
        "#FF0099",
        "#FF00CC",
        "#FF00FF",
        "#FF3300",
        "#FF3333",
        "#FF3366",
        "#FF3399",
        "#FF33CC",
        "#FF33FF",
        "#FF6600",
        "#FF6633",
        "#FF9900",
        "#FF9933",
        "#FFCC00",
        "#FFCC33"
      ];
      function useColors() {
        if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
          return true;
        }
        if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
          return false;
        }
        let m;
        return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
        typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
        // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
        typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
        typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
      }
      function formatArgs(args) {
        args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
        if (!this.useColors) {
          return;
        }
        const c2 = "color: " + this.color;
        args.splice(1, 0, c2, "color: inherit");
        let index = 0;
        let lastC = 0;
        args[0].replace(/%[a-zA-Z%]/g, (match2) => {
          if (match2 === "%%") {
            return;
          }
          index++;
          if (match2 === "%c") {
            lastC = index;
          }
        });
        args.splice(lastC, 0, c2);
      }
      exports.log = console.debug || console.log || (() => {
      });
      function save(namespaces) {
        try {
          if (namespaces) {
            exports.storage.setItem("debug", namespaces);
          } else {
            exports.storage.removeItem("debug");
          }
        } catch (error) {
        }
      }
      function load() {
        let r2;
        try {
          r2 = exports.storage.getItem("debug");
        } catch (error) {
        }
        if (!r2 && typeof process !== "undefined" && "env" in process) {
          r2 = define_process_env_default.DEBUG;
        }
        return r2;
      }
      function localstorage() {
        try {
          return localStorage;
        } catch (error) {
        }
      }
      module.exports = requireCommon()(exports);
      const { formatters } = module.exports;
      formatters.j = function(v) {
        try {
          return JSON.stringify(v);
        } catch (error) {
          return "[UnexpectedJSONParseError]: " + error.message;
        }
      };
    })(browser, browser.exports);
    return browser.exports;
  }
  var browserExports = requireBrowser();
  const debugFactory = /* @__PURE__ */ getDefaultExportFromCjs(browserExports);
  const APP_NAME = "Bilibili-Gate";
  const APP_NAMESPACE = "bilibili-gate";
  const APP_KEY_PREFIX = "bilibili_gate";
  const APP_SHORT_PREFIX = "bili-gate";
  const baseDebug = debugFactory(APP_NAMESPACE);
  const HOST_API = "https://api.bilibili.com";
  const HOST_APP = "https://app.bilibili.com";
  const TVKeyInfo = {
    appkey: "4409e2ce8ffd12b8",
    appsec: "59b43e04ad6965f34319062b478f83dd"
  };
  const APP_CLS_ROOT = `${APP_NAMESPACE}-root`;
  const APP_CLS_GRID = `${APP_NAMESPACE}-video-grid`;
  const APP_CLS_CARD = `${APP_NAMESPACE}-video-card`;
  const APP_CLS_CARD_ACTIVE = `${APP_NAMESPACE}-video-card-active`;
  const APP_CLS_CARD_COVER = `${APP_NAMESPACE}-video-card-cover`;
  const APP_CLS_TAB_BAR = `${APP_NAMESPACE}-tab-bar`;
  const REQUEST_FAIL_MSG = "请求失败, 请重试 !!!";
  const OPERATION_FAIL_MSG = "操作失败, 请重试 !!!";
  var BiliDomain = /* @__PURE__ */ ((BiliDomain2) => {
    BiliDomain2["Tld"] = ".bilibili.com";
    BiliDomain2["Main"] = "www.bilibili.com";
    BiliDomain2["Space"] = "space.bilibili.com";
    BiliDomain2["Search"] = "search.bilibili.com";
    return BiliDomain2;
  })(BiliDomain || {});
  const {
    hostname,
    pathname
  } = location;
  const IN_BILIBILI = hostname.endsWith(
    ".bilibili.com"
    /* Tld */
  );
  const IN_BILIBILI_HOMEPAGE = IN_BILIBILI && (pathname === "/" || pathname === "/index.html");
  const IN_BILIBILI_VIDEO_PLAY_PAGE = IN_BILIBILI && ["/video/", "/list/watchlater", "/bangumi/play/"].some((prefix2) => pathname.startsWith(prefix2));
  const IN_BILIBILI_SPACE_PAGE = hostname === "space.bilibili.com";
  const IN_BILIBILI_SEARCH_PAGE = hostname === "search.bilibili.com";
  function logFactory(logFn) {
    return function appLog2(...args) {
      const [message2, ...rest] = args;
      if (typeof message2 === "string") {
        return logFn(`[${APP_NAME}]: ${message2}`, ...rest);
      } else {
        return logFn(`[${APP_NAME}]:`, message2, ...rest);
      }
    };
  }
  const appWarn = logFactory(console.warn);
  const appError = logFactory(console.error);
  function countBy(arr, mapper) {
    const result = {};
    for (let i2 = 0; i2 < arr.length; i2++) {
      const item = arr[i2];
      const key = mapper(item);
      result[key] = (result[key] ?? 0) + 1;
    }
    return result;
  }
  function difference(firstArr, secondArr) {
    const secondSet = new Set(secondArr);
    return firstArr.filter((item) => !secondSet.has(item));
  }
  function groupBy(arr, getKeyFromItem) {
    const result = {};
    for (let i2 = 0; i2 < arr.length; i2++) {
      const item = arr[i2];
      const key = getKeyFromItem(item);
      if (!Object.hasOwn(result, key)) {
        result[key] = [];
      }
      result[key].push(item);
    }
    return result;
  }
  function compareValues(a2, b, order) {
    if (a2 < b) {
      return order === "asc" ? -1 : 1;
    }
    if (a2 > b) {
      return order === "asc" ? 1 : -1;
    }
    return 0;
  }
  function orderBy(arr, criteria, orders) {
    return arr.slice().sort((a2, b) => {
      const ordersLength = orders.length;
      for (let i2 = 0; i2 < criteria.length; i2++) {
        const order = ordersLength > i2 ? orders[i2] : orders[ordersLength - 1];
        const criterion = criteria[i2];
        const criterionIsFunction = typeof criterion === "function";
        const valueA = criterionIsFunction ? criterion(a2) : a2[criterion];
        const valueB = criterionIsFunction ? criterion(b) : b[criterion];
        const result = compareValues(valueA, valueB, order);
        if (result !== 0) {
          return result;
        }
      }
      return 0;
    });
  }
  function random(minimum, maximum) {
    if (maximum == null) {
      maximum = minimum;
      minimum = 0;
    }
    if (minimum >= maximum) {
      throw new Error("Invalid input: The maximum value must be greater than the minimum value.");
    }
    return Math.random() * (maximum - minimum) + minimum;
  }
  function randomInt(minimum, maximum) {
    return Math.floor(random(minimum, maximum));
  }
  function shuffle(arr) {
    const result = arr.slice();
    for (let i2 = result.length - 1; i2 >= 1; i2--) {
      const j = Math.floor(Math.random() * (i2 + 1));
      [result[i2], result[j]] = [result[j], result[i2]];
    }
    return result;
  }
  function isSymbol(value) {
    return typeof value === "symbol" || value instanceof Symbol;
  }
  function toNumber(value) {
    if (isSymbol(value)) {
      return NaN;
    }
    return Number(value);
  }
  function toFinite(value) {
    if (!value) {
      return value === 0 ? value : 0;
    }
    value = toNumber(value);
    if (value === Infinity || value === -Infinity) {
      const sign = value < 0 ? -1 : 1;
      return sign * Number.MAX_VALUE;
    }
    return value === value ? value : 0;
  }
  function toInteger(value) {
    const finite = toFinite(value);
    const remainder = finite % 1;
    return remainder ? finite - remainder : finite;
  }
  function uniq(arr) {
    return Array.from(new Set(arr));
  }
  function uniqBy(arr, mapper) {
    const map = /* @__PURE__ */ new Map();
    for (let i2 = 0; i2 < arr.length; i2++) {
      const item = arr[i2];
      const key = mapper(item);
      if (!map.has(key)) {
        map.set(key, item);
      }
    }
    return Array.from(map.values());
  }
  let AbortError$2 = class AbortError extends Error {
    constructor(message2 = "The operation was aborted") {
      super(message2);
      this.name = "AbortError";
    }
  };
  function debounce$1(func, debounceMs, { signal, edges } = {}) {
    let pendingThis = void 0;
    let pendingArgs = null;
    const leading = edges != null && edges.includes("leading");
    const trailing = edges == null || edges.includes("trailing");
    const invoke = () => {
      if (pendingArgs !== null) {
        func.apply(pendingThis, pendingArgs);
        pendingThis = void 0;
        pendingArgs = null;
      }
    };
    const onTimerEnd = () => {
      if (trailing) {
        invoke();
      }
      cancel();
    };
    let timeoutId = null;
    const schedule = () => {
      if (timeoutId != null) {
        clearTimeout(timeoutId);
      }
      timeoutId = setTimeout(() => {
        timeoutId = null;
        onTimerEnd();
      }, debounceMs);
    };
    const cancelTimer = () => {
      if (timeoutId !== null) {
        clearTimeout(timeoutId);
        timeoutId = null;
      }
    };
    const cancel = () => {
      cancelTimer();
      pendingThis = void 0;
      pendingArgs = null;
    };
    const flush = () => {
      cancelTimer();
      invoke();
    };
    const debounced = function(...args) {
      if (signal == null ? void 0 : signal.aborted) {
        return;
      }
      pendingThis = this;
      pendingArgs = args;
      const isFirstCall = timeoutId == null;
      schedule();
      if (leading && isFirstCall) {
        invoke();
      }
    };
    debounced.schedule = schedule;
    debounced.cancel = cancel;
    debounced.flush = flush;
    signal == null ? void 0 : signal.addEventListener("abort", cancel, { once: true });
    return debounced;
  }
  function noop$1() {
  }
  function once(func) {
    let called = false;
    let cache2;
    return function(...args) {
      if (!called) {
        called = true;
        cache2 = func(...args);
      }
      return cache2;
    };
  }
  function delay(ms2, { signal } = {}) {
    return new Promise((resolve, reject) => {
      const abortError = () => {
        reject(new AbortError$2());
      };
      const abortHandler = () => {
        clearTimeout(timeoutId);
        abortError();
      };
      if (signal == null ? void 0 : signal.aborted) {
        return abortError();
      }
      const timeoutId = setTimeout(() => {
        signal == null ? void 0 : signal.removeEventListener("abort", abortHandler);
        resolve();
      }, ms2);
      signal == null ? void 0 : signal.addEventListener("abort", abortHandler, { once: true });
    });
  }
  function throttle$1(func, throttleMs, { signal, edges = ["leading", "trailing"] } = {}) {
    let pendingAt = null;
    const debounced = debounce$1(func, throttleMs, { signal, edges });
    const throttled = function(...args) {
      if (pendingAt == null) {
        pendingAt = Date.now();
      } else {
        if (Date.now() - pendingAt >= throttleMs) {
          pendingAt = Date.now();
          debounced.cancel();
        }
      }
      debounced(...args);
    };
    throttled.cancel = debounced.cancel;
    throttled.flush = debounced.flush;
    return throttled;
  }
  function range(start, end, step = 1) {
    if (end == null) {
      end = start;
      start = 0;
    }
    if (!Number.isInteger(step) || step === 0) {
      throw new Error(`The step value must be a non-zero integer.`);
    }
    const length2 = Math.max(Math.ceil((end - start) / step), 0);
    const result = new Array(length2);
    for (let i2 = 0; i2 < length2; i2++) {
      result[i2] = start + i2 * step;
    }
    return result;
  }
  function isPrimitive(value) {
    return value == null || typeof value !== "object" && typeof value !== "function";
  }
  function isTypedArray(x) {
    return ArrayBuffer.isView(x) && !(x instanceof DataView);
  }
  function getSymbols(object) {
    return Object.getOwnPropertySymbols(object).filter((symbol) => Object.prototype.propertyIsEnumerable.call(object, symbol));
  }
  function getTag(value) {
    if (value == null) {
      return value === void 0 ? "[object Undefined]" : "[object Null]";
    }
    return Object.prototype.toString.call(value);
  }
  const regexpTag = "[object RegExp]";
  const stringTag = "[object String]";
  const numberTag = "[object Number]";
  const booleanTag = "[object Boolean]";
  const argumentsTag = "[object Arguments]";
  const symbolTag = "[object Symbol]";
  const dateTag = "[object Date]";
  const mapTag = "[object Map]";
  const setTag = "[object Set]";
  const arrayTag = "[object Array]";
  const functionTag = "[object Function]";
  const arrayBufferTag = "[object ArrayBuffer]";
  const objectTag = "[object Object]";
  const errorTag = "[object Error]";
  const dataViewTag = "[object DataView]";
  const uint8ArrayTag = "[object Uint8Array]";
  const uint8ClampedArrayTag = "[object Uint8ClampedArray]";
  const uint16ArrayTag = "[object Uint16Array]";
  const uint32ArrayTag = "[object Uint32Array]";
  const bigUint64ArrayTag = "[object BigUint64Array]";
  const int8ArrayTag = "[object Int8Array]";
  const int16ArrayTag = "[object Int16Array]";
  const int32ArrayTag = "[object Int32Array]";
  const bigInt64ArrayTag = "[object BigInt64Array]";
  const float32ArrayTag = "[object Float32Array]";
  const float64ArrayTag = "[object Float64Array]";
  function cloneDeepWithImpl(valueToClone, keyToClone, objectToClone, stack = /* @__PURE__ */ new Map(), cloneValue = void 0) {
    const cloned = cloneValue == null ? void 0 : cloneValue(valueToClone, keyToClone, objectToClone, stack);
    if (cloned != null) {
      return cloned;
    }
    if (isPrimitive(valueToClone)) {
      return valueToClone;
    }
    if (stack.has(valueToClone)) {
      return stack.get(valueToClone);
    }
    if (Array.isArray(valueToClone)) {
      const result = new Array(valueToClone.length);
      stack.set(valueToClone, result);
      for (let i2 = 0; i2 < valueToClone.length; i2++) {
        result[i2] = cloneDeepWithImpl(valueToClone[i2], i2, objectToClone, stack, cloneValue);
      }
      if (Object.hasOwn(valueToClone, "index")) {
        result.index = valueToClone.index;
      }
      if (Object.hasOwn(valueToClone, "input")) {
        result.input = valueToClone.input;
      }
      return result;
    }
    if (valueToClone instanceof Date) {
      return new Date(valueToClone.getTime());
    }
    if (valueToClone instanceof RegExp) {
      const result = new RegExp(valueToClone.source, valueToClone.flags);
      result.lastIndex = valueToClone.lastIndex;
      return result;
    }
    if (valueToClone instanceof Map) {
      const result = /* @__PURE__ */ new Map();
      stack.set(valueToClone, result);
      for (const [key, value] of valueToClone) {
        result.set(key, cloneDeepWithImpl(value, key, objectToClone, stack, cloneValue));
      }
      return result;
    }
    if (valueToClone instanceof Set) {
      const result = /* @__PURE__ */ new Set();
      stack.set(valueToClone, result);
      for (const value of valueToClone) {
        result.add(cloneDeepWithImpl(value, void 0, objectToClone, stack, cloneValue));
      }
      return result;
    }
    if (typeof Buffer !== "undefined" && Buffer.isBuffer(valueToClone)) {
      return valueToClone.subarray();
    }
    if (isTypedArray(valueToClone)) {
      const result = new (Object.getPrototypeOf(valueToClone)).constructor(valueToClone.length);
      stack.set(valueToClone, result);
      for (let i2 = 0; i2 < valueToClone.length; i2++) {
        result[i2] = cloneDeepWithImpl(valueToClone[i2], i2, objectToClone, stack, cloneValue);
      }
      return result;
    }
    if (valueToClone instanceof ArrayBuffer || typeof SharedArrayBuffer !== "undefined" && valueToClone instanceof SharedArrayBuffer) {
      return valueToClone.slice(0);
    }
    if (valueToClone instanceof DataView) {
      const result = new DataView(valueToClone.buffer.slice(0), valueToClone.byteOffset, valueToClone.byteLength);
      stack.set(valueToClone, result);
      copyProperties(result, valueToClone, objectToClone, stack, cloneValue);
      return result;
    }
    if (typeof File !== "undefined" && valueToClone instanceof File) {
      const result = new File([valueToClone], valueToClone.name, {
        type: valueToClone.type
      });
      stack.set(valueToClone, result);
      copyProperties(result, valueToClone, objectToClone, stack, cloneValue);
      return result;
    }
    if (valueToClone instanceof Blob) {
      const result = new Blob([valueToClone], { type: valueToClone.type });
      stack.set(valueToClone, result);
      copyProperties(result, valueToClone, objectToClone, stack, cloneValue);
      return result;
    }
    if (valueToClone instanceof Error) {
      const result = new valueToClone.constructor();
      stack.set(valueToClone, result);
      result.message = valueToClone.message;
      result.name = valueToClone.name;
      result.stack = valueToClone.stack;
      result.cause = valueToClone.cause;
      copyProperties(result, valueToClone, objectToClone, stack, cloneValue);
      return result;
    }
    if (typeof valueToClone === "object" && isCloneableObject(valueToClone)) {
      const result = Object.create(Object.getPrototypeOf(valueToClone));
      stack.set(valueToClone, result);
      copyProperties(result, valueToClone, objectToClone, stack, cloneValue);
      return result;
    }
    return valueToClone;
  }
  function copyProperties(target, source, objectToClone = target, stack, cloneValue) {
    const keys = [...Object.keys(source), ...getSymbols(source)];
    for (let i2 = 0; i2 < keys.length; i2++) {
      const key = keys[i2];
      const descriptor = Object.getOwnPropertyDescriptor(target, key);
      if (descriptor == null || descriptor.writable) {
        target[key] = cloneDeepWithImpl(source[key], key, objectToClone, stack, cloneValue);
      }
    }
  }
  function isCloneableObject(object) {
    switch (getTag(object)) {
      case argumentsTag:
      case arrayTag:
      case arrayBufferTag:
      case dataViewTag:
      case booleanTag:
      case dateTag:
      case float32ArrayTag:
      case float64ArrayTag:
      case int8ArrayTag:
      case int16ArrayTag:
      case int32ArrayTag:
      case mapTag:
      case numberTag:
      case objectTag:
      case regexpTag:
      case setTag:
      case stringTag:
      case symbolTag:
      case uint8ArrayTag:
      case uint8ClampedArrayTag:
      case uint16ArrayTag:
      case uint32ArrayTag: {
        return true;
      }
      default: {
        return false;
      }
    }
  }
  function cloneDeep(obj) {
    return cloneDeepWithImpl(obj, void 0, obj, /* @__PURE__ */ new Map(), void 0);
  }
  function isPlainObject(value) {
    if (!value || typeof value !== "object") {
      return false;
    }
    const proto = Object.getPrototypeOf(value);
    const hasObjectPrototype = proto === null || proto === Object.prototype || Object.getPrototypeOf(proto) === null;
    if (!hasObjectPrototype) {
      return false;
    }
    return Object.prototype.toString.call(value) === "[object Object]";
  }
  function merge$1(target, source) {
    const sourceKeys = Object.keys(source);
    for (let i2 = 0; i2 < sourceKeys.length; i2++) {
      const key = sourceKeys[i2];
      const sourceValue = source[key];
      const targetValue = target[key];
      if (Array.isArray(sourceValue)) {
        if (Array.isArray(targetValue)) {
          target[key] = merge$1(targetValue, sourceValue);
        } else {
          target[key] = merge$1([], sourceValue);
        }
      } else if (isPlainObject(sourceValue)) {
        if (isPlainObject(targetValue)) {
          target[key] = merge$1(targetValue, sourceValue);
        } else {
          target[key] = merge$1({}, sourceValue);
        }
      } else if (targetValue === void 0 || sourceValue !== void 0) {
        target[key] = sourceValue;
      }
    }
    return target;
  }
  function omit(obj, keys) {
    const result = { ...obj };
    for (let i2 = 0; i2 < keys.length; i2++) {
      const key = keys[i2];
      delete result[key];
    }
    return result;
  }
  function pick$1(obj, keys) {
    const result = {};
    for (let i2 = 0; i2 < keys.length; i2++) {
      const key = keys[i2];
      if (Object.hasOwn(obj, key)) {
        result[key] = obj[key];
      }
    }
    return result;
  }
  const CASE_SPLIT_PATTERN = new RegExp("\\p{Lu}?\\p{Ll}+|[0-9]+|\\p{Lu}+(?!\\p{Ll})|\\p{Emoji_Presentation}|\\p{Extended_Pictographic}|\\p{L}+", "gu");
  function words(str) {
    return Array.from(str.match(CASE_SPLIT_PATTERN) ?? []);
  }
  function toMerged(target, source) {
    return merge$1(cloneDeep(target), source);
  }
  function eq(value, other) {
    return value === other || Number.isNaN(value) && Number.isNaN(other);
  }
  function isEqualWith(a2, b, areValuesEqual) {
    return isEqualWithImpl(a2, b, void 0, void 0, void 0, void 0, areValuesEqual);
  }
  function isEqualWithImpl(a2, b, property, aParent, bParent, stack, areValuesEqual) {
    const result = areValuesEqual(a2, b, property, aParent, bParent, stack);
    if (result !== void 0) {
      return result;
    }
    if (typeof a2 === typeof b) {
      switch (typeof a2) {
        case "bigint":
        case "string":
        case "boolean":
        case "symbol":
        case "undefined": {
          return a2 === b;
        }
        case "number": {
          return a2 === b || Object.is(a2, b);
        }
        case "function": {
          return a2 === b;
        }
        case "object": {
          return areObjectsEqual(a2, b, stack, areValuesEqual);
        }
      }
    }
    return areObjectsEqual(a2, b, stack, areValuesEqual);
  }
  function areObjectsEqual(a2, b, stack, areValuesEqual) {
    if (Object.is(a2, b)) {
      return true;
    }
    let aTag = getTag(a2);
    let bTag = getTag(b);
    if (aTag === argumentsTag) {
      aTag = objectTag;
    }
    if (bTag === argumentsTag) {
      bTag = objectTag;
    }
    if (aTag !== bTag) {
      return false;
    }
    switch (aTag) {
      case stringTag:
        return a2.toString() === b.toString();
      case numberTag: {
        const x = a2.valueOf();
        const y = b.valueOf();
        return eq(x, y);
      }
      case booleanTag:
      case dateTag:
      case symbolTag:
        return Object.is(a2.valueOf(), b.valueOf());
      case regexpTag: {
        return a2.source === b.source && a2.flags === b.flags;
      }
      case functionTag: {
        return a2 === b;
      }
    }
    stack = stack ?? /* @__PURE__ */ new Map();
    const aStack = stack.get(a2);
    const bStack = stack.get(b);
    if (aStack != null && bStack != null) {
      return aStack === b;
    }
    stack.set(a2, b);
    stack.set(b, a2);
    try {
      switch (aTag) {
        case mapTag: {
          if (a2.size !== b.size) {
            return false;
          }
          for (const [key, value] of a2.entries()) {
            if (!b.has(key) || !isEqualWithImpl(value, b.get(key), key, a2, b, stack, areValuesEqual)) {
              return false;
            }
          }
          return true;
        }
        case setTag: {
          if (a2.size !== b.size) {
            return false;
          }
          const aValues = Array.from(a2.values());
          const bValues = Array.from(b.values());
          for (let i2 = 0; i2 < aValues.length; i2++) {
            const aValue = aValues[i2];
            const index = bValues.findIndex((bValue) => {
              return isEqualWithImpl(aValue, bValue, void 0, a2, b, stack, areValuesEqual);
            });
            if (index === -1) {
              return false;
            }
            bValues.splice(index, 1);
          }
          return true;
        }
        case arrayTag:
        case uint8ArrayTag:
        case uint8ClampedArrayTag:
        case uint16ArrayTag:
        case uint32ArrayTag:
        case bigUint64ArrayTag:
        case int8ArrayTag:
        case int16ArrayTag:
        case int32ArrayTag:
        case bigInt64ArrayTag:
        case float32ArrayTag:
        case float64ArrayTag: {
          if (typeof Buffer !== "undefined" && Buffer.isBuffer(a2) !== Buffer.isBuffer(b)) {
            return false;
          }
          if (a2.length !== b.length) {
            return false;
          }
          for (let i2 = 0; i2 < a2.length; i2++) {
            if (!isEqualWithImpl(a2[i2], b[i2], i2, a2, b, stack, areValuesEqual)) {
              return false;
            }
          }
          return true;
        }
        case arrayBufferTag: {
          if (a2.byteLength !== b.byteLength) {
            return false;
          }
          return areObjectsEqual(new Uint8Array(a2), new Uint8Array(b), stack, areValuesEqual);
        }
        case dataViewTag: {
          if (a2.byteLength !== b.byteLength || a2.byteOffset !== b.byteOffset) {
            return false;
          }
          return areObjectsEqual(new Uint8Array(a2), new Uint8Array(b), stack, areValuesEqual);
        }
        case errorTag: {
          return a2.name === b.name && a2.message === b.message;
        }
        case objectTag: {
          const areEqualInstances = areObjectsEqual(a2.constructor, b.constructor, stack, areValuesEqual) || isPlainObject(a2) && isPlainObject(b);
          if (!areEqualInstances) {
            return false;
          }
          const aKeys = [...Object.keys(a2), ...getSymbols(a2)];
          const bKeys = [...Object.keys(b), ...getSymbols(b)];
          if (aKeys.length !== bKeys.length) {
            return false;
          }
          for (let i2 = 0; i2 < aKeys.length; i2++) {
            const propKey = aKeys[i2];
            const aProp = a2[propKey];
            if (!Object.hasOwn(b, propKey)) {
              return false;
            }
            const bProp = b[propKey];
            if (!isEqualWithImpl(aProp, bProp, propKey, a2, b, stack, areValuesEqual)) {
              return false;
            }
          }
          return true;
        }
        default: {
          return false;
        }
      }
    } finally {
      stack.delete(a2);
      stack.delete(b);
    }
  }
  function isEqual$2(a2, b) {
    return isEqualWith(a2, b, noop$1);
  }
  function isNil(x) {
    return x == null;
  }
  function startCase(str) {
    const words$1 = words(str.trim());
    let result = "";
    for (let i2 = 0; i2 < words$1.length; i2++) {
      const word = words$1[i2];
      if (result) {
        result += " ";
      }
      result += word[0].toUpperCase() + word.slice(1).toLowerCase();
    }
    return result;
  }
  function invariant(condition, message2) {
    if (condition) {
      return;
    }
    throw new Error(message2);
  }
  var ETab = /* @__PURE__ */ ((ETab2) => {
    ETab2["AppRecommend"] = "app-recommend";
    ETab2["PcRecommend"] = "pc-recommend";
    ETab2["KeepFollowOnly"] = "keep-follow-only";
    ETab2["DynamicFeed"] = "dynamic-feed";
    ETab2["Watchlater"] = "watchlater";
    ETab2["Fav"] = "fav";
    ETab2["Hot"] = "hot";
    ETab2["Live"] = "live";
    ETab2["SpaceUpload"] = "space-upload";
    return ETab2;
  })(ETab || {});
  var EHotSubTab = /* @__PURE__ */ ((EHotSubTab2) => {
    EHotSubTab2["PopularGeneral"] = "popular-general";
    EHotSubTab2["PopularWeekly"] = "popular-weekly";
    EHotSubTab2["Rank"] = "ranking";
    return EHotSubTab2;
  })(EHotSubTab || {});
  const ALL_TAB_KEYS = Object.values(ETab);
  const NONE_CONFIGURABLE_TAB_KEYS = [
    "space-upload"
    /* SpaceUpload */
  ];
  const CONFIGURABLE_TAB_KEYS = difference(ALL_TAB_KEYS, NONE_CONFIGURABLE_TAB_KEYS);
  var jsxRuntime = { exports: {} };
  var reactJsxRuntime_production_min = {};
  /**
   * @license React
   * react-jsx-runtime.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var hasRequiredReactJsxRuntime_production_min;
  function requireReactJsxRuntime_production_min() {
    if (hasRequiredReactJsxRuntime_production_min) return reactJsxRuntime_production_min;
    hasRequiredReactJsxRuntime_production_min = 1;
    var f2 = H, k = Symbol.for("react.element"), l2 = Symbol.for("react.fragment"), m = Object.prototype.hasOwnProperty, n2 = f2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p2 = { key: true, ref: true, __self: true, __source: true };
    function q(c2, a2, g) {
      var b, d2 = {}, e2 = null, h = null;
      void 0 !== g && (e2 = "" + g);
      void 0 !== a2.key && (e2 = "" + a2.key);
      void 0 !== a2.ref && (h = a2.ref);
      for (b in a2) m.call(a2, b) && !p2.hasOwnProperty(b) && (d2[b] = a2[b]);
      if (c2 && c2.defaultProps) for (b in a2 = c2.defaultProps, a2) void 0 === d2[b] && (d2[b] = a2[b]);
      return { $$typeof: k, type: c2, key: e2, ref: h, props: d2, _owner: n2.current };
    }
    reactJsxRuntime_production_min.Fragment = l2;
    reactJsxRuntime_production_min.jsx = q;
    reactJsxRuntime_production_min.jsxs = q;
    return reactJsxRuntime_production_min;
  }
  var hasRequiredJsxRuntime;
  function requireJsxRuntime() {
    if (hasRequiredJsxRuntime) return jsxRuntime.exports;
    hasRequiredJsxRuntime = 1;
    {
      jsxRuntime.exports = requireReactJsxRuntime_production_min();
    }
    return jsxRuntime.exports;
  }
  var jsxRuntimeExports = requireJsxRuntime();
  function sheetForTag(tag) {
    if (tag.sheet) {
      return tag.sheet;
    }
    for (var i2 = 0; i2 < document.styleSheets.length; i2++) {
      if (document.styleSheets[i2].ownerNode === tag) {
        return document.styleSheets[i2];
      }
    }
    return void 0;
  }
  function createStyleElement(options) {
    var tag = document.createElement("style");
    tag.setAttribute("data-emotion", options.key);
    if (options.nonce !== void 0) {
      tag.setAttribute("nonce", options.nonce);
    }
    tag.appendChild(document.createTextNode(""));
    tag.setAttribute("data-s", "");
    return tag;
  }
  var StyleSheet = /* @__PURE__ */ function() {
    function StyleSheet2(options) {
      var _this = this;
      this._insertTag = function(tag) {
        var before;
        if (_this.tags.length === 0) {
          if (_this.insertionPoint) {
            before = _this.insertionPoint.nextSibling;
          } else if (_this.prepend) {
            before = _this.container.firstChild;
          } else {
            before = _this.before;
          }
        } else {
          before = _this.tags[_this.tags.length - 1].nextSibling;
        }
        _this.container.insertBefore(tag, before);
        _this.tags.push(tag);
      };
      this.isSpeedy = options.speedy === void 0 ? true : options.speedy;
      this.tags = [];
      this.ctr = 0;
      this.nonce = options.nonce;
      this.key = options.key;
      this.container = options.container;
      this.prepend = options.prepend;
      this.insertionPoint = options.insertionPoint;
      this.before = null;
    }
    var _proto = StyleSheet2.prototype;
    _proto.hydrate = function hydrate(nodes) {
      nodes.forEach(this._insertTag);
    };
    _proto.insert = function insert(rule) {
      if (this.ctr % (this.isSpeedy ? 65e3 : 1) === 0) {
        this._insertTag(createStyleElement(this));
      }
      var tag = this.tags[this.tags.length - 1];
      if (this.isSpeedy) {
        var sheet = sheetForTag(tag);
        try {
          sheet.insertRule(rule, sheet.cssRules.length);
        } catch (e2) {
        }
      } else {
        tag.appendChild(document.createTextNode(rule));
      }
      this.ctr++;
    };
    _proto.flush = function flush() {
      this.tags.forEach(function(tag) {
        var _tag$parentNode;
        return (_tag$parentNode = tag.parentNode) == null ? void 0 : _tag$parentNode.removeChild(tag);
      });
      this.tags = [];
      this.ctr = 0;
    };
    return StyleSheet2;
  }();
  var MS = "-ms-";
  var MOZ = "-moz-";
  var WEBKIT = "-webkit-";
  var COMMENT = "comm";
  var RULESET = "rule";
  var DECLARATION = "decl";
  var IMPORT = "@import";
  var KEYFRAMES = "@keyframes";
  var LAYER = "@layer";
  var abs = Math.abs;
  var from = String.fromCharCode;
  var assign = Object.assign;
  function hash(value, length2) {
    return charat(value, 0) ^ 45 ? (((length2 << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3) : 0;
  }
  function trim(value) {
    return value.trim();
  }
  function match(value, pattern) {
    return (value = pattern.exec(value)) ? value[0] : value;
  }
  function replace(value, pattern, replacement) {
    return value.replace(pattern, replacement);
  }
  function indexof(value, search) {
    return value.indexOf(search);
  }
  function charat(value, index) {
    return value.charCodeAt(index) | 0;
  }
  function substr(value, begin, end) {
    return value.slice(begin, end);
  }
  function strlen(value) {
    return value.length;
  }
  function sizeof(value) {
    return value.length;
  }
  function append(value, array) {
    return array.push(value), value;
  }
  function combine(array, callback) {
    return array.map(callback).join("");
  }
  var line = 1;
  var column = 1;
  var length = 0;
  var position = 0;
  var character = 0;
  var characters = "";
  function node(value, root2, parent, type, props, children, length2) {
    return { value, root: root2, parent, type, props, children, line, column, length: length2, return: "" };
  }
  function copy(root2, props) {
    return assign(node("", null, null, "", null, null, 0), root2, { length: -root2.length }, props);
  }
  function char() {
    return character;
  }
  function prev() {
    character = position > 0 ? charat(characters, --position) : 0;
    if (column--, character === 10)
      column = 1, line--;
    return character;
  }
  function next() {
    character = position < length ? charat(characters, position++) : 0;
    if (column++, character === 10)
      column = 1, line++;
    return character;
  }
  function peek() {
    return charat(characters, position);
  }
  function caret() {
    return position;
  }
  function slice(begin, end) {
    return substr(characters, begin, end);
  }
  function token(type) {
    switch (type) {
      // \0 \t \n \r \s whitespace token
      case 0:
      case 9:
      case 10:
      case 13:
      case 32:
        return 5;
      // ! + , / > @ ~ isolate token
      case 33:
      case 43:
      case 44:
      case 47:
      case 62:
      case 64:
      case 126:
      // ; { } breakpoint token
      case 59:
      case 123:
      case 125:
        return 4;
      // : accompanied token
      case 58:
        return 3;
      // " ' ( [ opening delimit token
      case 34:
      case 39:
      case 40:
      case 91:
        return 2;
      // ) ] closing delimit token
      case 41:
      case 93:
        return 1;
    }
    return 0;
  }
  function alloc(value) {
    return line = column = 1, length = strlen(characters = value), position = 0, [];
  }
  function dealloc(value) {
    return characters = "", value;
  }
  function delimit(type) {
    return trim(slice(position - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)));
  }
  function whitespace(type) {
    while (character = peek())
      if (character < 33)
        next();
      else
        break;
    return token(type) > 2 || token(character) > 3 ? "" : " ";
  }
  function escaping(index, count) {
    while (--count && next())
      if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
        break;
    return slice(index, caret() + (count < 6 && peek() == 32 && next() == 32));
  }
  function delimiter(type) {
    while (next())
      switch (character) {
        // ] ) " '
        case type:
          return position;
        // " '
        case 34:
        case 39:
          if (type !== 34 && type !== 39)
            delimiter(character);
          break;
        // (
        case 40:
          if (type === 41)
            delimiter(type);
          break;
        // \
        case 92:
          next();
          break;
      }
    return position;
  }
  function commenter(type, index) {
    while (next())
      if (type + character === 47 + 10)
        break;
      else if (type + character === 42 + 42 && peek() === 47)
        break;
    return "/*" + slice(index, position - 1) + "*" + from(type === 47 ? type : next());
  }
  function identifier(index) {
    while (!token(peek()))
      next();
    return slice(index, position);
  }
  function compile(value) {
    return dealloc(parse("", null, null, null, [""], value = alloc(value), 0, [0], value));
  }
  function parse(value, root2, parent, rule, rules, rulesets, pseudo, points, declarations) {
    var index = 0;
    var offset = 0;
    var length2 = pseudo;
    var atrule = 0;
    var property = 0;
    var previous = 0;
    var variable = 1;
    var scanning = 1;
    var ampersand = 1;
    var character2 = 0;
    var type = "";
    var props = rules;
    var children = rulesets;
    var reference = rule;
    var characters2 = type;
    while (scanning)
      switch (previous = character2, character2 = next()) {
        // (
        case 40:
          if (previous != 108 && charat(characters2, length2 - 1) == 58) {
            if (indexof(characters2 += replace(delimit(character2), "&", "&\f"), "&\f") != -1)
              ampersand = -1;
            break;
          }
        // " ' [
        case 34:
        case 39:
        case 91:
          characters2 += delimit(character2);
          break;
        // \t \n \r \s
        case 9:
        case 10:
        case 13:
        case 32:
          characters2 += whitespace(previous);
          break;
        // \
        case 92:
          characters2 += escaping(caret() - 1, 7);
          continue;
        // /
        case 47:
          switch (peek()) {
            case 42:
            case 47:
              append(comment(commenter(next(), caret()), root2, parent), declarations);
              break;
            default:
              characters2 += "/";
          }
          break;
        // {
        case 123 * variable:
          points[index++] = strlen(characters2) * ampersand;
        // } ; \0
        case 125 * variable:
        case 59:
        case 0:
          switch (character2) {
            // \0 }
            case 0:
            case 125:
              scanning = 0;
            // ;
            case 59 + offset:
              if (ampersand == -1) characters2 = replace(characters2, /\f/g, "");
              if (property > 0 && strlen(characters2) - length2)
                append(property > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1) : declaration(replace(characters2, " ", "") + ";", rule, parent, length2 - 2), declarations);
              break;
            // @ ;
            case 59:
              characters2 += ";";
            // { rule/at-rule
            default:
              append(reference = ruleset(characters2, root2, parent, index, offset, rules, points, type, props = [], children = [], length2), rulesets);
              if (character2 === 123)
                if (offset === 0)
                  parse(characters2, root2, reference, reference, props, rulesets, length2, points, children);
                else
                  switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
                    // d l m s
                    case 100:
                    case 108:
                    case 109:
                    case 115:
                      parse(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules, points, type, rules, props = [], length2), children), rules, children, length2, points, rule ? props : children);
                      break;
                    default:
                      parse(characters2, reference, reference, reference, [""], children, 0, points, children);
                  }
          }
          index = offset = property = 0, variable = ampersand = 1, type = characters2 = "", length2 = pseudo;
          break;
        // :
        case 58:
          length2 = 1 + strlen(characters2), property = previous;
        default:
          if (variable < 1) {
            if (character2 == 123)
              --variable;
            else if (character2 == 125 && variable++ == 0 && prev() == 125)
              continue;
          }
          switch (characters2 += from(character2), character2 * variable) {
            // &
            case 38:
              ampersand = offset > 0 ? 1 : (characters2 += "\f", -1);
              break;
            // ,
            case 44:
              points[index++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
              break;
            // @
            case 64:
              if (peek() === 45)
                characters2 += delimit(next());
              atrule = peek(), offset = length2 = strlen(type = characters2 += identifier(caret())), character2++;
              break;
            // -
            case 45:
              if (previous === 45 && strlen(characters2) == 2)
                variable = 0;
          }
      }
    return rulesets;
  }
  function ruleset(value, root2, parent, index, offset, rules, points, type, props, children, length2) {
    var post = offset - 1;
    var rule = offset === 0 ? rules : [""];
    var size = sizeof(rule);
    for (var i2 = 0, j = 0, k = 0; i2 < index; ++i2)
      for (var x = 0, y = substr(value, post + 1, post = abs(j = points[i2])), z = value; x < size; ++x)
        if (z = trim(j > 0 ? rule[x] + " " + y : replace(y, /&\f/g, rule[x])))
          props[k++] = z;
    return node(value, root2, parent, offset === 0 ? RULESET : type, props, children, length2);
  }
  function comment(value, root2, parent) {
    return node(value, root2, parent, COMMENT, from(char()), substr(value, 2, -2), 0);
  }
  function declaration(value, root2, parent, length2) {
    return node(value, root2, parent, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2);
  }
  function serialize(children, callback) {
    var output = "";
    var length2 = sizeof(children);
    for (var i2 = 0; i2 < length2; i2++)
      output += callback(children[i2], i2, children, callback) || "";
    return output;
  }
  function stringify(element, index, children, callback) {
    switch (element.type) {
      case LAYER:
        if (element.children.length) break;
      case IMPORT:
      case DECLARATION:
        return element.return = element.return || element.value;
      case COMMENT:
        return "";
      case KEYFRAMES:
        return element.return = element.value + "{" + serialize(element.children, callback) + "}";
      case RULESET:
        element.value = element.props.join(",");
    }
    return strlen(children = serialize(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
  }
  function middleware(collection) {
    var length2 = sizeof(collection);
    return function(element, index, children, callback) {
      var output = "";
      for (var i2 = 0; i2 < length2; i2++)
        output += collection[i2](element, index, children, callback) || "";
      return output;
    };
  }
  function rulesheet(callback) {
    return function(element) {
      if (!element.root) {
        if (element = element.return)
          callback(element);
      }
    };
  }
  function memoize(fn) {
    var cache2 = /* @__PURE__ */ Object.create(null);
    return function(arg) {
      if (cache2[arg] === void 0) cache2[arg] = fn(arg);
      return cache2[arg];
    };
  }
  var identifierWithPointTracking = function identifierWithPointTracking2(begin, points, index) {
    var previous = 0;
    var character2 = 0;
    while (true) {
      previous = character2;
      character2 = peek();
      if (previous === 38 && character2 === 12) {
        points[index] = 1;
      }
      if (token(character2)) {
        break;
      }
      next();
    }
    return slice(begin, position);
  };
  var toRules = function toRules2(parsed2, points) {
    var index = -1;
    var character2 = 44;
    do {
      switch (token(character2)) {
        case 0:
          if (character2 === 38 && peek() === 12) {
            points[index] = 1;
          }
          parsed2[index] += identifierWithPointTracking(position - 1, points, index);
          break;
        case 2:
          parsed2[index] += delimit(character2);
          break;
        case 4:
          if (character2 === 44) {
            parsed2[++index] = peek() === 58 ? "&\f" : "";
            points[index] = parsed2[index].length;
            break;
          }
        // fallthrough
        default:
          parsed2[index] += from(character2);
      }
    } while (character2 = next());
    return parsed2;
  };
  var getRules = function getRules2(value, points) {
    return dealloc(toRules(alloc(value), points));
  };
  var fixedElements = /* @__PURE__ */ new WeakMap();
  var compat = function compat2(element) {
    if (element.type !== "rule" || !element.parent || // positive .length indicates that this rule contains pseudo
    // negative .length indicates that this rule has been already prefixed
    element.length < 1) {
      return;
    }
    var value = element.value;
    var parent = element.parent;
    var isImplicitRule = element.column === parent.column && element.line === parent.line;
    while (parent.type !== "rule") {
      parent = parent.parent;
      if (!parent) return;
    }
    if (element.props.length === 1 && value.charCodeAt(0) !== 58 && !fixedElements.get(parent)) {
      return;
    }
    if (isImplicitRule) {
      return;
    }
    fixedElements.set(element, true);
    var points = [];
    var rules = getRules(value, points);
    var parentRules = parent.props;
    for (var i2 = 0, k = 0; i2 < rules.length; i2++) {
      for (var j = 0; j < parentRules.length; j++, k++) {
        element.props[k] = points[i2] ? rules[i2].replace(/&\f/g, parentRules[j]) : parentRules[j] + " " + rules[i2];
      }
    }
  };
  var removeLabel = function removeLabel2(element) {
    if (element.type === "decl") {
      var value = element.value;
      if (
        // charcode for l
        value.charCodeAt(0) === 108 && // charcode for b
        value.charCodeAt(2) === 98
      ) {
        element["return"] = "";
        element.value = "";
      }
    }
  };
  function prefix(value, length2) {
    switch (hash(value, length2)) {
      // color-adjust
      case 5103:
        return WEBKIT + "print-" + value + value;
      // animation, animation-(delay|direction|duration|fill-mode|iteration-count|name|play-state|timing-function)
      case 5737:
      case 4201:
      case 3177:
      case 3433:
      case 1641:
      case 4457:
      case 2921:
      // text-decoration, filter, clip-path, backface-visibility, column, box-decoration-break
      case 5572:
      case 6356:
      case 5844:
      case 3191:
      case 6645:
      case 3005:
      // mask, mask-image, mask-(mode|clip|size), mask-(repeat|origin), mask-position, mask-composite,
      case 6391:
      case 5879:
      case 5623:
      case 6135:
      case 4599:
      case 4855:
      // background-clip, columns, column-(count|fill|gap|rule|rule-color|rule-style|rule-width|span|width)
      case 4215:
      case 6389:
      case 5109:
      case 5365:
      case 5621:
      case 3829:
        return WEBKIT + value + value;
      // appearance, user-select, transform, hyphens, text-size-adjust
      case 5349:
      case 4246:
      case 4810:
      case 6968:
      case 2756:
        return WEBKIT + value + MOZ + value + MS + value + value;
      // flex, flex-direction
      case 6828:
      case 4268:
        return WEBKIT + value + MS + value + value;
      // order
      case 6165:
        return WEBKIT + value + MS + "flex-" + value + value;
      // align-items
      case 5187:
        return WEBKIT + value + replace(value, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + value;
      // align-self
      case 5443:
        return WEBKIT + value + MS + "flex-item-" + replace(value, /flex-|-self/, "") + value;
      // align-content
      case 4675:
        return WEBKIT + value + MS + "flex-line-pack" + replace(value, /align-content|flex-|-self/, "") + value;
      // flex-shrink
      case 5548:
        return WEBKIT + value + MS + replace(value, "shrink", "negative") + value;
      // flex-basis
      case 5292:
        return WEBKIT + value + MS + replace(value, "basis", "preferred-size") + value;
      // flex-grow
      case 6060:
        return WEBKIT + "box-" + replace(value, "-grow", "") + WEBKIT + value + MS + replace(value, "grow", "positive") + value;
      // transition
      case 4554:
        return WEBKIT + replace(value, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + value;
      // cursor
      case 6187:
        return replace(replace(replace(value, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value, "") + value;
      // background, background-image
      case 5495:
      case 3959:
        return replace(value, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
      // justify-content
      case 4968:
        return replace(replace(value, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT + value + value;
      // (margin|padding)-inline-(start|end)
      case 4095:
      case 3583:
      case 4068:
      case 2532:
        return replace(value, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value;
      // (min|max)?(width|height|inline-size|block-size)
      case 8116:
      case 7059:
      case 5753:
      case 5535:
      case 5445:
      case 5701:
      case 4933:
      case 4677:
      case 5533:
      case 5789:
      case 5021:
      case 4765:
        if (strlen(value) - 1 - length2 > 6) switch (charat(value, length2 + 1)) {
          // (m)ax-content, (m)in-content
          case 109:
            if (charat(value, length2 + 4) !== 45) break;
          // (f)ill-available, (f)it-content
          case 102:
            return replace(value, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(value, length2 + 3) == 108 ? "$3" : "$2-$3")) + value;
          // (s)tretch
          case 115:
            return ~indexof(value, "stretch") ? prefix(replace(value, "stretch", "fill-available"), length2) + value : value;
        }
        break;
      // position: sticky
      case 4949:
        if (charat(value, length2 + 1) !== 115) break;
      // display: (flex|inline-flex)
      case 6444:
        switch (charat(value, strlen(value) - 3 - (~indexof(value, "!important") && 10))) {
          // stic(k)y
          case 107:
            return replace(value, ":", ":" + WEBKIT) + value;
          // (inline-)?fl(e)x
          case 101:
            return replace(value, /(.+:)([^;!]+)(;|!.+)?/, "$1" + WEBKIT + (charat(value, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + value;
        }
        break;
      // writing-mode
      case 5936:
        switch (charat(value, length2 + 11)) {
          // vertical-l(r)
          case 114:
            return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb") + value;
          // vertical-r(l)
          case 108:
            return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb-rl") + value;
          // horizontal(-)tb
          case 45:
            return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "lr") + value;
        }
        return WEBKIT + value + MS + value + value;
    }
    return value;
  }
  var prefixer = function prefixer2(element, index, children, callback) {
    if (element.length > -1) {
      if (!element["return"]) switch (element.type) {
        case DECLARATION:
          element["return"] = prefix(element.value, element.length);
          break;
        case KEYFRAMES:
          return serialize([copy(element, {
            value: replace(element.value, "@", "@" + WEBKIT)
          })], callback);
        case RULESET:
          if (element.length) return combine(element.props, function(value) {
            switch (match(value, /(::plac\w+|:read-\w+)/)) {
              // :read-(only|write)
              case ":read-only":
              case ":read-write":
                return serialize([copy(element, {
                  props: [replace(value, /:(read-\w+)/, ":" + MOZ + "$1")]
                })], callback);
              // :placeholder
              case "::placeholder":
                return serialize([copy(element, {
                  props: [replace(value, /:(plac\w+)/, ":" + WEBKIT + "input-$1")]
                }), copy(element, {
                  props: [replace(value, /:(plac\w+)/, ":" + MOZ + "$1")]
                }), copy(element, {
                  props: [replace(value, /:(plac\w+)/, MS + "input-$1")]
                })], callback);
            }
            return "";
          });
      }
    }
  };
  var defaultStylisPlugins = [prefixer];
  var createCache = function createCache2(options) {
    var key = options.key;
    if (key === "css") {
      var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])");
      Array.prototype.forEach.call(ssrStyles, function(node2) {
        var dataEmotionAttribute = node2.getAttribute("data-emotion");
        if (dataEmotionAttribute.indexOf(" ") === -1) {
          return;
        }
        document.head.appendChild(node2);
        node2.setAttribute("data-s", "");
      });
    }
    var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;
    var inserted = {};
    var container;
    var nodesToHydrate = [];
    {
      container = options.container || document.head;
      Array.prototype.forEach.call(
        // this means we will ignore elements which don't have a space in them which
        // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
        document.querySelectorAll('style[data-emotion^="' + key + ' "]'),
        function(node2) {
          var attrib = node2.getAttribute("data-emotion").split(" ");
          for (var i2 = 1; i2 < attrib.length; i2++) {
            inserted[attrib[i2]] = true;
          }
          nodesToHydrate.push(node2);
        }
      );
    }
    var _insert;
    var omnipresentPlugins = [compat, removeLabel];
    {
      var currentSheet;
      var finalizingPlugins = [stringify, rulesheet(function(rule) {
        currentSheet.insert(rule);
      })];
      var serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));
      var stylis = function stylis2(styles) {
        return serialize(compile(styles), serializer);
      };
      _insert = function insert(selector, serialized, sheet, shouldCache) {
        currentSheet = sheet;
        stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
        if (shouldCache) {
          cache2.inserted[serialized.name] = true;
        }
      };
    }
    var cache2 = {
      key,
      sheet: new StyleSheet({
        key,
        container,
        nonce: options.nonce,
        speedy: options.speedy,
        prepend: options.prepend,
        insertionPoint: options.insertionPoint
      }),
      nonce: options.nonce,
      inserted,
      registered: {},
      insert: _insert
    };
    cache2.sheet.hydrate(nodesToHydrate);
    return cache2;
  };
  var reactIs = { exports: {} };
  var reactIs_production_min = {};
  /** @license React v16.13.1
   * react-is.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var hasRequiredReactIs_production_min;
  function requireReactIs_production_min() {
    if (hasRequiredReactIs_production_min) return reactIs_production_min;
    hasRequiredReactIs_production_min = 1;
    var b = "function" === typeof Symbol && Symbol.for, c2 = b ? Symbol.for("react.element") : 60103, d2 = b ? Symbol.for("react.portal") : 60106, e2 = b ? Symbol.for("react.fragment") : 60107, f2 = b ? Symbol.for("react.strict_mode") : 60108, g = b ? Symbol.for("react.profiler") : 60114, h = b ? Symbol.for("react.provider") : 60109, k = b ? Symbol.for("react.context") : 60110, l2 = b ? Symbol.for("react.async_mode") : 60111, m = b ? Symbol.for("react.concurrent_mode") : 60111, n2 = b ? Symbol.for("react.forward_ref") : 60112, p2 = b ? Symbol.for("react.suspense") : 60113, q = b ? Symbol.for("react.suspense_list") : 60120, r2 = b ? Symbol.for("react.memo") : 60115, t2 = b ? Symbol.for("react.lazy") : 60116, v = b ? Symbol.for("react.block") : 60121, w = b ? Symbol.for("react.fundamental") : 60117, x = b ? Symbol.for("react.responder") : 60118, y = b ? Symbol.for("react.scope") : 60119;
    function z(a2) {
      if ("object" === typeof a2 && null !== a2) {
        var u2 = a2.$$typeof;
        switch (u2) {
          case c2:
            switch (a2 = a2.type, a2) {
              case l2:
              case m:
              case e2:
              case g:
              case f2:
              case p2:
                return a2;
              default:
                switch (a2 = a2 && a2.$$typeof, a2) {
                  case k:
                  case n2:
                  case t2:
                  case r2:
                  case h:
                    return a2;
                  default:
                    return u2;
                }
            }
          case d2:
            return u2;
        }
      }
    }
    function A(a2) {
      return z(a2) === m;
    }
    reactIs_production_min.AsyncMode = l2;
    reactIs_production_min.ConcurrentMode = m;
    reactIs_production_min.ContextConsumer = k;
    reactIs_production_min.ContextProvider = h;
    reactIs_production_min.Element = c2;
    reactIs_production_min.ForwardRef = n2;
    reactIs_production_min.Fragment = e2;
    reactIs_production_min.Lazy = t2;
    reactIs_production_min.Memo = r2;
    reactIs_production_min.Portal = d2;
    reactIs_production_min.Profiler = g;
    reactIs_production_min.StrictMode = f2;
    reactIs_production_min.Suspense = p2;
    reactIs_production_min.isAsyncMode = function(a2) {
      return A(a2) || z(a2) === l2;
    };
    reactIs_production_min.isConcurrentMode = A;
    reactIs_production_min.isContextConsumer = function(a2) {
      return z(a2) === k;
    };
    reactIs_production_min.isContextProvider = function(a2) {
      return z(a2) === h;
    };
    reactIs_production_min.isElement = function(a2) {
      return "object" === typeof a2 && null !== a2 && a2.$$typeof === c2;
    };
    reactIs_production_min.isForwardRef = function(a2) {
      return z(a2) === n2;
    };
    reactIs_production_min.isFragment = function(a2) {
      return z(a2) === e2;
    };
    reactIs_production_min.isLazy = function(a2) {
      return z(a2) === t2;
    };
    reactIs_production_min.isMemo = function(a2) {
      return z(a2) === r2;
    };
    reactIs_production_min.isPortal = function(a2) {
      return z(a2) === d2;
    };
    reactIs_production_min.isProfiler = function(a2) {
      return z(a2) === g;
    };
    reactIs_production_min.isStrictMode = function(a2) {
      return z(a2) === f2;
    };
    reactIs_production_min.isSuspense = function(a2) {
      return z(a2) === p2;
    };
    reactIs_production_min.isValidElementType = function(a2) {
      return "string" === typeof a2 || "function" === typeof a2 || a2 === e2 || a2 === m || a2 === g || a2 === f2 || a2 === p2 || a2 === q || "object" === typeof a2 && null !== a2 && (a2.$$typeof === t2 || a2.$$typeof === r2 || a2.$$typeof === h || a2.$$typeof === k || a2.$$typeof === n2 || a2.$$typeof === w || a2.$$typeof === x || a2.$$typeof === y || a2.$$typeof === v);
    };
    reactIs_production_min.typeOf = z;
    return reactIs_production_min;
  }
  var hasRequiredReactIs;
  function requireReactIs() {
    if (hasRequiredReactIs) return reactIs.exports;
    hasRequiredReactIs = 1;
    {
      reactIs.exports = requireReactIs_production_min();
    }
    return reactIs.exports;
  }
  var hoistNonReactStatics_cjs;
  var hasRequiredHoistNonReactStatics_cjs;
  function requireHoistNonReactStatics_cjs() {
    if (hasRequiredHoistNonReactStatics_cjs) return hoistNonReactStatics_cjs;
    hasRequiredHoistNonReactStatics_cjs = 1;
    var reactIs2 = requireReactIs();
    var REACT_STATICS = {
      childContextTypes: true,
      contextType: true,
      contextTypes: true,
      defaultProps: true,
      displayName: true,
      getDefaultProps: true,
      getDerivedStateFromError: true,
      getDerivedStateFromProps: true,
      mixins: true,
      propTypes: true,
      type: true
    };
    var KNOWN_STATICS = {
      name: true,
      length: true,
      prototype: true,
      caller: true,
      callee: true,
      arguments: true,
      arity: true
    };
    var FORWARD_REF_STATICS = {
      "$$typeof": true,
      render: true,
      defaultProps: true,
      displayName: true,
      propTypes: true
    };
    var MEMO_STATICS = {
      "$$typeof": true,
      compare: true,
      defaultProps: true,
      displayName: true,
      propTypes: true,
      type: true
    };
    var TYPE_STATICS = {};
    TYPE_STATICS[reactIs2.ForwardRef] = FORWARD_REF_STATICS;
    TYPE_STATICS[reactIs2.Memo] = MEMO_STATICS;
    function getStatics(component) {
      if (reactIs2.isMemo(component)) {
        return MEMO_STATICS;
      }
      return TYPE_STATICS[component["$$typeof"]] || REACT_STATICS;
    }
    var defineProperty = Object.defineProperty;
    var getOwnPropertyNames = Object.getOwnPropertyNames;
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var getPrototypeOf = Object.getPrototypeOf;
    var objectPrototype = Object.prototype;
    function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
      if (typeof sourceComponent !== "string") {
        if (objectPrototype) {
          var inheritedComponent = getPrototypeOf(sourceComponent);
          if (inheritedComponent && inheritedComponent !== objectPrototype) {
            hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
          }
        }
        var keys = getOwnPropertyNames(sourceComponent);
        if (getOwnPropertySymbols) {
          keys = keys.concat(getOwnPropertySymbols(sourceComponent));
        }
        var targetStatics = getStatics(targetComponent);
        var sourceStatics = getStatics(sourceComponent);
        for (var i2 = 0; i2 < keys.length; ++i2) {
          var key = keys[i2];
          if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
            var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
            try {
              defineProperty(targetComponent, key, descriptor);
            } catch (e2) {
            }
          }
        }
      }
      return targetComponent;
    }
    hoistNonReactStatics_cjs = hoistNonReactStatics;
    return hoistNonReactStatics_cjs;
  }
  requireHoistNonReactStatics_cjs();
  var isBrowser$1 = true;
  function getRegisteredStyles(registered, registeredStyles, classNames) {
    var rawClassName = "";
    classNames.split(" ").forEach(function(className) {
      if (registered[className] !== void 0) {
        registeredStyles.push(registered[className] + ";");
      } else if (className) {
        rawClassName += className + " ";
      }
    });
    return rawClassName;
  }
  var registerStyles = function registerStyles2(cache2, serialized, isStringTag) {
    var className = cache2.key + "-" + serialized.name;
    if (
      // we only need to add the styles to the registered cache if the
      // class name could be used further down
      // the tree but if it's a string tag, we know it won't
      // so we don't have to add it to registered cache.
      // this improves memory usage since we can avoid storing the whole style string
      (isStringTag === false || // we need to always store it if we're in compat mode and
      // in node since emotion-server relies on whether a style is in
      // the registered cache to know whether a style is global or not
      // also, note that this check will be dead code eliminated in the browser
      isBrowser$1 === false) && cache2.registered[className] === void 0
    ) {
      cache2.registered[className] = serialized.styles;
    }
  };
  var insertStyles = function insertStyles2(cache2, serialized, isStringTag) {
    registerStyles(cache2, serialized, isStringTag);
    var className = cache2.key + "-" + serialized.name;
    if (cache2.inserted[serialized.name] === void 0) {
      var current = serialized;
      do {
        cache2.insert(serialized === current ? "." + className : "", current, cache2.sheet, true);
        current = current.next;
      } while (current !== void 0);
    }
  };
  function murmur2(str) {
    var h = 0;
    var k, i2 = 0, len = str.length;
    for (; len >= 4; ++i2, len -= 4) {
      k = str.charCodeAt(i2) & 255 | (str.charCodeAt(++i2) & 255) << 8 | (str.charCodeAt(++i2) & 255) << 16 | (str.charCodeAt(++i2) & 255) << 24;
      k = /* Math.imul(k, m): */
      (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16);
      k ^= /* k >>> r: */
      k >>> 24;
      h = /* Math.imul(k, m): */
      (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
      (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
    }
    switch (len) {
      case 3:
        h ^= (str.charCodeAt(i2 + 2) & 255) << 16;
      case 2:
        h ^= (str.charCodeAt(i2 + 1) & 255) << 8;
      case 1:
        h ^= str.charCodeAt(i2) & 255;
        h = /* Math.imul(h, m): */
        (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
    }
    h ^= h >>> 13;
    h = /* Math.imul(h, m): */
    (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
    return ((h ^ h >>> 15) >>> 0).toString(36);
  }
  var unitlessKeys = {
    animationIterationCount: 1,
    aspectRatio: 1,
    borderImageOutset: 1,
    borderImageSlice: 1,
    borderImageWidth: 1,
    boxFlex: 1,
    boxFlexGroup: 1,
    boxOrdinalGroup: 1,
    columnCount: 1,
    columns: 1,
    flex: 1,
    flexGrow: 1,
    flexPositive: 1,
    flexShrink: 1,
    flexNegative: 1,
    flexOrder: 1,
    gridRow: 1,
    gridRowEnd: 1,
    gridRowSpan: 1,
    gridRowStart: 1,
    gridColumn: 1,
    gridColumnEnd: 1,
    gridColumnSpan: 1,
    gridColumnStart: 1,
    msGridRow: 1,
    msGridRowSpan: 1,
    msGridColumn: 1,
    msGridColumnSpan: 1,
    fontWeight: 1,
    lineHeight: 1,
    opacity: 1,
    order: 1,
    orphans: 1,
    scale: 1,
    tabSize: 1,
    widows: 1,
    zIndex: 1,
    zoom: 1,
    WebkitLineClamp: 1,
    // SVG-related properties
    fillOpacity: 1,
    floodOpacity: 1,
    stopOpacity: 1,
    strokeDasharray: 1,
    strokeDashoffset: 1,
    strokeMiterlimit: 1,
    strokeOpacity: 1,
    strokeWidth: 1
  };
  var hyphenateRegex = /[A-Z]|^ms/g;
  var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
  var isCustomProperty = function isCustomProperty2(property) {
    return property.charCodeAt(1) === 45;
  };
  var isProcessableValue = function isProcessableValue2(value) {
    return value != null && typeof value !== "boolean";
  };
  var processStyleName = /* @__PURE__ */ memoize(function(styleName) {
    return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, "-$&").toLowerCase();
  });
  var processStyleValue = function processStyleValue2(key, value) {
    switch (key) {
      case "animation":
      case "animationName": {
        if (typeof value === "string") {
          return value.replace(animationRegex, function(match2, p1, p2) {
            cursor = {
              name: p1,
              styles: p2,
              next: cursor
            };
            return p1;
          });
        }
      }
    }
    if (unitlessKeys[key] !== 1 && !isCustomProperty(key) && typeof value === "number" && value !== 0) {
      return value + "px";
    }
    return value;
  };
  function handleInterpolation(mergedProps, registered, interpolation) {
    if (interpolation == null) {
      return "";
    }
    var componentSelector = interpolation;
    if (componentSelector.__emotion_styles !== void 0) {
      return componentSelector;
    }
    switch (typeof interpolation) {
      case "boolean": {
        return "";
      }
      case "object": {
        var keyframes = interpolation;
        if (keyframes.anim === 1) {
          cursor = {
            name: keyframes.name,
            styles: keyframes.styles,
            next: cursor
          };
          return keyframes.name;
        }
        var serializedStyles = interpolation;
        if (serializedStyles.styles !== void 0) {
          var next2 = serializedStyles.next;
          if (next2 !== void 0) {
            while (next2 !== void 0) {
              cursor = {
                name: next2.name,
                styles: next2.styles,
                next: cursor
              };
              next2 = next2.next;
            }
          }
          var styles = serializedStyles.styles + ";";
          return styles;
        }
        return createStringFromObject(mergedProps, registered, interpolation);
      }
      case "function": {
        if (mergedProps !== void 0) {
          var previousCursor = cursor;
          var result = interpolation(mergedProps);
          cursor = previousCursor;
          return handleInterpolation(mergedProps, registered, result);
        }
        break;
      }
    }
    var asString = interpolation;
    if (registered == null) {
      return asString;
    }
    var cached = registered[asString];
    return cached !== void 0 ? cached : asString;
  }
  function createStringFromObject(mergedProps, registered, obj) {
    var string = "";
    if (Array.isArray(obj)) {
      for (var i2 = 0; i2 < obj.length; i2++) {
        string += handleInterpolation(mergedProps, registered, obj[i2]) + ";";
      }
    } else {
      for (var key in obj) {
        var value = obj[key];
        if (typeof value !== "object") {
          var asString = value;
          if (registered != null && registered[asString] !== void 0) {
            string += key + "{" + registered[asString] + "}";
          } else if (isProcessableValue(asString)) {
            string += processStyleName(key) + ":" + processStyleValue(key, asString) + ";";
          }
        } else {
          if (Array.isArray(value) && typeof value[0] === "string" && (registered == null || registered[value[0]] === void 0)) {
            for (var _i = 0; _i < value.length; _i++) {
              if (isProcessableValue(value[_i])) {
                string += processStyleName(key) + ":" + processStyleValue(key, value[_i]) + ";";
              }
            }
          } else {
            var interpolated = handleInterpolation(mergedProps, registered, value);
            switch (key) {
              case "animation":
              case "animationName": {
                string += processStyleName(key) + ":" + interpolated + ";";
                break;
              }
              default: {
                string += key + "{" + interpolated + "}";
              }
            }
          }
        }
      }
    }
    return string;
  }
  var labelPattern = /label:\s*([^\s;{]+)\s*(;|$)/g;
  var cursor;
  function serializeStyles(args, registered, mergedProps) {
    if (args.length === 1 && typeof args[0] === "object" && args[0] !== null && args[0].styles !== void 0) {
      return args[0];
    }
    var stringMode = true;
    var styles = "";
    cursor = void 0;
    var strings = args[0];
    if (strings == null || strings.raw === void 0) {
      stringMode = false;
      styles += handleInterpolation(mergedProps, registered, strings);
    } else {
      var asTemplateStringsArr = strings;
      styles += asTemplateStringsArr[0];
    }
    for (var i2 = 1; i2 < args.length; i2++) {
      styles += handleInterpolation(mergedProps, registered, args[i2]);
      if (stringMode) {
        var templateStringsArr = strings;
        styles += templateStringsArr[i2];
      }
    }
    labelPattern.lastIndex = 0;
    var identifierName = "";
    var match2;
    while ((match2 = labelPattern.exec(styles)) !== null) {
      identifierName += "-" + match2[1];
    }
    var name = murmur2(styles) + identifierName;
    return {
      name,
      styles,
      next: cursor
    };
  }
  var syncFallback = function syncFallback2(create) {
    return create();
  };
  var useInsertionEffect = H__namespace["useInsertionEffect"] ? H__namespace["useInsertionEffect"] : false;
  var useInsertionEffectAlwaysWithSyncFallback = useInsertionEffect || syncFallback;
  var useInsertionEffectWithLayoutFallback = useInsertionEffect || H__namespace.useLayoutEffect;
  var EmotionCacheContext = /* @__PURE__ */ H__namespace.createContext(
    // we're doing this to avoid preconstruct's dead code elimination in this one case
    // because this module is primarily intended for the browser and node
    // but it's also required in react native and similar environments sometimes
    // and we could have a special build just for that
    // but this is much easier and the native packages
    // might use a different theme context in the future anyway
    typeof HTMLElement !== "undefined" ? /* @__PURE__ */ createCache({
      key: "css"
    }) : null
  );
  var CacheProvider = EmotionCacheContext.Provider;
  var withEmotionCache = function withEmotionCache2(func) {
    return /* @__PURE__ */ H.forwardRef(function(props, ref) {
      var cache2 = H.useContext(EmotionCacheContext);
      return func(props, cache2, ref);
    });
  };
  var ThemeContext = /* @__PURE__ */ H__namespace.createContext({});
  var hasOwn = {}.hasOwnProperty;
  var typePropName = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__";
  var createEmotionProps = function createEmotionProps2(type, props) {
    var newProps = {};
    for (var _key in props) {
      if (hasOwn.call(props, _key)) {
        newProps[_key] = props[_key];
      }
    }
    newProps[typePropName] = type;
    return newProps;
  };
  var Insertion = function Insertion2(_ref7) {
    var cache2 = _ref7.cache, serialized = _ref7.serialized, isStringTag = _ref7.isStringTag;
    registerStyles(cache2, serialized, isStringTag);
    useInsertionEffectAlwaysWithSyncFallback(function() {
      return insertStyles(cache2, serialized, isStringTag);
    });
    return null;
  };
  var Emotion = /* @__PURE__ */ withEmotionCache(function(props, cache2, ref) {
    var cssProp = props.css;
    if (typeof cssProp === "string" && cache2.registered[cssProp] !== void 0) {
      cssProp = cache2.registered[cssProp];
    }
    var WrappedComponent = props[typePropName];
    var registeredStyles = [cssProp];
    var className = "";
    if (typeof props.className === "string") {
      className = getRegisteredStyles(cache2.registered, registeredStyles, props.className);
    } else if (props.className != null) {
      className = props.className + " ";
    }
    var serialized = serializeStyles(registeredStyles, void 0, H__namespace.useContext(ThemeContext));
    className += cache2.key + "-" + serialized.name;
    var newProps = {};
    for (var _key2 in props) {
      if (hasOwn.call(props, _key2) && _key2 !== "css" && _key2 !== typePropName && true) {
        newProps[_key2] = props[_key2];
      }
    }
    newProps.className = className;
    if (ref) {
      newProps.ref = ref;
    }
    return /* @__PURE__ */ H__namespace.createElement(H__namespace.Fragment, null, /* @__PURE__ */ H__namespace.createElement(Insertion, {
      cache: cache2,
      serialized,
      isStringTag: typeof WrappedComponent === "string"
    }), /* @__PURE__ */ H__namespace.createElement(WrappedComponent, newProps));
  });
  var Emotion$1 = Emotion;
  var Fragment = jsxRuntimeExports.Fragment;
  var jsx$1 = function jsx(type, props, key) {
    if (!hasOwn.call(props, "css")) {
      return jsxRuntimeExports.jsx(type, props, key);
    }
    return jsxRuntimeExports.jsx(Emotion$1, createEmotionProps(type, props), key);
  };
  var jsxs = function jsxs2(type, props, key) {
    if (!hasOwn.call(props, "css")) {
      return jsxRuntimeExports.jsxs(type, props, key);
    }
    return jsxRuntimeExports.jsxs(Emotion$1, createEmotionProps(type, props), key);
  };
  function minmax(value, min, max) {
    if (value < min) {
      return min;
    } else if (value > max) {
      return max;
    } else {
      return value;
    }
  }
  const parsed = UAParser();
  const isMac = ((_a = parsed.os.name) == null ? void 0 : _a.toLowerCase()) === "mac os";
  const parsedBrowserName = parsed.browser.name || "";
  const isBrand = (brand) => new RegExp(String.raw`\b${brand}\b`, "i").test(parsedBrowserName);
  const isSafari = isBrand("safari");
  const isFirefox = isBrand("firefox");
  isBrand("edge");
  class Node {
    constructor(value) {
      __publicField(this, "value");
      __publicField(this, "next");
      this.value = value;
    }
  }
  class Queue {
    constructor() {
      __privateAdd(this, _head);
      __privateAdd(this, _tail);
      __privateAdd(this, _size);
      this.clear();
    }
    enqueue(value) {
      const node2 = new Node(value);
      if (__privateGet(this, _head)) {
        __privateGet(this, _tail).next = node2;
        __privateSet(this, _tail, node2);
      } else {
        __privateSet(this, _head, node2);
        __privateSet(this, _tail, node2);
      }
      __privateWrapper(this, _size)._++;
    }
    dequeue() {
      const current = __privateGet(this, _head);
      if (!current) {
        return;
      }
      __privateSet(this, _head, __privateGet(this, _head).next);
      __privateWrapper(this, _size)._--;
      return current.value;
    }
    peek() {
      if (!__privateGet(this, _head)) {
        return;
      }
      return __privateGet(this, _head).value;
    }
    clear() {
      __privateSet(this, _head, void 0);
      __privateSet(this, _tail, void 0);
      __privateSet(this, _size, 0);
    }
    get size() {
      return __privateGet(this, _size);
    }
    *[Symbol.iterator]() {
      let current = __privateGet(this, _head);
      while (current) {
        yield current.value;
        current = current.next;
      }
    }
  }
  _head = new WeakMap();
  _tail = new WeakMap();
  _size = new WeakMap();
  function pLimit(concurrency) {
    validateConcurrency(concurrency);
    const queue = new Queue();
    let activeCount = 0;
    const resumeNext = () => {
      if (activeCount < concurrency && queue.size > 0) {
        queue.dequeue()();
        activeCount++;
      }
    };
    const next2 = () => {
      activeCount--;
      resumeNext();
    };
    const run = async (function_, resolve, arguments_) => {
      const result = (async () => function_(...arguments_))();
      resolve(result);
      try {
        await result;
      } catch {
      }
      next2();
    };
    const enqueue = (function_, resolve, arguments_) => {
      new Promise((internalResolve) => {
        queue.enqueue(internalResolve);
      }).then(
        run.bind(void 0, function_, resolve, arguments_)
      );
      (async () => {
        await Promise.resolve();
        if (activeCount < concurrency) {
          resumeNext();
        }
      })();
    };
    const generator = (function_, ...arguments_) => new Promise((resolve) => {
      enqueue(function_, resolve, arguments_);
    });
    Object.defineProperties(generator, {
      activeCount: {
        get: () => activeCount
      },
      pendingCount: {
        get: () => queue.size
      },
      clearQueue: {
        value() {
          queue.clear();
        }
      },
      concurrency: {
        get: () => concurrency,
        set(newConcurrency) {
          validateConcurrency(newConcurrency);
          concurrency = newConcurrency;
          queueMicrotask(() => {
            while (activeCount < concurrency && queue.size > 0) {
              resumeNext();
            }
          });
        }
      }
    });
    return generator;
  }
  function limitFunction(function_, option) {
    const { concurrency } = option;
    const limit2 = pLimit(concurrency);
    return (...arguments_) => limit2(() => function_(...arguments_));
  }
  function validateConcurrency(concurrency) {
    if (!((Number.isInteger(concurrency) || concurrency === Number.POSITIVE_INFINITY) && concurrency > 0)) {
      throw new TypeError("Expected `concurrency` to be a number from 1 and up");
    }
  }
  function openNewTab(url, active = true) {
    if (url.startsWith("/")) url = location.origin + url;
    if (isSafari) {
      GM.openInTab(url, !active);
    } else {
      GM.openInTab(url, {
        active,
        insert: true,
        setParent: true
      });
    }
  }
  function reciveGmValueUpdatesFromOtherTab({
    storageKey: storageKey2,
    onUpdate,
    setPersist
  }) {
    if (typeof GM_addValueChangeListener === "undefined") return;
    const limit2 = pLimit(1);
    GM_addValueChangeListener(storageKey2, (name, oldValue, newValue, remote) => {
      if (!remote) return;
      if (!newValue) return;
      limit2(async () => {
        setPersist(false);
        try {
          onUpdate(newValue);
        } finally {
          await Promise.resolve().then(() => {
            setPersist(true);
          });
        }
      });
    });
  }
  const TRACK_MEMO_SYMBOL = Symbol();
  const GET_ORIGINAL_SYMBOL = Symbol();
  const AFFECTED_PROPERTY = "a";
  const IS_TARGET_COPIED_PROPERTY = "f";
  const PROXY_PROPERTY = "p";
  const PROXY_CACHE_PROPERTY = "c";
  const TARGET_CACHE_PROPERTY = "t";
  const HAS_KEY_PROPERTY = "h";
  const ALL_OWN_KEYS_PROPERTY = "w";
  const HAS_OWN_KEY_PROPERTY = "o";
  const KEYS_PROPERTY = "k";
  let newProxy$1 = (target, handler) => new Proxy(target, handler);
  const getProto = Object.getPrototypeOf;
  const objectsToTrack = /* @__PURE__ */ new WeakMap();
  const isObjectToTrack = (obj) => obj && (objectsToTrack.has(obj) ? objectsToTrack.get(obj) : getProto(obj) === Object.prototype || getProto(obj) === Array.prototype);
  const isObject$2 = (x) => typeof x === "object" && x !== null;
  const needsToCopyTargetObject = (obj) => Object.values(Object.getOwnPropertyDescriptors(obj)).some((descriptor) => !descriptor.configurable && !descriptor.writable);
  const copyTargetObject = (obj) => {
    if (Array.isArray(obj)) {
      return Array.from(obj);
    }
    const descriptors2 = Object.getOwnPropertyDescriptors(obj);
    Object.values(descriptors2).forEach((desc) => {
      desc.configurable = true;
    });
    return Object.create(getProto(obj), descriptors2);
  };
  const createProxyHandler = (origObj, isTargetCopied) => {
    const state2 = {
      [IS_TARGET_COPIED_PROPERTY]: isTargetCopied
    };
    let trackObject = false;
    const recordUsage = (type, key) => {
      if (!trackObject) {
        let used = state2[AFFECTED_PROPERTY].get(origObj);
        if (!used) {
          used = {};
          state2[AFFECTED_PROPERTY].set(origObj, used);
        }
        if (type === ALL_OWN_KEYS_PROPERTY) {
          used[ALL_OWN_KEYS_PROPERTY] = true;
        } else {
          let set2 = used[type];
          if (!set2) {
            set2 = /* @__PURE__ */ new Set();
            used[type] = set2;
          }
          set2.add(key);
        }
      }
    };
    const recordObjectAsUsed = () => {
      trackObject = true;
      state2[AFFECTED_PROPERTY].delete(origObj);
    };
    const handler = {
      get(target, key) {
        if (key === GET_ORIGINAL_SYMBOL) {
          return origObj;
        }
        recordUsage(KEYS_PROPERTY, key);
        return createProxy(Reflect.get(target, key), state2[AFFECTED_PROPERTY], state2[PROXY_CACHE_PROPERTY], state2[TARGET_CACHE_PROPERTY]);
      },
      has(target, key) {
        if (key === TRACK_MEMO_SYMBOL) {
          recordObjectAsUsed();
          return true;
        }
        recordUsage(HAS_KEY_PROPERTY, key);
        return Reflect.has(target, key);
      },
      getOwnPropertyDescriptor(target, key) {
        recordUsage(HAS_OWN_KEY_PROPERTY, key);
        return Reflect.getOwnPropertyDescriptor(target, key);
      },
      ownKeys(target) {
        recordUsage(ALL_OWN_KEYS_PROPERTY);
        return Reflect.ownKeys(target);
      }
    };
    if (isTargetCopied) {
      handler.set = handler.deleteProperty = () => false;
    }
    return [handler, state2];
  };
  const getOriginalObject = (obj) => (
    // unwrap proxy
    obj[GET_ORIGINAL_SYMBOL] || // otherwise
    obj
  );
  const createProxy = (obj, affected, proxyCache2, targetCache2) => {
    if (!isObjectToTrack(obj))
      return obj;
    let targetAndCopied = targetCache2 && targetCache2.get(obj);
    if (!targetAndCopied) {
      const target2 = getOriginalObject(obj);
      if (needsToCopyTargetObject(target2)) {
        targetAndCopied = [target2, copyTargetObject(target2)];
      } else {
        targetAndCopied = [target2];
      }
      targetCache2 === null || targetCache2 === void 0 ? void 0 : targetCache2.set(obj, targetAndCopied);
    }
    const [target, copiedTarget] = targetAndCopied;
    let handlerAndState = proxyCache2 && proxyCache2.get(target);
    if (!handlerAndState || handlerAndState[1][IS_TARGET_COPIED_PROPERTY] !== !!copiedTarget) {
      handlerAndState = createProxyHandler(target, !!copiedTarget);
      handlerAndState[1][PROXY_PROPERTY] = newProxy$1(copiedTarget || target, handlerAndState[0]);
      if (proxyCache2) {
        proxyCache2.set(target, handlerAndState);
      }
    }
    handlerAndState[1][AFFECTED_PROPERTY] = affected;
    handlerAndState[1][PROXY_CACHE_PROPERTY] = proxyCache2;
    handlerAndState[1][TARGET_CACHE_PROPERTY] = targetCache2;
    return handlerAndState[1][PROXY_PROPERTY];
  };
  const isAllOwnKeysChanged = (prevObj, nextObj) => {
    const prevKeys = Reflect.ownKeys(prevObj);
    const nextKeys = Reflect.ownKeys(nextObj);
    return prevKeys.length !== nextKeys.length || prevKeys.some((k, i2) => k !== nextKeys[i2]);
  };
  const isChanged = (prevObj, nextObj, affected, cache2, isEqual2 = Object.is) => {
    if (isEqual2(prevObj, nextObj)) {
      return false;
    }
    if (!isObject$2(prevObj) || !isObject$2(nextObj))
      return true;
    const used = affected.get(getOriginalObject(prevObj));
    if (!used)
      return true;
    if (cache2) {
      const hit = cache2.get(prevObj);
      if (hit === nextObj) {
        return false;
      }
      cache2.set(prevObj, nextObj);
    }
    let changed = null;
    for (const key of used[HAS_KEY_PROPERTY] || []) {
      changed = Reflect.has(prevObj, key) !== Reflect.has(nextObj, key);
      if (changed)
        return changed;
    }
    if (used[ALL_OWN_KEYS_PROPERTY] === true) {
      changed = isAllOwnKeysChanged(prevObj, nextObj);
      if (changed)
        return changed;
    } else {
      for (const key of used[HAS_OWN_KEY_PROPERTY] || []) {
        const hasPrev = !!Reflect.getOwnPropertyDescriptor(prevObj, key);
        const hasNext = !!Reflect.getOwnPropertyDescriptor(nextObj, key);
        changed = hasPrev !== hasNext;
        if (changed)
          return changed;
      }
    }
    for (const key of used[KEYS_PROPERTY] || []) {
      changed = isChanged(prevObj[key], nextObj[key], affected, cache2, isEqual2);
      if (changed)
        return changed;
    }
    if (changed === null)
      throw new Error("invalid used");
    return changed;
  };
  const getUntracked = (obj) => {
    if (isObjectToTrack(obj)) {
      return obj[GET_ORIGINAL_SYMBOL] || null;
    }
    return null;
  };
  const markToTrack = (obj, mark = true) => {
    objectsToTrack.set(obj, mark);
  };
  const affectedToPathList = (obj, affected, onlyWithValues) => {
    const list2 = [];
    const seen = /* @__PURE__ */ new WeakSet();
    const walk = (x, path2) => {
      var _a2, _b2, _c2;
      if (seen.has(x)) {
        return;
      }
      if (isObject$2(x)) {
        seen.add(x);
      }
      const used = isObject$2(x) && affected.get(getOriginalObject(x));
      if (used) {
        (_a2 = used[HAS_KEY_PROPERTY]) === null || _a2 === void 0 ? void 0 : _a2.forEach((key) => {
          const segment = `:has(${String(key)})`;
          list2.push(path2 ? [...path2, segment] : [segment]);
        });
        if (used[ALL_OWN_KEYS_PROPERTY] === true) {
          const segment = ":ownKeys";
          list2.push(path2 ? [...path2, segment] : [segment]);
        } else {
          (_b2 = used[HAS_OWN_KEY_PROPERTY]) === null || _b2 === void 0 ? void 0 : _b2.forEach((key) => {
            const segment = `:hasOwn(${String(key)})`;
            list2.push(path2 ? [...path2, segment] : [segment]);
          });
        }
        (_c2 = used[KEYS_PROPERTY]) === null || _c2 === void 0 ? void 0 : _c2.forEach((key) => {
          if ("value" in (Object.getOwnPropertyDescriptor(x, key) || {})) {
            walk(x[key], path2 ? [...path2, key] : [key]);
          }
        });
      } else if (path2) {
        list2.push(path2);
      }
    };
    walk(obj);
    return list2;
  };
  const __vite_import_meta_env__$1 = {};
  const isObject$1 = (x) => typeof x === "object" && x !== null;
  const canProxyDefault = (x) => isObject$1(x) && !refSet.has(x) && (Array.isArray(x) || !(Symbol.iterator in x)) && !(x instanceof WeakMap) && !(x instanceof WeakSet) && !(x instanceof Error) && !(x instanceof Number) && !(x instanceof Date) && !(x instanceof String) && !(x instanceof RegExp) && !(x instanceof ArrayBuffer) && !(x instanceof Promise);
  const createSnapshotDefault = (target, version) => {
    const cache2 = snapCache$2.get(target);
    if ((cache2 == null ? void 0 : cache2[0]) === version) {
      return cache2[1];
    }
    const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));
    markToTrack(snap, true);
    snapCache$2.set(target, [version, snap]);
    Reflect.ownKeys(target).forEach((key) => {
      if (Object.getOwnPropertyDescriptor(snap, key)) {
        return;
      }
      const value = Reflect.get(target, key);
      const { enumerable } = Reflect.getOwnPropertyDescriptor(
        target,
        key
      );
      const desc = {
        value,
        enumerable,
        // This is intentional to avoid copying with proxy-compare.
        // It's still non-writable, so it avoids assigning a value.
        configurable: true
      };
      if (refSet.has(value)) {
        markToTrack(value, false);
      } else if (proxyStateMap$2.has(value)) {
        const [target2, ensureVersion] = proxyStateMap$2.get(
          value
        );
        desc.value = createSnapshotDefault(target2, ensureVersion());
      }
      Object.defineProperty(snap, key, desc);
    });
    return Object.preventExtensions(snap);
  };
  const createHandlerDefault = (isInitializing, addPropListener, removePropListener, notifyUpdate) => ({
    deleteProperty(target, prop) {
      const prevValue = Reflect.get(target, prop);
      removePropListener(prop);
      const deleted = Reflect.deleteProperty(target, prop);
      if (deleted) {
        notifyUpdate(["delete", [prop], prevValue]);
      }
      return deleted;
    },
    set(target, prop, value, receiver) {
      const hasPrevValue = !isInitializing() && Reflect.has(target, prop);
      const prevValue = Reflect.get(target, prop, receiver);
      if (hasPrevValue && (objectIs(prevValue, value) || proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value)))) {
        return true;
      }
      removePropListener(prop);
      if (isObject$1(value)) {
        value = getUntracked(value) || value;
      }
      const nextValue = !proxyStateMap$2.has(value) && canProxy(value) ? proxy(value) : value;
      addPropListener(prop, nextValue);
      Reflect.set(target, prop, nextValue, receiver);
      notifyUpdate(["set", [prop], value, prevValue]);
      return true;
    }
  });
  const proxyStateMap$2 = /* @__PURE__ */ new WeakMap();
  const refSet = /* @__PURE__ */ new WeakSet();
  const snapCache$2 = /* @__PURE__ */ new WeakMap();
  const versionHolder = [1, 1];
  const proxyCache = /* @__PURE__ */ new WeakMap();
  let objectIs = Object.is;
  let newProxy = (target, handler) => new Proxy(target, handler);
  let canProxy = canProxyDefault;
  let createSnapshot = createSnapshotDefault;
  let createHandler = createHandlerDefault;
  function proxy(baseObject = {}) {
    if (!isObject$1(baseObject)) {
      throw new Error("object required");
    }
    const found = proxyCache.get(baseObject);
    if (found) {
      return found;
    }
    let version = versionHolder[0];
    const listeners2 = /* @__PURE__ */ new Set();
    const notifyUpdate = (op, nextVersion = ++versionHolder[0]) => {
      if (version !== nextVersion) {
        version = nextVersion;
        listeners2.forEach((listener) => listener(op, nextVersion));
      }
    };
    let checkVersion = versionHolder[1];
    const ensureVersion = (nextCheckVersion = ++versionHolder[1]) => {
      if (checkVersion !== nextCheckVersion && !listeners2.size) {
        checkVersion = nextCheckVersion;
        propProxyStates.forEach(([propProxyState]) => {
          const propVersion = propProxyState[1](nextCheckVersion);
          if (propVersion > version) {
            version = propVersion;
          }
        });
      }
      return version;
    };
    const createPropListener = (prop) => (op, nextVersion) => {
      const newOp = [...op];
      newOp[1] = [prop, ...newOp[1]];
      notifyUpdate(newOp, nextVersion);
    };
    const propProxyStates = /* @__PURE__ */ new Map();
    const addPropListener = (prop, propValue) => {
      const propProxyState = !refSet.has(propValue) && proxyStateMap$2.get(propValue);
      if (propProxyState) {
        if ((__vite_import_meta_env__$1 ? "production" : void 0) !== "production" && propProxyStates.has(prop)) {
          throw new Error("prop listener already exists");
        }
        if (listeners2.size) {
          const remove = propProxyState[2](createPropListener(prop));
          propProxyStates.set(prop, [propProxyState, remove]);
        } else {
          propProxyStates.set(prop, [propProxyState]);
        }
      }
    };
    const removePropListener = (prop) => {
      var _a2;
      const entry = propProxyStates.get(prop);
      if (entry) {
        propProxyStates.delete(prop);
        (_a2 = entry[1]) == null ? void 0 : _a2.call(entry);
      }
    };
    const addListener = (listener) => {
      listeners2.add(listener);
      if (listeners2.size === 1) {
        propProxyStates.forEach(([propProxyState, prevRemove], prop) => {
          if ((__vite_import_meta_env__$1 ? "production" : void 0) !== "production" && prevRemove) {
            throw new Error("remove already exists");
          }
          const remove = propProxyState[2](createPropListener(prop));
          propProxyStates.set(prop, [propProxyState, remove]);
        });
      }
      const removeListener = () => {
        listeners2.delete(listener);
        if (listeners2.size === 0) {
          propProxyStates.forEach(([propProxyState, remove], prop) => {
            if (remove) {
              remove();
              propProxyStates.set(prop, [propProxyState]);
            }
          });
        }
      };
      return removeListener;
    };
    let initializing = true;
    const handler = createHandler(
      () => initializing,
      addPropListener,
      removePropListener,
      notifyUpdate
    );
    const proxyObject = newProxy(baseObject, handler);
    proxyCache.set(baseObject, proxyObject);
    const proxyState = [baseObject, ensureVersion, addListener];
    proxyStateMap$2.set(proxyObject, proxyState);
    Reflect.ownKeys(baseObject).forEach((key) => {
      const desc = Object.getOwnPropertyDescriptor(
        baseObject,
        key
      );
      if ("value" in desc && desc.writable) {
        proxyObject[key] = baseObject[key];
      }
    });
    initializing = false;
    return proxyObject;
  }
  function subscribe$3(proxyObject, callback, notifyInSync) {
    const proxyState = proxyStateMap$2.get(proxyObject);
    if ((__vite_import_meta_env__$1 ? "production" : void 0) !== "production" && !proxyState) {
      console.warn("Please use proxy object");
    }
    let promise;
    const ops = [];
    const addListener = proxyState[2];
    let isListenerActive = false;
    const listener = (op) => {
      ops.push(op);
      if (notifyInSync) {
        callback(ops.splice(0));
        return;
      }
      if (!promise) {
        promise = Promise.resolve().then(() => {
          promise = void 0;
          if (isListenerActive) {
            callback(ops.splice(0));
          }
        });
      }
    };
    const removeListener = addListener(listener);
    isListenerActive = true;
    return () => {
      isListenerActive = false;
      removeListener();
    };
  }
  function snapshot(proxyObject) {
    const proxyState = proxyStateMap$2.get(proxyObject);
    if ((__vite_import_meta_env__$1 ? "production" : void 0) !== "production" && !proxyState) {
      console.warn("Please use proxy object");
    }
    const [target, ensureVersion] = proxyState;
    return createSnapshot(target, ensureVersion());
  }
  function unstable_getInternalStates() {
    return {
      proxyStateMap: proxyStateMap$2,
      refSet,
      snapCache: snapCache$2,
      versionHolder,
      proxyCache
    };
  }
  const __vite_import_meta_env__ = {};
  const useAffectedDebugValue = (state2, affected) => {
    const pathList = H.useRef(void 0);
    H.useEffect(() => {
      pathList.current = affectedToPathList(state2, affected);
    });
    H.useDebugValue(pathList.current);
  };
  const condUseAffectedDebugValue = useAffectedDebugValue;
  const targetCache = /* @__PURE__ */ new WeakMap();
  function useSnapshot(proxyObject, options) {
    const notifyInSync = options == null ? void 0 : options.sync;
    const affected = H.useMemo(
      () => proxyObject && /* @__PURE__ */ new WeakMap(),
      [proxyObject]
    );
    const lastSnapshot = H.useRef(void 0);
    let inRender = true;
    const currSnapshot = H.useSyncExternalStore(
      H.useCallback(
        (callback) => {
          const unsub = subscribe$3(proxyObject, callback, notifyInSync);
          callback();
          return unsub;
        },
        [proxyObject, notifyInSync]
      ),
      () => {
        const nextSnapshot = snapshot(proxyObject);
        try {
          if (!inRender && lastSnapshot.current && !isChanged(
            lastSnapshot.current,
            nextSnapshot,
            affected,
            /* @__PURE__ */ new WeakMap()
          )) {
            return lastSnapshot.current;
          }
        } catch (e2) {
        }
        return nextSnapshot;
      },
      () => snapshot(proxyObject)
    );
    inRender = false;
    H.useLayoutEffect(() => {
      lastSnapshot.current = currSnapshot;
    });
    if ((__vite_import_meta_env__ ? "production" : void 0) !== "production") {
      condUseAffectedDebugValue(currSnapshot, affected);
    }
    const proxyCache2 = H.useMemo(() => /* @__PURE__ */ new WeakMap(), []);
    return createProxy(currSnapshot, affected, proxyCache2, targetCache);
  }
  function subscribeKey(proxyObject, key, callback, notifyInSync) {
    let prevValue = proxyObject[key];
    return subscribe$3(
      proxyObject,
      () => {
        const nextValue = proxyObject[key];
        if (!Object.is(prevValue, nextValue)) {
          callback(prevValue = nextValue);
        }
      },
      notifyInSync
    );
  }
  const { proxyStateMap: proxyStateMap$1, snapCache: snapCache$1 } = unstable_getInternalStates();
  const isProxy$1 = (x) => proxyStateMap$1.has(x);
  function proxyMap(entries) {
    const initialData = [];
    let initialIndex = 0;
    const indexMap = /* @__PURE__ */ new Map();
    const snapMapCache = /* @__PURE__ */ new WeakMap();
    const registerSnapMap = () => {
      const cache2 = snapCache$1.get(vObject);
      const latestSnap = cache2 == null ? void 0 : cache2[1];
      if (latestSnap && !snapMapCache.has(latestSnap)) {
        const clonedMap = new Map(indexMap);
        snapMapCache.set(latestSnap, clonedMap);
      }
    };
    const getMapForThis = (x) => snapMapCache.get(x) || indexMap;
    if (entries) {
      if (typeof entries[Symbol.iterator] !== "function") {
        throw new TypeError(
          "proxyMap:\n	initial state must be iterable\n		tip: structure should be [[key, value]]"
        );
      }
      for (const [key, value] of entries) {
        indexMap.set(key, initialIndex);
        initialData[initialIndex++] = value;
      }
    }
    const vObject = {
      data: initialData,
      index: initialIndex,
      epoch: 0,
      get size() {
        if (!isProxy$1(this)) {
          registerSnapMap();
        }
        const map = getMapForThis(this);
        return map.size;
      },
      get(key) {
        const map = getMapForThis(this);
        const index = map.get(key);
        if (index === void 0) {
          this.epoch;
          return void 0;
        }
        return this.data[index];
      },
      has(key) {
        const map = getMapForThis(this);
        this.epoch;
        return map.has(key);
      },
      set(key, value) {
        if (!isProxy$1(this)) {
          throw new Error("Cannot perform mutations on a snapshot");
        }
        const index = indexMap.get(key);
        if (index === void 0) {
          indexMap.set(key, this.index);
          this.data[this.index++] = value;
        } else {
          this.data[index] = value;
        }
        this.epoch++;
        return this;
      },
      delete(key) {
        if (!isProxy$1(this)) {
          throw new Error("Cannot perform mutations on a snapshot");
        }
        const index = indexMap.get(key);
        if (index === void 0) {
          return false;
        }
        delete this.data[index];
        indexMap.delete(key);
        this.epoch++;
        return true;
      },
      clear() {
        if (!isProxy$1(this)) {
          throw new Error("Cannot perform mutations on a snapshot");
        }
        this.data.length = 0;
        this.index = 0;
        this.epoch++;
        indexMap.clear();
      },
      forEach(cb) {
        this.epoch;
        const map = getMapForThis(this);
        map.forEach((index, key) => {
          cb(this.data[index], key, this);
        });
      },
      *entries() {
        this.epoch;
        const map = getMapForThis(this);
        for (const [key, index] of map) {
          yield [key, this.data[index]];
        }
      },
      *keys() {
        this.epoch;
        const map = getMapForThis(this);
        for (const key of map.keys()) {
          yield key;
        }
      },
      *values() {
        this.epoch;
        const map = getMapForThis(this);
        for (const index of map.values()) {
          yield this.data[index];
        }
      },
      [Symbol.iterator]() {
        return this.entries();
      },
      get [Symbol.toStringTag]() {
        return "Map";
      },
      toJSON() {
        return new Map(this.entries());
      }
    };
    const proxiedObject = proxy(vObject);
    Object.defineProperties(proxiedObject, {
      size: { enumerable: false },
      index: { enumerable: false },
      epoch: { enumerable: false },
      data: { enumerable: false },
      toJSON: { enumerable: false }
    });
    Object.seal(proxiedObject);
    return proxiedObject;
  }
  const { proxyStateMap, snapCache } = unstable_getInternalStates();
  const maybeProxify = (x) => typeof x === "object" ? proxy({ x }).x : x;
  const isProxy = (x) => proxyStateMap.has(x);
  function proxySet(initialValues) {
    const initialData = [];
    const indexMap = /* @__PURE__ */ new Map();
    let initialIndex = 0;
    const snapMapCache = /* @__PURE__ */ new WeakMap();
    const registerSnapMap = () => {
      const cache2 = snapCache.get(vObject);
      const latestSnap = cache2 == null ? void 0 : cache2[1];
      if (latestSnap && !snapMapCache.has(latestSnap)) {
        const clonedMap = new Map(indexMap);
        snapMapCache.set(latestSnap, clonedMap);
      }
    };
    const getMapForThis = (x) => snapMapCache.get(x) || indexMap;
    if (initialValues) {
      if (typeof initialValues[Symbol.iterator] !== "function") {
        throw new TypeError("not iterable");
      }
      for (const value of initialValues) {
        if (!indexMap.has(value)) {
          const v = maybeProxify(value);
          indexMap.set(v, initialIndex);
          initialData[initialIndex++] = v;
        }
      }
    }
    const vObject = {
      data: initialData,
      index: initialIndex,
      epoch: 0,
      get size() {
        if (!isProxy(this)) {
          registerSnapMap();
        }
        return indexMap.size;
      },
      has(value) {
        const map = getMapForThis(this);
        const v = maybeProxify(value);
        this.epoch;
        return map.has(v);
      },
      add(value) {
        if (!isProxy(this)) {
          throw new Error("Cannot perform mutations on a snapshot");
        }
        const v = maybeProxify(value);
        if (!indexMap.has(v)) {
          indexMap.set(v, this.index);
          this.data[this.index++] = v;
          this.epoch++;
        }
        return this;
      },
      delete(value) {
        if (!isProxy(this)) {
          throw new Error("Cannot perform mutations on a snapshot");
        }
        const v = maybeProxify(value);
        const index = indexMap.get(v);
        if (index === void 0) {
          return false;
        }
        delete this.data[index];
        indexMap.delete(v);
        this.epoch++;
        return true;
      },
      clear() {
        if (!isProxy(this)) {
          throw new Error("Cannot perform mutations on a snapshot");
        }
        this.data.length = 0;
        this.index = 0;
        this.epoch++;
        indexMap.clear();
      },
      forEach(cb) {
        this.epoch;
        const map = getMapForThis(this);
        map.forEach((index) => {
          cb(this.data[index], this.data[index], this);
        });
      },
      *values() {
        this.epoch;
        const map = getMapForThis(this);
        for (const index of map.values()) {
          yield this.data[index];
        }
      },
      keys() {
        this.epoch;
        return this.values();
      },
      *entries() {
        this.epoch;
        const map = getMapForThis(this);
        for (const index of map.values()) {
          const value = this.data[index];
          yield [value, value];
        }
      },
      toJSON() {
        return new Set(this.values());
      },
      [Symbol.iterator]() {
        return this.values();
      },
      get [Symbol.toStringTag]() {
        return "Set";
      },
      intersection(other) {
        this.epoch;
        const otherSet = proxySet(other);
        const resultSet = proxySet();
        for (const value of this.values()) {
          if (otherSet.has(value)) {
            resultSet.add(value);
          }
        }
        return proxySet(resultSet);
      },
      union(other) {
        this.epoch;
        const resultSet = proxySet();
        const otherSet = proxySet(other);
        for (const value of this.values()) {
          resultSet.add(value);
        }
        for (const value of otherSet) {
          resultSet.add(value);
        }
        return proxySet(resultSet);
      },
      difference(other) {
        this.epoch;
        const resultSet = proxySet();
        const otherSet = proxySet(other);
        for (const value of this.values()) {
          if (!otherSet.has(value)) {
            resultSet.add(value);
          }
        }
        return proxySet(resultSet);
      },
      symmetricDifference(other) {
        this.epoch;
        const resultSet = proxySet();
        const otherSet = proxySet(other);
        for (const value of this.values()) {
          if (!otherSet.has(value)) {
            resultSet.add(value);
          }
        }
        for (const value of otherSet.values()) {
          if (!this.has(value)) {
            resultSet.add(value);
          }
        }
        return proxySet(resultSet);
      },
      isSubsetOf(other) {
        this.epoch;
        const otherSet = proxySet(other);
        return this.size <= other.size && [...this.values()].every((value) => otherSet.has(value));
      },
      isSupersetOf(other) {
        this.epoch;
        const otherSet = proxySet(other);
        return this.size >= other.size && [...otherSet].every((value) => this.has(value));
      },
      isDisjointFrom(other) {
        this.epoch;
        const otherSet = proxySet(other);
        return [...this.values()].every((value) => !otherSet.has(value));
      }
    };
    const proxiedObject = proxy(vObject);
    Object.defineProperties(proxiedObject, {
      size: { enumerable: false },
      data: { enumerable: false },
      index: { enumerable: false },
      epoch: { enumerable: false },
      toJSON: { enumerable: false }
    });
    Object.seal(proxiedObject);
    return proxiedObject;
  }
  function valtioFactory(computeValue) {
    const state2 = proxy({
      value: computeValue()
    });
    function use() {
      return useSnapshot(state2).value;
    }
    function get2() {
      return state2.value;
    }
    function update() {
      state2.value = computeValue();
    }
    const updateThrottled = throttle$1(update, 100, {
      edges: ["leading", "trailing"]
    });
    return {
      state: state2,
      use,
      get: get2,
      update,
      updateThrottled
    };
  }
  function subscribeOnKeys(state2, keys, callback) {
    let prevVal = pick$1(snapshot(state2), keys);
    subscribe$3(state2, () => {
      const snap = snapshot(state2);
      const val = pick$1(snap, keys);
      if (!isEqual$2(prevVal, val)) {
        callback(snap);
      }
      prevVal = val;
    });
  }
  async function proxyWithGmStorage(initialVaue, storageKey2) {
    async function load() {
      const allowedKeys = Object.keys(initialVaue);
      return pick$1(await GM.getValue(storageKey2) || {}, allowedKeys);
    }
    const p2 = proxy({
      ...initialVaue,
      ...await load()
    });
    setTimeout(() => {
      const limit2 = pLimit(1);
      subscribe$3(p2, () => limit2(async () => {
        const existing = await load();
        const newValue = toMerged(existing, snapshot(p2));
        GM.setValue(storageKey2, newValue);
      }));
    });
    return p2;
  }
  async function proxySetWithGmStorage(storageKey2) {
    const load = async () => await GM.getValue(storageKey2) || [];
    const p2 = proxySet(await load());
    const replaceAllWith = (newVal) => {
      const newSet = new Set(newVal);
      for (const x of [...p2, ...newSet]) {
        if (!newSet.has(x)) p2.delete(x);
        else p2.add(x);
      }
    };
    setTimeout(setupSubscribe);
    let persist = true;
    function setupSubscribe() {
      subscribe$3(p2, () => {
        if (!persist) return;
        GM.setValue(storageKey2, Array.from(snapshot(p2)));
      });
      reciveGmValueUpdatesFromOtherTab({
        storageKey: storageKey2,
        setPersist: (val) => persist = val,
        onUpdate: replaceAllWith
      });
    }
    return {
      set: p2,
      replaceAllWith
    };
  }
  async function proxyMapWithGmStorage(storageKey2, beforeSave) {
    const load = async () => await GM.getValue(storageKey2) || [];
    const p2 = proxyMap(await load());
    const replaceAllWith = (newVal) => {
      const newMap = new Map(newVal);
      for (const [k, v] of [...p2, ...newMap]) {
        if (!newMap.has(k)) p2.delete(k);
        else p2.set(k, v);
      }
    };
    setTimeout(setupSubscribe);
    let persist = true;
    function setupSubscribe() {
      subscribe$3(p2, () => {
        if (!persist) return;
        let val = Array.from(snapshot(p2));
        GM.setValue(storageKey2, val);
      });
      reciveGmValueUpdatesFromOtherTab({
        storageKey: storageKey2,
        setPersist: (val) => persist = val,
        onUpdate: replaceAllWith
      });
    }
    return {
      map: p2,
      replaceAllWith
    };
  }
  const defaultHeader = () => document.querySelector(".bili-header__bar");
  function isUsingCustomHeader() {
    const el = defaultHeader();
    return Boolean(el && window.getComputedStyle(el).display === "none");
  }
  const $usingEvolevdHeader = valtioFactory(isUsingCustomHeader);
  function calcHeaderHeight() {
    if (!isUsingCustomHeader()) return 64;
    const fixed = document.body.classList.contains("fixed-navbar");
    if (!fixed) return 0;
    const heightDef = document.documentElement.style.getPropertyValue("--navbar-height");
    if (!heightDef) return 50;
    const height = Number(heightDef.replace("px", ""));
    if (isNaN(height)) return 50;
    return height;
  }
  const $headerHeight = valtioFactory(calcHeaderHeight);
  function calcHeaderWidth() {
    const paddingDef = document.documentElement.style.getPropertyValue("--navbar-bounds-padding");
    if (!paddingDef) return;
    const percent = minmax(Number(paddingDef.replace("%", "")), 2, 10);
    const width = 100 - percent * 2;
    return width;
  }
  const $headerWidth = valtioFactory(calcHeaderWidth);
  function useBackToTopRight() {
    const width = $headerWidth.use();
    const {
      pureRecommend,
      style: {
        pureRecommend: {
          useCustomGrid
        }
      }
    } = useSettingsSnapshot();
    if (!pureRecommend || !useCustomGrid) return;
    if (!width) return;
    const rest = (1 - width / 100) / 2 * window.innerWidth + /* padding */
    10;
    const backToTopWidth = 40;
    if (rest > backToTopWidth + /** default back-top-right */
    24 + /** visual padding */
    5) {
      return;
    }
    if (rest < backToTopWidth) {
      return 0;
    }
    const right = Math.floor((rest - backToTopWidth) / 2);
    return right;
  }
  const $evolvedThemeColor = valtioFactory(function calcEvolvedThemeColor() {
    return window.getComputedStyle(document.documentElement).getPropertyValue("--theme-color");
  });
  function action() {
    $usingEvolevdHeader.updateThrottled();
    $headerHeight.updateThrottled();
    $headerWidth.updateThrottled();
    $evolvedThemeColor.updateThrottled();
  }
  const ob$1 = new MutationObserver(() => action());
  ob$1.observe(document.documentElement, {
    attributes: true,
    attributeFilter: ["style"]
  });
  ob$1.observe(document.body, {
    attributes: true,
    attributeFilter: ["class"]
  });
  window.addEventListener("unload", () => {
    ob$1.disconnect();
  });
  document.body.addEventListener("click", (e2) => {
    const el = e2.target;
    const isClickOnButton = (el2) => !!(el2 == null ? void 0 : el2.matches(".be-button.ok"));
    if (!isClickOnButton(el) && !isClickOnButton(el.parentElement)) return;
    if (!el.closest(".be-popup.picker.open")) return;
    setTimeout($evolvedThemeColor.updateThrottled, 1e3);
  }, {
    capture: true,
    passive: true
  });
  const messageConfig = {
    // duration: default 3, 单位秒
    maxCount: 5,
    top: $headerHeight.get() - 4
  };
  antd.message.config(messageConfig);
  function AntdStaticFunctionsSetup() {
    const h = $headerHeight.use();
    return /* @__PURE__ */ jsx$1(antd.App, { component: "div", message: {
      ...messageConfig,
      top: h - 4
    }, children: /* @__PURE__ */ jsx$1(SetupInner, {}) });
  }
  let antStatic;
  let antMessage = antd.message;
  let antNotification = antd.notification;
  function SetupInner() {
    antStatic = antd.App.useApp();
    antMessage = antStatic.message;
    antNotification = antStatic.notification;
    return null;
  }
  function defineAntMenus(arr) {
    return arr.filter(Boolean).filter((x) => {
      if (typeof x.test === "undefined") return true;
      if (typeof x.test === "boolean") return x.test;
      return x.test();
    }).map((x) => omit(x, ["test"]));
  }
  const cuidaShuffleOutline = (props, ref) => /* @__PURE__ */ jsxs("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref, ...props, children: [
    /* @__PURE__ */ jsx$1("path", { fill: "currentColor", fillRule: "evenodd", d: "M17.793 3.693a1 1 0 0 1 1.414 0l2.5 2.5a1 1 0 0 1 0 1.414l-2.5 2.5a1 1 0 1 1-1.414-1.414L19.586 6.9l-1.793-1.793a1 1 0 0 1 0-1.414m0 10.15a1 1 0 0 1 1.414 0l2.5 2.5a1 1 0 0 1 0 1.414l-2.5 2.5a1 1 0 1 1-1.414-1.414l1.793-1.793l-1.793-1.793a1 1 0 0 1 0-1.414", clipRule: "evenodd" }),
    /* @__PURE__ */ jsx$1("path", { fill: "currentColor", fillRule: "evenodd", d: "M19.054 5.913c.352.023.657.043.946.043a1 1 0 1 1 0 2c-.346 0-.776-.028-1.184-.054a37 37 0 0 0-.606-.037c-.614-.03-1.118-.02-1.482.065c-1.456.341-3.07 1.481-4.394 4.117c1.304 2.555 2.9 3.529 4.394 3.879c.364.085.868.094 1.482.064c.186-.009.393-.022.606-.036A19 19 0 0 1 20 15.899a1 1 0 1 1 0 2c-.289 0-.594.02-.946.044c-.227.015-.473.032-.747.045c-.63.03-1.377.04-2.035-.115c-1.812-.424-3.549-1.493-4.972-3.634c-.553 1.02-1.177 1.822-1.927 2.427c-.978.788-2.12 1.106-3.213 1.24c-.882.108-1.81.102-2.64.096L3 18a1 1 0 1 1 0-2l.582.002c.824.005 1.593.01 2.335-.08c.892-.11 1.624-.348 2.201-.813c.687-.554 1.323-1.447 1.962-2.95l.046-.109l-.046-.109c-.651-1.53-1.303-2.495-2.015-3.103c-.56-.477-1.277-.726-2.161-.845c-.763-.102-1.562-.099-2.42-.095L3 7.899a1 1 0 1 1 0-2l.445-.001c.853-.004 1.813-.01 2.724.113c1.094.146 2.234.486 3.194 1.305c.75.64 1.375 1.481 1.93 2.52c1.408-2.187 3.136-3.421 4.979-3.853c.658-.154 1.405-.145 2.035-.115c.274.013.52.03.747.045", clipRule: "evenodd" })
  ] });
  const ForwardRef$18 = H.forwardRef(cuidaShuffleOutline);
  function createSvgComponent(render5) {
    return H.forwardRef((props, ref) => {
      return render5({
        xmlns: "http://www.w3.org/2000/svg",
        xmlnsXlink: "http://www.w3.org/1999/xlink",
        ...props,
        ref
      });
    });
  }
  function r$1(e2) {
    var t2, f2, n2 = "";
    if ("string" == typeof e2 || "number" == typeof e2) n2 += e2;
    else if ("object" == typeof e2) if (Array.isArray(e2)) {
      var o2 = e2.length;
      for (t2 = 0; t2 < o2; t2++) e2[t2] && (f2 = r$1(e2[t2])) && (n2 && (n2 += " "), n2 += f2);
    } else for (f2 in e2) e2[f2] && (n2 && (n2 += " "), n2 += f2);
    return n2;
  }
  function clsx() {
    for (var e2, t2, f2 = 0, n2 = "", o2 = arguments.length; f2 < o2; f2++) (e2 = arguments[f2]) && (t2 = r$1(e2)) && (n2 && (n2 += " "), n2 += t2);
    return n2;
  }
  const phThumbsDownDuotone = (props, ref) => /* @__PURE__ */ jsx$1("svg", { viewBox: "0 0 256 256", width: "1.2em", height: "1.2em", ref, ...props, children: /* @__PURE__ */ jsxs("g", { fill: "currentColor", children: [
    /* @__PURE__ */ jsx$1("path", { d: "M80 48v104H32a8 8 0 0 1-8-8V56a8 8 0 0 1 8-8Z", opacity: 0.2 }),
    /* @__PURE__ */ jsx$1("path", { d: "m239.82 157l-12-96A24 24 0 0 0 204 40H32a16 16 0 0 0-16 16v88a16 16 0 0 0 16 16h43.06l37.78 75.58A8 8 0 0 0 120 240a40 40 0 0 0 40-40v-16h56a24 24 0 0 0 23.82-27M72 144H32V56h40Zm150 21.29a7.88 7.88 0 0 1-6 2.71h-64a8 8 0 0 0-8 8v24a24 24 0 0 1-19.29 23.54L88 150.11V56h116a8 8 0 0 1 7.94 7l12 96a7.87 7.87 0 0 1-1.94 6.29" })
  ] }) });
  const ForwardRef$17 = H.forwardRef(phThumbsDownDuotone);
  const iconParkOutlineConfig = (props, ref) => /* @__PURE__ */ jsx$1("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref, ...props, children: /* @__PURE__ */ jsxs("g", { fill: "none", stroke: "currentColor", strokeLinejoin: "round", strokeWidth: 4, children: [
    /* @__PURE__ */ jsx$1("path", { d: "m24 4l-6 6h-8v8l-6 6l6 6v8h8l6 6l6-6h8v-8l6-6l-6-6v-8h-8z" }),
    /* @__PURE__ */ jsx$1("path", { d: "M24 30a6 6 0 1 0 0-12a6 6 0 0 0 0 12Z" })
  ] }) });
  const ForwardRef$16 = H.forwardRef(iconParkOutlineConfig);
  const iconParkOutlinePlayTwo = (props, ref) => /* @__PURE__ */ jsx$1("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref, ...props, children: /* @__PURE__ */ jsxs("g", { fill: "none", stroke: "currentColor", strokeLinejoin: "round", strokeWidth: 4, children: [
    /* @__PURE__ */ jsx$1("rect", { width: 36, height: 36, x: 6, y: 6, strokeLinecap: "round", rx: 3 }),
    /* @__PURE__ */ jsx$1("path", { d: "M18.5 24v-7.794l6.75 3.897L32 24l-6.75 3.897l-6.75 3.897z" })
  ] }) });
  const ForwardRef$15 = H.forwardRef(iconParkOutlinePlayTwo);
  const materialSymbolsLightOpenInNew = (props, ref) => /* @__PURE__ */ jsx$1("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref, ...props, children: /* @__PURE__ */ jsx$1("path", { fill: "currentColor", d: "M5.616 20q-.691 0-1.153-.462T4 18.384V5.616q0-.691.463-1.153T5.616 4h5.615v1H5.616q-.231 0-.424.192T5 5.616v12.769q0 .23.192.423t.423.192h12.77q.23 0 .423-.192t.192-.423v-5.616h1v5.616q0 .69-.462 1.152T18.384 20zm4.123-5.03l-.708-.709L18.292 5H14V4h6v6h-1V5.708z" }) });
  const ForwardRef$14 = H.forwardRef(materialSymbolsLightOpenInNew);
  const tablerSortAscending2 = (props, ref) => /* @__PURE__ */ jsx$1("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref, ...props, children: /* @__PURE__ */ jsx$1("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "m14 9l3-3l3 3M5 5.5a.5.5 0 0 1 .5-.5h4a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-.5.5h-4a.5.5 0 0 1-.5-.5zm0 9a.5.5 0 0 1 .5-.5h4a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-.5.5h-4a.5.5 0 0 1-.5-.5zM17 6v12" }) });
  const ForwardRef$13 = H.forwardRef(tablerSortAscending2);
  const tablerSortDescending2 = (props, ref) => /* @__PURE__ */ jsx$1("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref, ...props, children: /* @__PURE__ */ jsx$1("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M5 5.5a.5.5 0 0 1 .5-.5h4a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-.5.5h-4a.5.5 0 0 1-.5-.5zm0 9a.5.5 0 0 1 .5-.5h4a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-.5.5h-4a.5.5 0 0 1-.5-.5zm9 .5l3 3l3-3m-3 3V6" }) });
  const ForwardRef$12 = H.forwardRef(tablerSortDescending2);
  const iconParkOutlineInfo = (props, ref) => /* @__PURE__ */ jsx$1("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref, ...props, children: /* @__PURE__ */ jsxs("g", { fill: "none", children: [
    /* @__PURE__ */ jsx$1("path", { stroke: "currentColor", strokeLinejoin: "round", strokeWidth: 4, d: "M24 44a19.94 19.94 0 0 0 14.142-5.858A19.94 19.94 0 0 0 44 24a19.94 19.94 0 0 0-5.858-14.142A19.94 19.94 0 0 0 24 4A19.94 19.94 0 0 0 9.858 9.858A19.94 19.94 0 0 0 4 24a19.94 19.94 0 0 0 5.858 14.142A19.94 19.94 0 0 0 24 44Z" }),
    /* @__PURE__ */ jsx$1("path", { fill: "currentColor", fillRule: "evenodd", d: "M24 11a2.5 2.5 0 1 1 0 5a2.5 2.5 0 0 1 0-5", clipRule: "evenodd" }),
    /* @__PURE__ */ jsx$1("path", { stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 4, d: "M24.5 34V20h-2M21 34h7" })
  ] }) });
  const ForwardRef$11 = H.forwardRef(iconParkOutlineInfo);
  const mdiShuffleDisabled = (props, ref) => /* @__PURE__ */ jsx$1("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref, ...props, children: /* @__PURE__ */ jsx$1("path", { fill: "currentColor", d: "M16 4.5V7H5v2h11v2.5L19.5 8M16 12.5V15H5v2h11v2.5l3.5-3.5" }) });
  const ForwardRef$10 = H.forwardRef(mdiShuffleDisabled);
  const iconParkOutlineTime = (props, ref) => /* @__PURE__ */ jsx$1("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref, ...props, children: /* @__PURE__ */ jsxs("g", { fill: "none", stroke: "currentColor", strokeLinejoin: "round", strokeWidth: 4, children: [
    /* @__PURE__ */ jsx$1("path", { d: "M24 44c11.046 0 20-8.954 20-20S35.046 4 24 4S4 12.954 4 24s8.954 20 20 20Z" }),
    /* @__PURE__ */ jsx$1("path", { strokeLinecap: "round", d: "M24.008 12v12.01l8.479 8.48" })
  ] }) });
  const ForwardRef$$ = H.forwardRef(iconParkOutlineTime);
  const iconParkOutlineIphone = (props, ref) => /* @__PURE__ */ jsx$1("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref, ...props, children: /* @__PURE__ */ jsxs("g", { fill: "none", stroke: "currentColor", strokeWidth: 4, children: [
    /* @__PURE__ */ jsx$1("rect", { width: 26, height: 40, x: 11, y: 4, rx: 3 }),
    /* @__PURE__ */ jsx$1("path", { strokeLinecap: "round", strokeLinejoin: "round", d: "M22 10h4m-6 28h8" })
  ] }) });
  const ForwardRef$_ = H.forwardRef(iconParkOutlineIphone);
  const iconParkOutlineComputer = (props, ref) => /* @__PURE__ */ jsx$1("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref, ...props, children: /* @__PURE__ */ jsxs("g", { fill: "none", stroke: "currentColor", strokeWidth: 4, children: [
    /* @__PURE__ */ jsx$1("path", { strokeLinecap: "round", strokeLinejoin: "round", d: "M19 32h10v9H19z" }),
    /* @__PURE__ */ jsx$1("rect", { width: 38, height: 24, x: 5, y: 8, rx: 2 }),
    /* @__PURE__ */ jsx$1("path", { strokeLinecap: "round", strokeLinejoin: "round", d: "M22 27h4M14 41h20" })
  ] }) });
  const ForwardRef$Z = H.forwardRef(iconParkOutlineComputer);
  const iconParkOutlineConcern = (props, ref) => /* @__PURE__ */ jsx$1("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref, ...props, children: /* @__PURE__ */ jsxs("g", { fill: "none", stroke: "currentColor", children: [
    /* @__PURE__ */ jsx$1("path", { strokeLinecap: "round", strokeWidth: 4, d: "M10.858 9.858A19.94 19.94 0 0 0 5 24a19.94 19.94 0 0 0 5.858 14.142m28.284 0A19.94 19.94 0 0 0 45 24a19.94 19.94 0 0 0-5.858-14.142M34.9 33.9A13.96 13.96 0 0 0 39 24a13.96 13.96 0 0 0-4.1-9.9m-19.8 0A13.96 13.96 0 0 0 11 24a13.96 13.96 0 0 0 4.1 9.9" }),
    /* @__PURE__ */ jsx$1("path", { strokeLinejoin: "round", strokeWidth: 3.5, d: "M28.182 20C30.29 20 32 21.612 32 23.6c0 2.588-2.546 4.8-3.818 6Q26.908 30.8 25 32q-1.909-1.2-3.182-2.4C20.545 28.4 18 26.188 18 23.6c0-1.988 1.71-3.6 3.818-3.6c1.328 0 2.498.64 3.182 1.61c.684-.97 1.854-1.61 3.182-1.61Z" })
  ] }) });
  const ForwardRef$Y = H.forwardRef(iconParkOutlineConcern);
  const iconParkOutlineTumblr = (props, ref) => /* @__PURE__ */ jsx$1("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref, ...props, children: /* @__PURE__ */ jsxs("g", { fill: "none", children: [
    /* @__PURE__ */ jsx$1("path", { stroke: "currentColor", strokeWidth: 4, d: "M39 6H9a3 3 0 0 0-3 3v30a3 3 0 0 0 3 3h30a3 3 0 0 0 3-3V9a3 3 0 0 0-3-3Z" }),
    /* @__PURE__ */ jsx$1("path", { fill: "currentColor", d: "M15 22v-5h5v-3l6-2v5h5v5h-5v7s0 1.5 2 2s5-1 5-1l-2 6h-5c-3.5 0-6-3.5-6-6v-8z" })
  ] }) });
  const ForwardRef$X = H.forwardRef(iconParkOutlineTumblr);
  const carbonStar = (props, ref) => /* @__PURE__ */ jsx$1("svg", { viewBox: "0 0 32 32", width: "1.2em", height: "1.2em", ref, ...props, children: /* @__PURE__ */ jsx$1("path", { fill: "currentColor", d: "m16 6.52l2.76 5.58l.46 1l1 .15l6.16.89l-4.38 4.3l-.75.73l.18 1l1.05 6.13l-5.51-2.89L16 23l-.93.49l-5.51 2.85l1-6.13l.18-1l-.74-.77l-4.42-4.35l6.16-.89l1-.15l.46-1zM16 2l-4.55 9.22l-10.17 1.47l7.36 7.18L6.9 30l9.1-4.78L25.1 30l-1.74-10.13l7.36-7.17l-10.17-1.48Z" }) });
  const ForwardRef$W = H.forwardRef(carbonStar);
  const carbonStarFilled = (props, ref) => /* @__PURE__ */ jsx$1("svg", { viewBox: "0 0 32 32", width: "1.2em", height: "1.2em", ref, ...props, children: /* @__PURE__ */ jsx$1("path", { fill: "currentColor", d: "m16 2l-4.55 9.22l-10.17 1.47l7.36 7.18L6.9 30l9.1-4.78L25.1 30l-1.74-10.13l7.36-7.17l-10.17-1.48Z" }) });
  const ForwardRef$V = H.forwardRef(carbonStarFilled);
  const iconParkOutlineFire = (props, ref) => /* @__PURE__ */ jsx$1("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref, ...props, children: /* @__PURE__ */ jsx$1("path", { fill: "none", stroke: "currentColor", strokeLinejoin: "round", strokeWidth: 4, d: "M24 44c8.235 0 15-6.526 15-14.902c0-2.056-.105-4.26-1.245-7.686s-1.369-3.868-2.574-5.984c-.515 4.317-3.27 6.117-3.97 6.655c0-.56-1.666-6.747-4.193-10.45C24.537 8 21.163 5.617 19.185 4c0 3.07-.863 7.634-2.1 9.96c-1.236 2.325-1.468 2.41-3.013 4.14s-2.253 2.265-3.545 4.365S9 27.362 9 29.418C9 37.794 15.765 44 24 44Z" }) });
  const ForwardRef$U = H.forwardRef(iconParkOutlineFire);
  const lineMdUploadingLoop = (props, ref) => /* @__PURE__ */ jsx$1("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref, ...props, children: /* @__PURE__ */ jsxs("g", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, children: [
    /* @__PURE__ */ jsx$1("path", { strokeDasharray: "2 4", strokeDashoffset: 6, d: "M12 21c-4.97 0 -9 -4.03 -9 -9c0 -4.97 4.03 -9 9 -9", children: /* @__PURE__ */ jsx$1("animate", { attributeName: "stroke-dashoffset", dur: "0.6s", repeatCount: "indefinite", values: "6;0" }) }),
    /* @__PURE__ */ jsx$1("path", { strokeDasharray: 32, strokeDashoffset: 32, d: "M12 3c4.97 0 9 4.03 9 9c0 4.97 -4.03 9 -9 9", children: /* @__PURE__ */ jsx$1("animate", { fill: "freeze", attributeName: "stroke-dashoffset", begin: "0.1s", dur: "0.4s", values: "32;0" }) }),
    /* @__PURE__ */ jsx$1("path", { strokeDasharray: 10, strokeDashoffset: 10, d: "M12 16v-7.5", children: /* @__PURE__ */ jsx$1("animate", { fill: "freeze", attributeName: "stroke-dashoffset", begin: "0.5s", dur: "0.2s", values: "10;0" }) }),
    /* @__PURE__ */ jsx$1("path", { strokeDasharray: 6, strokeDashoffset: 6, d: "M12 8.5l3.5 3.5M12 8.5l-3.5 3.5", children: /* @__PURE__ */ jsx$1("animate", { fill: "freeze", attributeName: "stroke-dashoffset", begin: "0.7s", dur: "0.2s", values: "6;0" }) })
  ] }) });
  const ForwardRef$T = H.forwardRef(lineMdUploadingLoop);
  const iconParkOutlinePeopleDelete = (props, ref) => /* @__PURE__ */ jsx$1("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref, ...props, children: /* @__PURE__ */ jsxs("g", { fill: "none", stroke: "currentColor", strokeLinejoin: "round", strokeWidth: 4, children: [
    /* @__PURE__ */ jsx$1("path", { d: "M19 20a7 7 0 1 0 0-14a7 7 0 0 0 0 14Z" }),
    /* @__PURE__ */ jsx$1("path", { strokeLinecap: "round", d: "m33 31l8 8m-8 0l8-8m-14-3h-8.2c-4.48 0-6.72 0-8.432.872a8 8 0 0 0-3.496 3.496C6 34.08 6 36.32 6 40.8V42h21" })
  ] }) });
  const ForwardRef$S = H.forwardRef(iconParkOutlinePeopleDelete);
  const iconParkOutlineReturn = (props, ref) => /* @__PURE__ */ jsx$1("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref, ...props, children: /* @__PURE__ */ jsxs("g", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 4, children: [
    /* @__PURE__ */ jsx$1("path", { d: "m13 8l-7 6l7 7" }),
    /* @__PURE__ */ jsx$1("path", { d: "M6 14h22.994c6.883 0 12.728 5.62 12.996 12.5c.284 7.27-5.723 13.5-12.996 13.5H11.998" })
  ] }) });
  const ForwardRef$R = H.forwardRef(iconParkOutlineReturn);
  const iconParkOutlineCopy = (props, ref) => /* @__PURE__ */ jsx$1("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref, ...props, children: /* @__PURE__ */ jsxs("g", { fill: "none", stroke: "currentColor", strokeLinejoin: "round", strokeWidth: 4, children: [
    /* @__PURE__ */ jsx$1("path", { strokeLinecap: "round", d: "M13 12.432v-4.62A2.813 2.813 0 0 1 15.813 5h24.374A2.813 2.813 0 0 1 43 7.813v24.375A2.813 2.813 0 0 1 40.188 35h-4.672" }),
    /* @__PURE__ */ jsx$1("path", { d: "M32.188 13H7.811A2.813 2.813 0 0 0 5 15.813v24.374A2.813 2.813 0 0 0 7.813 43h24.375A2.813 2.813 0 0 0 35 40.188V15.811A2.813 2.813 0 0 0 32.188 13Z" })
  ] }) });
  const ForwardRef$Q = H.forwardRef(iconParkOutlineCopy);
  const svgSpinnersBarsRotateFade = (props, ref) => /* @__PURE__ */ jsx$1("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref, ...props, children: /* @__PURE__ */ jsxs("g", { children: [
    /* @__PURE__ */ jsx$1("rect", { width: 2, height: 5, x: 11, y: 1, fill: "currentColor", opacity: 0.14 }),
    /* @__PURE__ */ jsx$1("rect", { width: 2, height: 5, x: 11, y: 1, fill: "currentColor", opacity: 0.29, transform: "rotate(30 12 12)" }),
    /* @__PURE__ */ jsx$1("rect", { width: 2, height: 5, x: 11, y: 1, fill: "currentColor", opacity: 0.43, transform: "rotate(60 12 12)" }),
    /* @__PURE__ */ jsx$1("rect", { width: 2, height: 5, x: 11, y: 1, fill: "currentColor", opacity: 0.57, transform: "rotate(90 12 12)" }),
    /* @__PURE__ */ jsx$1("rect", { width: 2, height: 5, x: 11, y: 1, fill: "currentColor", opacity: 0.71, transform: "rotate(120 12 12)" }),
    /* @__PURE__ */ jsx$1("rect", { width: 2, height: 5, x: 11, y: 1, fill: "currentColor", opacity: 0.86, transform: "rotate(150 12 12)" }),
    /* @__PURE__ */ jsx$1("rect", { width: 2, height: 5, x: 11, y: 1, fill: "currentColor", transform: "rotate(180 12 12)" }),
    /* @__PURE__ */ jsx$1("animateTransform", { attributeName: "transform", calcMode: "discrete", dur: "0.75s", repeatCount: "indefinite", type: "rotate", values: "0 12 12;30 12 12;60 12 12;90 12 12;120 12 12;150 12 12;180 12 12;210 12 12;240 12 12;270 12 12;300 12 12;330 12 12;360 12 12" })
  ] }) });
  const ForwardRef$P = H.forwardRef(svgSpinnersBarsRotateFade);
  const materialSymbolsDeleteOutlineRounded = (props, ref) => /* @__PURE__ */ jsx$1("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref, ...props, children: /* @__PURE__ */ jsx$1("path", { fill: "currentColor", d: "M7 21q-.825 0-1.412-.587T5 19V6q-.425 0-.712-.288T4 5t.288-.712T5 4h4q0-.425.288-.712T10 3h4q.425 0 .713.288T15 4h4q.425 0 .713.288T20 5t-.288.713T19 6v13q0 .825-.587 1.413T17 21zM17 6H7v13h10zm-7 11q.425 0 .713-.288T11 16V9q0-.425-.288-.712T10 8t-.712.288T9 9v7q0 .425.288.713T10 17m4 0q.425 0 .713-.288T15 16V9q0-.425-.288-.712T14 8t-.712.288T13 9v7q0 .425.288.713T14 17M7 6v13z" }) });
  const ForwardRef$O = H.forwardRef(materialSymbolsDeleteOutlineRounded);
  const materialSymbolsBarChart = (props, ref) => /* @__PURE__ */ jsx$1("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref, ...props, children: /* @__PURE__ */ jsx$1("path", { fill: "currentColor", d: "M16 20v-7h4v7zm-6 0V4h4v16zm-6 0V9h4v11z" }) });
  const ForwardRef$N = H.forwardRef(materialSymbolsBarChart);
  const IconForDislike = ForwardRef$17;
  const IconForConfig = ForwardRef$16;
  const IconForPlayer = ForwardRef$15;
  const IconForOpenExternalLink = ForwardRef$14;
  const IconForAsc = ForwardRef$13;
  const IconForDesc = ForwardRef$12;
  const IconForInfo = ForwardRef$11;
  const IconForDefaultOrder = ForwardRef$10;
  const IconForShuffle = ForwardRef$18;
  const IconForTimestamp = ForwardRef$$;
  const IconForPhone = ForwardRef$_;
  const IconForPc = ForwardRef$Z;
  const IconForFollowedOnly = ForwardRef$Y;
  const IconForDynamicFeed = ForwardRef$X;
  const IconForFav = ForwardRef$W;
  const IconForFaved = ForwardRef$V;
  const IconForHot = ForwardRef$U;
  const IconForSpaceUpload = ForwardRef$T;
  const IconForBlacklist = ForwardRef$S;
  const IconForReset = ForwardRef$R;
  const IconForCopy = ForwardRef$Q;
  const IconForLoading = ForwardRef$P;
  const IconForRemove = ForwardRef$O;
  const LIVE_GIF = `data:image/gif;base64,R0lGODlhGAAYAJECAP7+/v///wAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh/wtYTVAgRGF0YVhNUDw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTQ4IDc5LjE2NDAzNiwgMjAxOS8wOC8xMy0wMTowNjo1NyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDIxLjAgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6QTI2NTYzMDc2RTNDMTFFREJENEJEMzUxOTQzQjMxMkQiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6QTI2NTYzMDg2RTNDMTFFREJENEJEMzUxOTQzQjMxMkQiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDpBMjY1NjMwNTZFM0MxMUVEQkQ0QkQzNTE5NDNCMzEyRCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDpBMjY1NjMwNjZFM0MxMUVEQkQ0QkQzNTE5NDNCMzEyRCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PgH//v38+/r5+Pf29fTz8vHw7+7t7Ovq6ejn5uXk4+Lh4N/e3dzb2tnY19bV1NPS0dDPzs3My8rJyMfGxcTDwsHAv769vLu6ubi3trW0s7KxsK+urayrqqmop6alpKOioaCfnp2cm5qZmJeWlZSTkpGQj46NjIuKiYiHhoWEg4KBgH9+fXx7enl4d3Z1dHNycXBvbm1sa2ppaGdmZWRjYmFgX15dXFtaWVhXVlVUU1JRUE9OTUxLSklIR0ZFRENCQUA/Pj08Ozo5ODc2NTQzMjEwLy4tLCsqKSgnJiUkIyIhIB8eHRwbGhkYFxYVFBMSERAPDg0MCwoJCAcGBQQDAgEAACH5BAkEAAIALAAAAAAYABgAAAI5lI+py+0Po2QhTFXrRdlu031gJgqhpI0pdJ4sacJv6j6trABeTOMcfFslgp7ar4fcDVcyX+kJjToKACH5BAkEAAIALAAAAAAYABgAAAI2lI+py+0Po5xUhFDRvdls3H0T522SaJkRikKs6qptAr+kYoOzJvc37dPBgKQco3YbdpbM5qQAACH5BAkEAAIALAAAAAAYABgAAAI3lI+py+0Po5y02hhykHqLzmkGiImfCZHkkh0qmrztOSuyt8bmzfC0Z9sJa7qZLwhEwS7MpnNSAAAh+QQJBAACACwAAAAAGAAYAAACPJSPqcvtD6OctJoQ7MFYC55dYQSKHcmZo3J+qdsmJRzO7DvbMs7HSN5b/YIqBvCkGyKJixds4/NIp1RHAQAh+QQJBAACACwAAAAAGAAYAAACOpSPqcvtD6OcLwSarMVHXy54YKhJIrmhn3K25eKmJ/vGa1bnKS3rN2IzzHC94q/jE754yNVyBI1KIQUAIfkECQQAAgAsAAAAABgAGAAAAjmUj6nL7Q+jnLSaEOzBePbLSVwmjGJYopCZfmnDxmoif6xSkzeN5ozfIuF6RBfPVhQeN66Z5gmNTgoAIfkECQQAAgAsAAAAABgAGAAAAjmUj6nL7Q+jnLRaETLSMnMfdJ4Bit8YlRgKqerauOibyCen2OGK1/Pf2wB3NOGNyPLteIfk5QmNTgoAIfkECQQAAgAsAAAAABgAGAAAAjeUj6nL7Q+jnCkEWu3FRm/uHdYUCiVUnk+qSewYvd/amrWKyF2t6DbcuwmBGZgv+OHxOMyms1kAACH5BAkEAAIALAAAAAAYABgAAAI5lI+py+0PowtBLkptwlUf7n1YaIBlF5kmpI6puz5t9tLxBLsCgCpzdxPZcjQfEajbFHVJkvMJtRQAACH5BAkEAAIALAAAAAAYABgAAAI1lI+py+0Po5wpBFrtxUZv7nGdJgqheJ5QSkasJb2bmsFmSyPyaCv73avNcC1fr1gsKZdMSAEAIfkECQQAAgAsAAAAABgAGAAAAjWUj6nL7Q+jnLRaEfI1Wd8ebKDYkR4WHqcyol7Llm4KJ+0tx69cI/i+8vGGQdUpl9sol0xIAQAh+QQJBAACACwAAAAAGAAYAAACNJSPqcvtD6OctNq7QsBCa+xtV9h8DJl5p5qaCtqJsZugNvuyN43sIlzTCXkHnJHISSqXiQIAIfkECQQAAgAsAAAAABgAGAAAAjKUj6nL7Q+jnLTai3MMPLDuLeDXkZwZKqNYsqebJqva0u86yy1e6/feQ9SGL43xiEwUAAAh+QQJBAACACwAAAAAGAAYAAACM5SPqcvtD6OctNp7Q8BCa+xtzDd6JamEp5iai2qgcEvCc2K7N5LXLi3qsXCy4pCDTCoXBQAh+QQJBAACACwAAAAAGAAYAAACNJSPqcvtD6OctNoYcrhC7+txIag1mVkuY/exp5qOayLHqVK/M5J/+9Ez/IQvF7DISSqXkAIAIfkEBQQAAgAsAAAAABgAGAAAAjKUj6nL7Q+jnFSEUNG92WzcfZ21jWJYRucJranyutwig2xSey+e5nQPnMGEMeHoiExCCgA7`;
  function IconForLive({
    active = false,
    ...props
  }) {
    if (active) {
      return /* @__PURE__ */ jsx$1("img", { ...props, src: LIVE_GIF });
    } else {
      return /* @__PURE__ */ jsx$1(ForwardRef$N, { ...props });
    }
  }
  const IconForWatchlater = createSvgComponent((props) => {
    return /* @__PURE__ */ jsxs("svg", { viewBox: "0 0 20 20", width: "20", height: "20", fill: "currentColor", ...props, children: [
      /* @__PURE__ */ jsx$1("path", { className: "circle", d: "M10 3.1248000000000005C6.20305 3.1248000000000005 3.1250083333333336 6.202841666666667 3.1250083333333336 9.999833333333335C3.1250083333333336 13.796750000000001 6.20305 16.874833333333335 10 16.874833333333335C11.898291666666667 16.874833333333335 13.615833333333333 16.106291666666667 14.860625 14.861916666666666C15.104708333333335 14.617916666666666 15.500416666666668 14.617958333333334 15.7445 14.862041666666668C15.9885 15.106166666666669 15.988416666666668 15.501916666666666 15.744333333333334 15.745958333333334C14.274750000000001 17.215041666666668 12.243041666666667 18.124833333333335 10 18.124833333333335C5.512691666666667 18.124833333333335 1.8750083333333334 14.487125 1.8750083333333334 9.999833333333335C1.8750083333333334 5.512483333333334 5.512691666666667 1.8748000000000002 10 1.8748000000000002C14.487291666666668 1.8748000000000002 18.125 5.512483333333334 18.125 9.999833333333335C18.125 10.304458333333333 18.108208333333334 10.605458333333333 18.075458333333337 10.901791666666668C18.0375 11.244916666666667 17.728625 11.492291666666667 17.385583333333333 11.454333333333334C17.0425 11.416416666666667 16.795083333333334 11.107541666666668 16.833000000000002 10.764458333333334C16.860750000000003 10.513625000000001 16.875 10.2585 16.875 9.999833333333335C16.875 6.202841666666667 13.796958333333333 3.1248000000000005 10 3.1248000000000005z", fill: "currentColor" }),
      /* @__PURE__ */ jsx$1("path", { d: "M15.391416666666666 9.141166666666667C15.635458333333334 8.897083333333335 16.031208333333332 8.897083333333335 16.275291666666668 9.141166666666667L17.5 10.365875L18.72475 9.141166666666667C18.968791666666668 8.897083333333335 19.364541666666668 8.897083333333335 19.608625 9.141166666666667C19.852666666666668 9.385291666666667 19.852666666666668 9.780958333333334 19.608625 10.025083333333333L18.08925 11.544416666666669C17.763833333333334 11.869833333333334 17.236208333333334 11.869833333333334 16.91075 11.544416666666669L15.391416666666666 10.025083333333333C15.147333333333334 9.780958333333334 15.147333333333334 9.385291666666667 15.391416666666666 9.141166666666667z", fill: "currentColor" }),
      /* @__PURE__ */ jsx$1("path", { d: "M12.499333333333334 9.278375C13.05475 9.599 13.05475 10.400666666666668 12.499333333333334 10.721291666666668L9.373916666666666 12.525791666666668C8.818541666666667 12.846416666666666 8.124274999999999 12.445583333333333 8.124274999999999 11.804291666666668L8.124274999999999 8.1954C8.124274999999999 7.554066666666667 8.818541666666667 7.153233333333334 9.373916666666666 7.473900000000001L12.499333333333334 9.278375z", fill: "currentColor" })
    ] });
  });
  const clsIconTextWrapper = "inline-flex items-center justify-center line-height-[0]";
  function withDescIcon(label) {
    return /* @__PURE__ */ jsxs("span", { className: clsx(clsIconTextWrapper, "gap-1px"), children: [
      label,
      /* @__PURE__ */ jsx$1(IconForDesc, { className: "size-16px" })
    ] });
  }
  function withAscIcon(label) {
    return /* @__PURE__ */ jsxs("span", { className: clsx(clsIconTextWrapper, "gap-1px"), children: [
      label,
      /* @__PURE__ */ jsx$1(IconForAsc, { className: "size-16px" })
    ] });
  }
  function mitt(n2) {
    return { all: n2 = n2 || /* @__PURE__ */ new Map(), on: function(t2, e2) {
      var i2 = n2.get(t2);
      i2 ? i2.push(e2) : n2.set(t2, [e2]);
    }, off: function(t2, e2) {
      var i2 = n2.get(t2);
      i2 && (e2 ? i2.splice(i2.indexOf(e2) >>> 0, 1) : n2.set(t2, []));
    }, emit: function(t2, e2) {
      var i2 = n2.get(t2);
      i2 && i2.slice().map(function(n3) {
        n3(e2);
      }), (i2 = n2.get("*")) && i2.slice().map(function(n3) {
        n3(t2, e2);
      });
    } };
  }
  const materialSymbolsLightOpenInNewOff = (props, ref) => /* @__PURE__ */ jsx$1("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref, ...props, children: /* @__PURE__ */ jsx$1("path", { fill: "currentColor", d: "m19.833 21.26l-1.298-1.298q-.096.019-.173.029q-.077.009-.173.009H5.616q-.691 0-1.153-.462T4 18.384V5.813q0-.096.01-.173t.029-.173l-1.299-1.3l.713-.713l17.092 17.092zM5.616 19h11.957l-5.933-5.933l-1.902 1.902l-.707-.708l1.902-1.902L5 6.427v11.958q0 .23.192.423t.423.192M7.813 5l-1-1h4.419v1zm5.948 5.948l-.708-.707L18.292 5H14V4h6v6h-1V5.708zm6.24 6.24l-1-1V12.77h1z" }) });
  const ForwardRef$M = H.forwardRef(materialSymbolsLightOpenInNewOff);
  const riFullscreenFill = (props, ref) => /* @__PURE__ */ jsx$1("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref, ...props, children: /* @__PURE__ */ jsx$1("path", { fill: "currentColor", d: "M16 3h6v6h-2V5h-4zM2 3h6v2H4v4H2zm18 16v-4h2v6h-6v-2zM4 19h4v2H2v-6h2z" }) });
  const ForwardRef$L = H.forwardRef(riFullscreenFill);
  const akarIconsMiniplayer = (props, ref) => /* @__PURE__ */ jsx$1("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref, ...props, children: /* @__PURE__ */ jsxs("g", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, children: [
    /* @__PURE__ */ jsx$1("rect", { width: 20, height: 16, x: 2, y: 4, rx: 2 }),
    /* @__PURE__ */ jsx$1("rect", { width: 9, height: 7, x: 13, y: 13, rx: 2 })
  ] }) });
  const ForwardRef$K = H.forwardRef(akarIconsMiniplayer);
  const eosIconsBackgroundTasks = (props, ref) => /* @__PURE__ */ jsxs("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref, ...props, children: [
    /* @__PURE__ */ jsx$1("path", { fill: "currentColor", d: "M6 3h8.99v1.5H6zM2.99 6h1.5v1.5h-1.5zm0-3h1.5v1.5h-1.5zm0 6.01H4.5v1.5H2.99z" }),
    /* @__PURE__ */ jsx$1("path", { fill: "currentColor", d: "M4.5 12h-3V1.49h15V6H18V2a2 2 0 0 0-2-2H2a2 2 0 0 0-2 2v9.48a2 2 0 0 0 2 2h2.5Z" }),
    /* @__PURE__ */ jsx$1("path", { fill: "currentColor", d: "M22 7.5H8a2 2 0 0 0-2 2V19a2 2 0 0 0 2 2h5.53v1.53H12V24h6v-1.49h-1.5V21H22a2 2 0 0 0 2-2V9.5a2 2 0 0 0-2-2m.51 12h-15V9h15Z" })
  ] });
  const ForwardRef$J = H.forwardRef(eosIconsBackgroundTasks);
  const STAT_NUMBER_FALLBACK = "0";
  function copyContent(content) {
    GM.setClipboard(content);
    antMessage.success(`已复制: ${content}`);
  }
  var QueryKey = ((QueryKey2) => {
    QueryKey2["PlayerScreenMode"] = `${APP_SHORT_PREFIX}-player-screen-mode`;
    QueryKey2["ForceAutoPlay"] = `${APP_SHORT_PREFIX}-force-auto-play`;
    return QueryKey2;
  })(QueryKey || {});
  var PlayerScreenMode = /* @__PURE__ */ ((PlayerScreenMode2) => {
    PlayerScreenMode2["Normal"] = "normal";
    PlayerScreenMode2["Wide"] = "wide";
    PlayerScreenMode2["WebFullscreen"] = "web";
    PlayerScreenMode2["Fullscreen"] = "full";
    return PlayerScreenMode2;
  })(PlayerScreenMode || {});
  var ForceAutoPlay = /* @__PURE__ */ ((ForceAutoPlay2) => {
    ForceAutoPlay2["ON"] = "on";
    ForceAutoPlay2["OFF"] = "off";
    return ForceAutoPlay2;
  })(ForceAutoPlay || {});
  var VideoLinkOpenMode = /* @__PURE__ */ ((VideoLinkOpenMode2) => {
    VideoLinkOpenMode2["Normal"] = "Normal";
    VideoLinkOpenMode2["CurrentPage"] = "CurrentPage";
    VideoLinkOpenMode2["NormalWebFullscreen"] = "NormalWebFullscreen";
    VideoLinkOpenMode2["Popup"] = "Popup";
    VideoLinkOpenMode2["Background"] = "Background";
    VideoLinkOpenMode2["Iina"] = "Iina";
    return VideoLinkOpenMode2;
  })(VideoLinkOpenMode || {});
  const VideoLinkOpenModeKey = Object.entries(VideoLinkOpenMode).reduce((record, [key, value]) => {
    return {
      ...record,
      [value]: `LinkOpenMode.${key}`
    };
  }, {});
  const VideoLinkOpenModeConfig = {
    [
      "Normal"
      /* Normal */
    ]: {
      icon: /* @__PURE__ */ jsx$1(IconForOpenExternalLink, { className: "size-16px" }),
      label: "打开",
      desc: "默认在新标签页中打开"
    },
    [
      "CurrentPage"
      /* CurrentPage */
    ]: {
      icon: /* @__PURE__ */ jsx$1(ForwardRef$M, { className: "size-16px" }),
      label: "当前页中打开",
      desc: "不打开新标签页, 使用当前标签页打开, 适用于将网站作为应用安装场景"
    },
    [
      "NormalWebFullscreen"
      /* NormalWebFullscreen */
    ]: {
      icon: /* @__PURE__ */ jsx$1(ForwardRef$L, { className: "size-15px" }),
      label: "打开-网页全屏",
      desc: /* @__PURE__ */ jsx$1(Fragment, { children: "默认在新标签页中打开, 打开后自动网页全屏" })
    },
    [
      "Popup"
      /* Popup */
    ]: {
      icon: /* @__PURE__ */ jsx$1(ForwardRef$K, { className: "size-15px" }),
      label: "小窗打开",
      desc: /* @__PURE__ */ jsxs(Fragment, { children: [
        "当",
        " ",
        /* @__PURE__ */ jsx$1("a", { href: "https://developer.chrome.com/docs/web-platform/document-picture-in-picture", target: "_blank", children: "「文档画中画」API" }),
        " ",
        "可用时, 会使用「文档画中画」的形式: 窗口置顶 + 播放页网页全屏.",
        /* @__PURE__ */ jsx$1("br", {}),
        "当该 API 不可用时, 会使用 popup window + 播放页网页全屏 的形式."
      ] })
    },
    [
      "Background"
      /* Background */
    ]: {
      icon: /* @__PURE__ */ jsx$1(ForwardRef$J, { className: "size-15px" }),
      label: "后台打开"
    },
    [
      "Iina"
      /* Iina */
    ]: {
      icon: /* @__PURE__ */ jsx$1(IconForPlayer, { className: "size-15px" }),
      label: "在 IINA 中打开",
      enabled: isMac,
      desc: /* @__PURE__ */ jsx$1(Fragment, { children: /* @__PURE__ */ jsx$1("a", { href: "https://github.com/magicdawn/bilibili-gate/blob/main/notes/iina.md", target: "_blank", children: "macOS IINA 设置教程" }) })
    }
  };
  function createVideoCardEmitter() {
    return mitt();
  }
  function createSharedEmitter() {
    return mitt();
  }
  const defaultEmitter = createVideoCardEmitter();
  const defaultSharedEmitter = createSharedEmitter();
  var ECardDisplay = /* @__PURE__ */ ((ECardDisplay2) => {
    ECardDisplay2["Grid"] = "grid";
    ECardDisplay2["List"] = "list";
    return ECardDisplay2;
  })(ECardDisplay || {});
  const displayAsListCss = {
    card: {
      name: "18iuzk9",
      styles: "grid-column:1/-1"
    },
    cardWrap: {
      name: "k9oiqw",
      styles: "display:flex;column-gap:20px"
    },
    cover: {
      name: "12x64ox",
      styles: "width:20%"
    }
  };
  function isDisplayAsList(cardDisplay) {
    return cardDisplay === "list";
  }
  const zIndexWatchlaterProgressBar = 2;
  const zIndexPreviewImageWrapper = 3;
  const zIndexMultiSelectBg = 4;
  const zIndexLeftMarks = 5;
  const zIndexRightActions = 6;
  var EAppApiDevice = /* @__PURE__ */ ((EAppApiDevice2) => {
    EAppApiDevice2["android"] = "android";
    EAppApiDevice2["ipad"] = "ipad";
    return EAppApiDevice2;
  })(EAppApiDevice || {});
  var EApiType = /* @__PURE__ */ ((EApiType2) => {
    EApiType2["Separator"] = "separator";
    EApiType2["AppRecommend"] = "app-recommend";
    EApiType2["PcRecommend"] = "pc-recommend";
    EApiType2["DynamicFeed"] = "dynamic-feed";
    EApiType2["Watchlater"] = "watchlater";
    EApiType2["Fav"] = "fav";
    EApiType2["PopularGeneral"] = "popular-general";
    EApiType2["PopularWeekly"] = "popular-weekly";
    EApiType2["Rank"] = "ranking";
    EApiType2["Live"] = "live";
    EApiType2["SpaceUpload"] = "space-upload";
    return EApiType2;
  })(EApiType || {});
  var WatchlaterItemsOrder = /* @__PURE__ */ ((WatchlaterItemsOrder2) => {
    WatchlaterItemsOrder2["AddTimeDesc"] = "add-time-desc";
    WatchlaterItemsOrder2["AddTimeAsc"] = "add-time-asc";
    WatchlaterItemsOrder2["Shuffle"] = "shuffle";
    return WatchlaterItemsOrder2;
  })(WatchlaterItemsOrder || {});
  function getPaths(obj, parentPath = "", result = []) {
    if (parentPath) {
      result.push(parentPath);
    }
    for (const key in obj) {
      if (!Object.prototype.hasOwnProperty.call(obj, key)) continue;
      const value = obj[key];
      const currentPath = parentPath ? `${parentPath}.${key}` : key;
      result.push(currentPath);
      if (value && typeof value === "object" && !Array.isArray(value) && // 如果是数组，不再递归处理
      !(value instanceof Date) && !(value instanceof RegExp)) {
        getPaths(value, currentPath, result);
      }
    }
    return [...new Set(result)];
  }
  function getObjectPaths(obj, parentPath = "") {
    const result = [];
    if (parentPath) {
      result.push(parentPath);
    }
    for (const key in obj) {
      if (!Object.prototype.hasOwnProperty.call(obj, key)) continue;
      const value = obj[key];
      const currentPath = parentPath ? `${parentPath}.${key}` : key;
      if (value && typeof value === "object" && !Array.isArray(value) && !(value instanceof Date) && !(value instanceof RegExp) && Object.getPrototypeOf(value) === Object.prototype) {
        result.push(currentPath);
        result.push(...getObjectPaths(value, currentPath));
      }
    }
    return [...new Set(result)];
  }
  function getLeafPaths(obj) {
    const allPaths = getPaths(obj);
    const objPaths = getObjectPaths(obj);
    return allPaths.filter((p2) => !objPaths.includes(p2));
  }
  const appColorPrimaryId = "--bilibili-gate--color-primary";
  const appBorderColorId = "--bilibili-gate--border-color";
  const appCustomFontId = "--bilibili-gate--font";
  const appVideoCardBorderRadiusId = "--bilibili-gate--video-card--border-radius";
  const appBgId = "--bilibili-gate--bg";
  const appBgLv1Id = "--bilibili-gate--bg--lv1";
  const appBgLv2Id = "--bilibili-gate--bg--lv2";
  const appBgLv3Id = "--bilibili-gate--bg--lv3";
  const biliPink = "#ff6699";
  const appCustomFontValue = '"Alibaba PuHuiTi 3.0", "PingFang SC", HarmonyOS_Regular, "Helvetica Neue", "Microsoft YaHei", sans-serif';
  const appUsingFont = "var(--custom-font-family--options--font-family, var(--bilibili-gate--font))";
  const appClsRoot = "bilibili-gate-root";
  const appClsDark = "bilibili-gate-dark";
  const appClsDarkSelector = "html.bilibili-gate-dark";
  const appClsColorPrimary = "bilibili-gate-color-primary";
  const zIndexRecHeader = "1001";
  const zIndexBaseModal = "10003";
  const zIndexAntdPopupBase = "11000";
  const zIndexVideoCardLargePreview = "11200";
  const zIndexVideoCardContextMenu = "11300";
  const zIndexToast = "90000";
  const cssVars = {
    appColorPrimaryId,
    appBorderColorId,
    appCustomFontId,
    appVideoCardBorderRadiusId,
    appBgId,
    appBgLv1Id,
    appBgLv2Id,
    appBgLv3Id,
    biliPink,
    appCustomFontValue,
    appUsingFont,
    appClsRoot,
    appClsDark,
    appClsDarkSelector,
    appClsColorPrimary,
    zIndexRecHeader,
    zIndexBaseModal,
    zIndexAntdPopupBase,
    zIndexVideoCardLargePreview,
    zIndexVideoCardContextMenu,
    zIndexToast
  };
  const debug$g = baseDebug.extend("components:css-vars");
  debug$g(":export = %O", cssVars);
  const cssVar = (id) => {
    if (!id.startsWith("--")) id = `--${id}`;
    return `var(${id})`;
  };
  const colorPrimaryValue = cssVar(cssVars.appColorPrimaryId);
  const borderColorValue = cssVar(cssVars.appBorderColorId);
  const videoCardBorderRadiusValue = cssVar(cssVars.appVideoCardBorderRadiusId);
  const bgValue = cssVar(cssVars.appBgId);
  const bgLv1Value = cssVar(cssVars.appBgLv1Id);
  const bgLv2Value = cssVar(cssVars.appBgLv2Id);
  const bgLv3Value = cssVar(cssVars.appBgLv3Id);
  function insertWithoutScoping(cache2, serialized) {
    if (cache2.inserted[serialized.name] === void 0) {
      return cache2.insert("", serialized, cache2.sheet, true);
    }
  }
  function merge(registered, css2, className) {
    var registeredStyles = [];
    var rawClassName = getRegisteredStyles(registered, registeredStyles, className);
    if (registeredStyles.length < 2) {
      return className;
    }
    return rawClassName + css2(registeredStyles);
  }
  var createEmotion = function createEmotion2(options) {
    var cache2 = createCache(options);
    cache2.sheet.speedy = function(value) {
      this.isSpeedy = value;
    };
    cache2.compat = true;
    var css2 = function css3() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      var serialized = serializeStyles(args, cache2.registered, void 0);
      insertStyles(cache2, serialized, false);
      return cache2.key + "-" + serialized.name;
    };
    var keyframes = function keyframes2() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      var serialized = serializeStyles(args, cache2.registered);
      var animation = "animation-" + serialized.name;
      insertWithoutScoping(cache2, {
        name: serialized.name,
        styles: "@keyframes " + animation + "{" + serialized.styles + "}"
      });
      return animation;
    };
    var injectGlobal = function injectGlobal2() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      var serialized = serializeStyles(args, cache2.registered);
      insertWithoutScoping(cache2, serialized);
    };
    var cx = function cx2() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      return merge(cache2.registered, css2, classnames(args));
    };
    return {
      css: css2,
      cx,
      injectGlobal,
      keyframes,
      hydrate: function hydrate(ids2) {
        ids2.forEach(function(key) {
          cache2.inserted[key] = true;
        });
      },
      flush: function flush() {
        cache2.registered = {};
        cache2.inserted = {};
        cache2.sheet.flush();
      },
      sheet: cache2.sheet,
      cache: cache2,
      getRegisteredStyles: getRegisteredStyles.bind(null, cache2.registered),
      merge: merge.bind(null, cache2.registered, css2)
    };
  };
  var classnames = function classnames2(args) {
    var cls = "";
    for (var i2 = 0; i2 < args.length; i2++) {
      var arg = args[i2];
      if (arg == null) continue;
      var toAdd = void 0;
      switch (typeof arg) {
        case "boolean":
          break;
        case "object": {
          if (Array.isArray(arg)) {
            toAdd = classnames2(arg);
          } else {
            toAdd = "";
            for (var k in arg) {
              if (arg[k] && k) {
                toAdd && (toAdd += " ");
                toAdd += k;
              }
            }
          }
          break;
        }
        default: {
          toAdd = arg;
        }
      }
      if (toAdd) {
        cls && (cls += " ");
        cls += toAdd;
      }
    }
    return cls;
  };
  var _createEmotion = createEmotion({
    key: "css"
  }), css$1 = _createEmotion.css, cache$4 = _createEmotion.cache;
  const toastContainer = /* @__PURE__ */ css$1("position:fixed;top:50%;left:50%;transform:translate(-50%, -50%);z-index:", zIndexToast, ";padding:12px 24px;font-size:14px;min-width:200px;width:max-content;max-width:450px;color:#fff;background-color:#ffb243;background-color:", colorPrimaryValue, ";border-radius:6px;white-space:pre-wrap;", "");
  const singleLine = /* @__PURE__ */ css$1({
    name: "1azakc",
    styles: "text-align:center"
  });
  function toast(msg, duration2 = 2e3, container = document.body) {
    const div = document.createElement("div");
    div.classList.add(toastContainer, APP_CLS_ROOT);
    div.innerText = msg;
    if (!msg.includes("\n") && !msg.includes("<br")) {
      div.classList.add(singleLine);
    }
    container.appendChild(div);
    setTimeout(() => div.remove(), duration2);
  }
  function toastRequestFail() {
    return toast(REQUEST_FAIL_MSG);
  }
  function isDeepKey(key) {
    switch (typeof key) {
      case "number":
      case "symbol": {
        return false;
      }
      case "string": {
        return key.includes(".") || key.includes("[") || key.includes("]");
      }
    }
  }
  function toKey(value) {
    var _a2;
    if (typeof value === "string" || typeof value === "symbol") {
      return value;
    }
    if (Object.is((_a2 = value == null ? void 0 : value.valueOf) == null ? void 0 : _a2.call(value), -0)) {
      return "-0";
    }
    return String(value);
  }
  function toPath(deepKey) {
    const result = [];
    const length2 = deepKey.length;
    if (length2 === 0) {
      return result;
    }
    let index = 0;
    let key = "";
    let quoteChar = "";
    let bracket = false;
    if (deepKey.charCodeAt(0) === 46) {
      result.push("");
      index++;
    }
    while (index < length2) {
      const char2 = deepKey[index];
      if (quoteChar) {
        if (char2 === "\\" && index + 1 < length2) {
          index++;
          key += deepKey[index];
        } else if (char2 === quoteChar) {
          quoteChar = "";
        } else {
          key += char2;
        }
      } else if (bracket) {
        if (char2 === '"' || char2 === "'") {
          quoteChar = char2;
        } else if (char2 === "]") {
          bracket = false;
          result.push(key);
          key = "";
        } else {
          key += char2;
        }
      } else {
        if (char2 === "[") {
          bracket = true;
          if (key) {
            result.push(key);
            key = "";
          }
        } else if (char2 === ".") {
          if (key) {
            result.push(key);
            key = "";
          }
        } else {
          key += char2;
        }
      }
      index++;
    }
    if (key) {
      result.push(key);
    }
    return result;
  }
  function get(object, path2, defaultValue2) {
    if (object == null) {
      return defaultValue2;
    }
    switch (typeof path2) {
      case "string": {
        const result = object[path2];
        if (result === void 0) {
          if (isDeepKey(path2)) {
            return get(object, toPath(path2), defaultValue2);
          } else {
            return defaultValue2;
          }
        }
        return result;
      }
      case "number":
      case "symbol": {
        if (typeof path2 === "number") {
          path2 = toKey(path2);
        }
        const result = object[path2];
        if (result === void 0) {
          return defaultValue2;
        }
        return result;
      }
      default: {
        if (Array.isArray(path2)) {
          return getWithPath(object, path2, defaultValue2);
        }
        if (Object.is(path2 == null ? void 0 : path2.valueOf(), -0)) {
          path2 = "-0";
        } else {
          path2 = String(path2);
        }
        const result = object[path2];
        if (result === void 0) {
          return defaultValue2;
        }
        return result;
      }
    }
  }
  function getWithPath(object, path2, defaultValue2) {
    if (path2.length === 0) {
      return defaultValue2;
    }
    let current = object;
    for (let index = 0; index < path2.length; index++) {
      if (current == null) {
        return defaultValue2;
      }
      current = current[path2[index]];
    }
    if (current === void 0) {
      return defaultValue2;
    }
    return current;
  }
  function isObject(value) {
    return value !== null && (typeof value === "object" || typeof value === "function");
  }
  const IS_UNSIGNED_INTEGER = /^(?:0|[1-9]\d*)$/;
  function isIndex(value, length2 = Number.MAX_SAFE_INTEGER) {
    switch (typeof value) {
      case "number": {
        return Number.isInteger(value) && value >= 0 && value < length2;
      }
      case "symbol": {
        return false;
      }
      case "string": {
        return IS_UNSIGNED_INTEGER.test(value);
      }
    }
  }
  const regexIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
  const regexIsPlainProp = /^\w*$/;
  function isKey(value, object) {
    if (Array.isArray(value)) {
      return false;
    }
    if (typeof value === "number" || typeof value === "boolean" || value == null || isSymbol(value)) {
      return true;
    }
    return typeof value === "string" && (regexIsPlainProp.test(value) || !regexIsDeepProp.test(value)) || object != null && Object.hasOwn(object, value);
  }
  const assignValue = (object, key, value) => {
    const objValue = object[key];
    if (!(Object.hasOwn(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
      object[key] = value;
    }
  };
  function updateWith(obj, path2, updater, customizer) {
    if (obj == null && !isObject(obj)) {
      return obj;
    }
    const resolvedPath = isKey(path2, obj) ? [path2] : Array.isArray(path2) ? path2 : typeof path2 === "string" ? toPath(path2) : [path2];
    let current = obj;
    for (let i2 = 0; i2 < resolvedPath.length && current != null; i2++) {
      const key = toKey(resolvedPath[i2]);
      let newValue;
      if (i2 === resolvedPath.length - 1) {
        newValue = updater(current[key]);
      } else {
        const objValue = current[key];
        const customizerResult = customizer(objValue);
        newValue = customizerResult !== void 0 ? customizerResult : isObject(objValue) ? objValue : isIndex(resolvedPath[i2 + 1]) ? [] : {};
      }
      assignValue(current, key, newValue);
      current = current[key];
    }
    return obj;
  }
  function set(obj, path2, value) {
    return updateWith(obj, path2, () => value, () => void 0);
  }
  function times(n2, getValue) {
    n2 = toInteger(n2);
    if (n2 < 1 || !Number.isSafeInteger(n2)) {
      return [];
    }
    const result = new Array(n2);
    for (let i2 = 0; i2 < n2; i2++) {
      result[i2] = typeof getValue === "function" ? getValue(i2) : i2;
    }
    return result;
  }
  var msExports = requireMs();
  const ms = /* @__PURE__ */ getDefaultExportFromCjs(msExports);
  const genDate = () => dayjs().format("YYYY-MM-DD");
  function dailyCache(namespace) {
    async function cleanUp() {
      const date = genDate();
      const keys = await GM.listValues();
      keys.filter((k) => k.startsWith(namespace + ":") && k !== namespace + ":" + date).forEach((k) => GM.deleteValue(k));
    }
    cleanUp();
    return {
      async set(val) {
        cleanUp();
        await GM.setValue(namespace + ":" + genDate(), val);
      },
      async get() {
        cleanUp();
        return GM.getValue(namespace + ":" + genDate());
      }
    };
  }
  const copyProperty = (to, from2, property, ignoreNonConfigurable) => {
    if (property === "length" || property === "prototype") {
      return;
    }
    if (property === "arguments" || property === "caller") {
      return;
    }
    const toDescriptor = Object.getOwnPropertyDescriptor(to, property);
    const fromDescriptor = Object.getOwnPropertyDescriptor(from2, property);
    if (!canCopyProperty(toDescriptor, fromDescriptor) && ignoreNonConfigurable) {
      return;
    }
    Object.defineProperty(to, property, fromDescriptor);
  };
  const canCopyProperty = function(toDescriptor, fromDescriptor) {
    return toDescriptor === void 0 || toDescriptor.configurable || toDescriptor.writable === fromDescriptor.writable && toDescriptor.enumerable === fromDescriptor.enumerable && toDescriptor.configurable === fromDescriptor.configurable && (toDescriptor.writable || toDescriptor.value === fromDescriptor.value);
  };
  const changePrototype = (to, from2) => {
    const fromPrototype = Object.getPrototypeOf(from2);
    if (fromPrototype === Object.getPrototypeOf(to)) {
      return;
    }
    Object.setPrototypeOf(to, fromPrototype);
  };
  const wrappedToString = (withName, fromBody) => `/* Wrapped ${withName}*/
${fromBody}`;
  const toStringDescriptor = Object.getOwnPropertyDescriptor(Function.prototype, "toString");
  const toStringName = Object.getOwnPropertyDescriptor(Function.prototype.toString, "name");
  const changeToString = (to, from2, name) => {
    const withName = name === "" ? "" : `with ${name.trim()}() `;
    const newToString = wrappedToString.bind(null, withName, from2.toString());
    Object.defineProperty(newToString, "name", toStringName);
    Object.defineProperty(to, "toString", { ...toStringDescriptor, value: newToString });
  };
  function mimicFunction(to, from2, { ignoreNonConfigurable = false } = {}) {
    const { name } = to;
    for (const property of Reflect.ownKeys(from2)) {
      copyProperty(to, from2, property, ignoreNonConfigurable);
    }
    changePrototype(to, from2);
    changeToString(to, from2, name);
    return to;
  }
  const cacheStore = /* @__PURE__ */ new WeakMap();
  function pMemoize(fn, { cacheKey: cacheKey2 = ([firstArgument]) => firstArgument, cache: cache2 = /* @__PURE__ */ new Map() } = {}) {
    const promiseCache = /* @__PURE__ */ new Map();
    const memoized = function(...arguments_) {
      const key = cacheKey2(arguments_);
      if (promiseCache.has(key)) {
        return promiseCache.get(key);
      }
      const promise = (async () => {
        try {
          if (cache2 && await cache2.has(key)) {
            return await cache2.get(key);
          }
          const promise2 = fn.apply(this, arguments_);
          const result = await promise2;
          try {
            return result;
          } finally {
            if (cache2) {
              await cache2.set(key, result);
            }
          }
        } finally {
          promiseCache.delete(key);
        }
      })();
      promiseCache.set(key, promise);
      return promise;
    };
    mimicFunction(memoized, fn, {
      ignoreNonConfigurable: true
    });
    cacheStore.set(memoized, cache2);
    return memoized;
  }
  function reusePendingPromise(fn, generateKey) {
    generateKey ?? (generateKey = (...args) => JSON.stringify(args));
    return pMemoize(fn, {
      cache: false,
      cacheKey(args) {
        return generateKey(...args);
      }
    });
  }
  var sparkMd5 = { exports: {} };
  var hasRequiredSparkMd5;
  function requireSparkMd5() {
    if (hasRequiredSparkMd5) return sparkMd5.exports;
    hasRequiredSparkMd5 = 1;
    (function(module, exports) {
      (function(factory) {
        {
          module.exports = factory();
        }
      })(function(undefined$1) {
        var hex_chr = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
        function md5cycle(x, k) {
          var a2 = x[0], b = x[1], c2 = x[2], d2 = x[3];
          a2 += (b & c2 | ~b & d2) + k[0] - 680876936 | 0;
          a2 = (a2 << 7 | a2 >>> 25) + b | 0;
          d2 += (a2 & b | ~a2 & c2) + k[1] - 389564586 | 0;
          d2 = (d2 << 12 | d2 >>> 20) + a2 | 0;
          c2 += (d2 & a2 | ~d2 & b) + k[2] + 606105819 | 0;
          c2 = (c2 << 17 | c2 >>> 15) + d2 | 0;
          b += (c2 & d2 | ~c2 & a2) + k[3] - 1044525330 | 0;
          b = (b << 22 | b >>> 10) + c2 | 0;
          a2 += (b & c2 | ~b & d2) + k[4] - 176418897 | 0;
          a2 = (a2 << 7 | a2 >>> 25) + b | 0;
          d2 += (a2 & b | ~a2 & c2) + k[5] + 1200080426 | 0;
          d2 = (d2 << 12 | d2 >>> 20) + a2 | 0;
          c2 += (d2 & a2 | ~d2 & b) + k[6] - 1473231341 | 0;
          c2 = (c2 << 17 | c2 >>> 15) + d2 | 0;
          b += (c2 & d2 | ~c2 & a2) + k[7] - 45705983 | 0;
          b = (b << 22 | b >>> 10) + c2 | 0;
          a2 += (b & c2 | ~b & d2) + k[8] + 1770035416 | 0;
          a2 = (a2 << 7 | a2 >>> 25) + b | 0;
          d2 += (a2 & b | ~a2 & c2) + k[9] - 1958414417 | 0;
          d2 = (d2 << 12 | d2 >>> 20) + a2 | 0;
          c2 += (d2 & a2 | ~d2 & b) + k[10] - 42063 | 0;
          c2 = (c2 << 17 | c2 >>> 15) + d2 | 0;
          b += (c2 & d2 | ~c2 & a2) + k[11] - 1990404162 | 0;
          b = (b << 22 | b >>> 10) + c2 | 0;
          a2 += (b & c2 | ~b & d2) + k[12] + 1804603682 | 0;
          a2 = (a2 << 7 | a2 >>> 25) + b | 0;
          d2 += (a2 & b | ~a2 & c2) + k[13] - 40341101 | 0;
          d2 = (d2 << 12 | d2 >>> 20) + a2 | 0;
          c2 += (d2 & a2 | ~d2 & b) + k[14] - 1502002290 | 0;
          c2 = (c2 << 17 | c2 >>> 15) + d2 | 0;
          b += (c2 & d2 | ~c2 & a2) + k[15] + 1236535329 | 0;
          b = (b << 22 | b >>> 10) + c2 | 0;
          a2 += (b & d2 | c2 & ~d2) + k[1] - 165796510 | 0;
          a2 = (a2 << 5 | a2 >>> 27) + b | 0;
          d2 += (a2 & c2 | b & ~c2) + k[6] - 1069501632 | 0;
          d2 = (d2 << 9 | d2 >>> 23) + a2 | 0;
          c2 += (d2 & b | a2 & ~b) + k[11] + 643717713 | 0;
          c2 = (c2 << 14 | c2 >>> 18) + d2 | 0;
          b += (c2 & a2 | d2 & ~a2) + k[0] - 373897302 | 0;
          b = (b << 20 | b >>> 12) + c2 | 0;
          a2 += (b & d2 | c2 & ~d2) + k[5] - 701558691 | 0;
          a2 = (a2 << 5 | a2 >>> 27) + b | 0;
          d2 += (a2 & c2 | b & ~c2) + k[10] + 38016083 | 0;
          d2 = (d2 << 9 | d2 >>> 23) + a2 | 0;
          c2 += (d2 & b | a2 & ~b) + k[15] - 660478335 | 0;
          c2 = (c2 << 14 | c2 >>> 18) + d2 | 0;
          b += (c2 & a2 | d2 & ~a2) + k[4] - 405537848 | 0;
          b = (b << 20 | b >>> 12) + c2 | 0;
          a2 += (b & d2 | c2 & ~d2) + k[9] + 568446438 | 0;
          a2 = (a2 << 5 | a2 >>> 27) + b | 0;
          d2 += (a2 & c2 | b & ~c2) + k[14] - 1019803690 | 0;
          d2 = (d2 << 9 | d2 >>> 23) + a2 | 0;
          c2 += (d2 & b | a2 & ~b) + k[3] - 187363961 | 0;
          c2 = (c2 << 14 | c2 >>> 18) + d2 | 0;
          b += (c2 & a2 | d2 & ~a2) + k[8] + 1163531501 | 0;
          b = (b << 20 | b >>> 12) + c2 | 0;
          a2 += (b & d2 | c2 & ~d2) + k[13] - 1444681467 | 0;
          a2 = (a2 << 5 | a2 >>> 27) + b | 0;
          d2 += (a2 & c2 | b & ~c2) + k[2] - 51403784 | 0;
          d2 = (d2 << 9 | d2 >>> 23) + a2 | 0;
          c2 += (d2 & b | a2 & ~b) + k[7] + 1735328473 | 0;
          c2 = (c2 << 14 | c2 >>> 18) + d2 | 0;
          b += (c2 & a2 | d2 & ~a2) + k[12] - 1926607734 | 0;
          b = (b << 20 | b >>> 12) + c2 | 0;
          a2 += (b ^ c2 ^ d2) + k[5] - 378558 | 0;
          a2 = (a2 << 4 | a2 >>> 28) + b | 0;
          d2 += (a2 ^ b ^ c2) + k[8] - 2022574463 | 0;
          d2 = (d2 << 11 | d2 >>> 21) + a2 | 0;
          c2 += (d2 ^ a2 ^ b) + k[11] + 1839030562 | 0;
          c2 = (c2 << 16 | c2 >>> 16) + d2 | 0;
          b += (c2 ^ d2 ^ a2) + k[14] - 35309556 | 0;
          b = (b << 23 | b >>> 9) + c2 | 0;
          a2 += (b ^ c2 ^ d2) + k[1] - 1530992060 | 0;
          a2 = (a2 << 4 | a2 >>> 28) + b | 0;
          d2 += (a2 ^ b ^ c2) + k[4] + 1272893353 | 0;
          d2 = (d2 << 11 | d2 >>> 21) + a2 | 0;
          c2 += (d2 ^ a2 ^ b) + k[7] - 155497632 | 0;
          c2 = (c2 << 16 | c2 >>> 16) + d2 | 0;
          b += (c2 ^ d2 ^ a2) + k[10] - 1094730640 | 0;
          b = (b << 23 | b >>> 9) + c2 | 0;
          a2 += (b ^ c2 ^ d2) + k[13] + 681279174 | 0;
          a2 = (a2 << 4 | a2 >>> 28) + b | 0;
          d2 += (a2 ^ b ^ c2) + k[0] - 358537222 | 0;
          d2 = (d2 << 11 | d2 >>> 21) + a2 | 0;
          c2 += (d2 ^ a2 ^ b) + k[3] - 722521979 | 0;
          c2 = (c2 << 16 | c2 >>> 16) + d2 | 0;
          b += (c2 ^ d2 ^ a2) + k[6] + 76029189 | 0;
          b = (b << 23 | b >>> 9) + c2 | 0;
          a2 += (b ^ c2 ^ d2) + k[9] - 640364487 | 0;
          a2 = (a2 << 4 | a2 >>> 28) + b | 0;
          d2 += (a2 ^ b ^ c2) + k[12] - 421815835 | 0;
          d2 = (d2 << 11 | d2 >>> 21) + a2 | 0;
          c2 += (d2 ^ a2 ^ b) + k[15] + 530742520 | 0;
          c2 = (c2 << 16 | c2 >>> 16) + d2 | 0;
          b += (c2 ^ d2 ^ a2) + k[2] - 995338651 | 0;
          b = (b << 23 | b >>> 9) + c2 | 0;
          a2 += (c2 ^ (b | ~d2)) + k[0] - 198630844 | 0;
          a2 = (a2 << 6 | a2 >>> 26) + b | 0;
          d2 += (b ^ (a2 | ~c2)) + k[7] + 1126891415 | 0;
          d2 = (d2 << 10 | d2 >>> 22) + a2 | 0;
          c2 += (a2 ^ (d2 | ~b)) + k[14] - 1416354905 | 0;
          c2 = (c2 << 15 | c2 >>> 17) + d2 | 0;
          b += (d2 ^ (c2 | ~a2)) + k[5] - 57434055 | 0;
          b = (b << 21 | b >>> 11) + c2 | 0;
          a2 += (c2 ^ (b | ~d2)) + k[12] + 1700485571 | 0;
          a2 = (a2 << 6 | a2 >>> 26) + b | 0;
          d2 += (b ^ (a2 | ~c2)) + k[3] - 1894986606 | 0;
          d2 = (d2 << 10 | d2 >>> 22) + a2 | 0;
          c2 += (a2 ^ (d2 | ~b)) + k[10] - 1051523 | 0;
          c2 = (c2 << 15 | c2 >>> 17) + d2 | 0;
          b += (d2 ^ (c2 | ~a2)) + k[1] - 2054922799 | 0;
          b = (b << 21 | b >>> 11) + c2 | 0;
          a2 += (c2 ^ (b | ~d2)) + k[8] + 1873313359 | 0;
          a2 = (a2 << 6 | a2 >>> 26) + b | 0;
          d2 += (b ^ (a2 | ~c2)) + k[15] - 30611744 | 0;
          d2 = (d2 << 10 | d2 >>> 22) + a2 | 0;
          c2 += (a2 ^ (d2 | ~b)) + k[6] - 1560198380 | 0;
          c2 = (c2 << 15 | c2 >>> 17) + d2 | 0;
          b += (d2 ^ (c2 | ~a2)) + k[13] + 1309151649 | 0;
          b = (b << 21 | b >>> 11) + c2 | 0;
          a2 += (c2 ^ (b | ~d2)) + k[4] - 145523070 | 0;
          a2 = (a2 << 6 | a2 >>> 26) + b | 0;
          d2 += (b ^ (a2 | ~c2)) + k[11] - 1120210379 | 0;
          d2 = (d2 << 10 | d2 >>> 22) + a2 | 0;
          c2 += (a2 ^ (d2 | ~b)) + k[2] + 718787259 | 0;
          c2 = (c2 << 15 | c2 >>> 17) + d2 | 0;
          b += (d2 ^ (c2 | ~a2)) + k[9] - 343485551 | 0;
          b = (b << 21 | b >>> 11) + c2 | 0;
          x[0] = a2 + x[0] | 0;
          x[1] = b + x[1] | 0;
          x[2] = c2 + x[2] | 0;
          x[3] = d2 + x[3] | 0;
        }
        function md5blk(s2) {
          var md5blks = [], i2;
          for (i2 = 0; i2 < 64; i2 += 4) {
            md5blks[i2 >> 2] = s2.charCodeAt(i2) + (s2.charCodeAt(i2 + 1) << 8) + (s2.charCodeAt(i2 + 2) << 16) + (s2.charCodeAt(i2 + 3) << 24);
          }
          return md5blks;
        }
        function md5blk_array(a2) {
          var md5blks = [], i2;
          for (i2 = 0; i2 < 64; i2 += 4) {
            md5blks[i2 >> 2] = a2[i2] + (a2[i2 + 1] << 8) + (a2[i2 + 2] << 16) + (a2[i2 + 3] << 24);
          }
          return md5blks;
        }
        function md51(s2) {
          var n2 = s2.length, state2 = [1732584193, -271733879, -1732584194, 271733878], i2, length2, tail, tmp, lo, hi;
          for (i2 = 64; i2 <= n2; i2 += 64) {
            md5cycle(state2, md5blk(s2.substring(i2 - 64, i2)));
          }
          s2 = s2.substring(i2 - 64);
          length2 = s2.length;
          tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
          for (i2 = 0; i2 < length2; i2 += 1) {
            tail[i2 >> 2] |= s2.charCodeAt(i2) << (i2 % 4 << 3);
          }
          tail[i2 >> 2] |= 128 << (i2 % 4 << 3);
          if (i2 > 55) {
            md5cycle(state2, tail);
            for (i2 = 0; i2 < 16; i2 += 1) {
              tail[i2] = 0;
            }
          }
          tmp = n2 * 8;
          tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
          lo = parseInt(tmp[2], 16);
          hi = parseInt(tmp[1], 16) || 0;
          tail[14] = lo;
          tail[15] = hi;
          md5cycle(state2, tail);
          return state2;
        }
        function md51_array(a2) {
          var n2 = a2.length, state2 = [1732584193, -271733879, -1732584194, 271733878], i2, length2, tail, tmp, lo, hi;
          for (i2 = 64; i2 <= n2; i2 += 64) {
            md5cycle(state2, md5blk_array(a2.subarray(i2 - 64, i2)));
          }
          a2 = i2 - 64 < n2 ? a2.subarray(i2 - 64) : new Uint8Array(0);
          length2 = a2.length;
          tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
          for (i2 = 0; i2 < length2; i2 += 1) {
            tail[i2 >> 2] |= a2[i2] << (i2 % 4 << 3);
          }
          tail[i2 >> 2] |= 128 << (i2 % 4 << 3);
          if (i2 > 55) {
            md5cycle(state2, tail);
            for (i2 = 0; i2 < 16; i2 += 1) {
              tail[i2] = 0;
            }
          }
          tmp = n2 * 8;
          tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
          lo = parseInt(tmp[2], 16);
          hi = parseInt(tmp[1], 16) || 0;
          tail[14] = lo;
          tail[15] = hi;
          md5cycle(state2, tail);
          return state2;
        }
        function rhex(n2) {
          var s2 = "", j;
          for (j = 0; j < 4; j += 1) {
            s2 += hex_chr[n2 >> j * 8 + 4 & 15] + hex_chr[n2 >> j * 8 & 15];
          }
          return s2;
        }
        function hex(x) {
          var i2;
          for (i2 = 0; i2 < x.length; i2 += 1) {
            x[i2] = rhex(x[i2]);
          }
          return x.join("");
        }
        if (hex(md51("hello")) !== "5d41402abc4b2a76b9719d911017c592") ;
        if (typeof ArrayBuffer !== "undefined" && !ArrayBuffer.prototype.slice) {
          (function() {
            function clamp(val, length2) {
              val = val | 0 || 0;
              if (val < 0) {
                return Math.max(val + length2, 0);
              }
              return Math.min(val, length2);
            }
            ArrayBuffer.prototype.slice = function(from2, to) {
              var length2 = this.byteLength, begin = clamp(from2, length2), end = length2, num, target, targetArray, sourceArray;
              if (to !== undefined$1) {
                end = clamp(to, length2);
              }
              if (begin > end) {
                return new ArrayBuffer(0);
              }
              num = end - begin;
              target = new ArrayBuffer(num);
              targetArray = new Uint8Array(target);
              sourceArray = new Uint8Array(this, begin, num);
              targetArray.set(sourceArray);
              return target;
            };
          })();
        }
        function toUtf8(str) {
          if (/[\u0080-\uFFFF]/.test(str)) {
            str = unescape(encodeURIComponent(str));
          }
          return str;
        }
        function utf8Str2ArrayBuffer(str, returnUInt8Array) {
          var length2 = str.length, buff = new ArrayBuffer(length2), arr = new Uint8Array(buff), i2;
          for (i2 = 0; i2 < length2; i2 += 1) {
            arr[i2] = str.charCodeAt(i2);
          }
          return returnUInt8Array ? arr : buff;
        }
        function arrayBuffer2Utf8Str(buff) {
          return String.fromCharCode.apply(null, new Uint8Array(buff));
        }
        function concatenateArrayBuffers(first, second, returnUInt8Array) {
          var result = new Uint8Array(first.byteLength + second.byteLength);
          result.set(new Uint8Array(first));
          result.set(new Uint8Array(second), first.byteLength);
          return result;
        }
        function hexToBinaryString(hex2) {
          var bytes = [], length2 = hex2.length, x;
          for (x = 0; x < length2 - 1; x += 2) {
            bytes.push(parseInt(hex2.substr(x, 2), 16));
          }
          return String.fromCharCode.apply(String, bytes);
        }
        function SparkMD5() {
          this.reset();
        }
        SparkMD5.prototype.append = function(str) {
          this.appendBinary(toUtf8(str));
          return this;
        };
        SparkMD5.prototype.appendBinary = function(contents) {
          this._buff += contents;
          this._length += contents.length;
          var length2 = this._buff.length, i2;
          for (i2 = 64; i2 <= length2; i2 += 64) {
            md5cycle(this._hash, md5blk(this._buff.substring(i2 - 64, i2)));
          }
          this._buff = this._buff.substring(i2 - 64);
          return this;
        };
        SparkMD5.prototype.end = function(raw) {
          var buff = this._buff, length2 = buff.length, i2, tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], ret;
          for (i2 = 0; i2 < length2; i2 += 1) {
            tail[i2 >> 2] |= buff.charCodeAt(i2) << (i2 % 4 << 3);
          }
          this._finish(tail, length2);
          ret = hex(this._hash);
          if (raw) {
            ret = hexToBinaryString(ret);
          }
          this.reset();
          return ret;
        };
        SparkMD5.prototype.reset = function() {
          this._buff = "";
          this._length = 0;
          this._hash = [1732584193, -271733879, -1732584194, 271733878];
          return this;
        };
        SparkMD5.prototype.getState = function() {
          return {
            buff: this._buff,
            length: this._length,
            hash: this._hash.slice()
          };
        };
        SparkMD5.prototype.setState = function(state2) {
          this._buff = state2.buff;
          this._length = state2.length;
          this._hash = state2.hash;
          return this;
        };
        SparkMD5.prototype.destroy = function() {
          delete this._hash;
          delete this._buff;
          delete this._length;
        };
        SparkMD5.prototype._finish = function(tail, length2) {
          var i2 = length2, tmp, lo, hi;
          tail[i2 >> 2] |= 128 << (i2 % 4 << 3);
          if (i2 > 55) {
            md5cycle(this._hash, tail);
            for (i2 = 0; i2 < 16; i2 += 1) {
              tail[i2] = 0;
            }
          }
          tmp = this._length * 8;
          tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
          lo = parseInt(tmp[2], 16);
          hi = parseInt(tmp[1], 16) || 0;
          tail[14] = lo;
          tail[15] = hi;
          md5cycle(this._hash, tail);
        };
        SparkMD5.hash = function(str, raw) {
          return SparkMD5.hashBinary(toUtf8(str), raw);
        };
        SparkMD5.hashBinary = function(content, raw) {
          var hash2 = md51(content), ret = hex(hash2);
          return raw ? hexToBinaryString(ret) : ret;
        };
        SparkMD5.ArrayBuffer = function() {
          this.reset();
        };
        SparkMD5.ArrayBuffer.prototype.append = function(arr) {
          var buff = concatenateArrayBuffers(this._buff.buffer, arr), length2 = buff.length, i2;
          this._length += arr.byteLength;
          for (i2 = 64; i2 <= length2; i2 += 64) {
            md5cycle(this._hash, md5blk_array(buff.subarray(i2 - 64, i2)));
          }
          this._buff = i2 - 64 < length2 ? new Uint8Array(buff.buffer.slice(i2 - 64)) : new Uint8Array(0);
          return this;
        };
        SparkMD5.ArrayBuffer.prototype.end = function(raw) {
          var buff = this._buff, length2 = buff.length, tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], i2, ret;
          for (i2 = 0; i2 < length2; i2 += 1) {
            tail[i2 >> 2] |= buff[i2] << (i2 % 4 << 3);
          }
          this._finish(tail, length2);
          ret = hex(this._hash);
          if (raw) {
            ret = hexToBinaryString(ret);
          }
          this.reset();
          return ret;
        };
        SparkMD5.ArrayBuffer.prototype.reset = function() {
          this._buff = new Uint8Array(0);
          this._length = 0;
          this._hash = [1732584193, -271733879, -1732584194, 271733878];
          return this;
        };
        SparkMD5.ArrayBuffer.prototype.getState = function() {
          var state2 = SparkMD5.prototype.getState.call(this);
          state2.buff = arrayBuffer2Utf8Str(state2.buff);
          return state2;
        };
        SparkMD5.ArrayBuffer.prototype.setState = function(state2) {
          state2.buff = utf8Str2ArrayBuffer(state2.buff, true);
          return SparkMD5.prototype.setState.call(this, state2);
        };
        SparkMD5.ArrayBuffer.prototype.destroy = SparkMD5.prototype.destroy;
        SparkMD5.ArrayBuffer.prototype._finish = SparkMD5.prototype._finish;
        SparkMD5.ArrayBuffer.hash = function(arr, raw) {
          var hash2 = md51_array(new Uint8Array(arr)), ret = hex(hash2);
          return raw ? hexToBinaryString(ret) : ret;
        };
        return SparkMD5;
      });
    })(sparkMd5);
    return sparkMd5.exports;
  }
  var sparkMd5Exports = requireSparkMd5();
  async function encWbi(_params) {
    const {
      img_key,
      sub_key
    } = await getWbiKeys();
    const mixin_key = getMixinKey(img_key + sub_key);
    const wts = Math.round(Date.now() / 1e3);
    const params = {
      ..._params,
      wts
    };
    const chr_filter = /[!'()*]/g;
    const query = Object.keys(params).sort().map((key) => {
      return `${encodeURIComponent(key)}=${encodeURIComponent(
      // 过滤 value 中的 "!'()*" 字符
      params[key].toString().replace(chr_filter, "")
    )}`;
    }).join("&");
    const wbi_sign = sparkMd5Exports.hash(query + mixin_key);
    return {
      ...params,
      wts,
      w_rid: wbi_sign
    };
  }
  const keysCache = dailyCache("wbi-keys");
  async function getWbiKeys() {
    const cached = await keysCache.get();
    const shouldReuse = (cached == null ? void 0 : cached.val) && (cached == null ? void 0 : cached.ts) && Date.now() - cached.ts <= ms("6h");
    if (shouldReuse) return cached.val;
    return __fetchWbiKeys();
  }
  const __fetchWbiKeys = reusePendingPromise(async () => {
    const res = await axios.get("/x/web-interface/nav", {
      baseURL: HOST_API
    });
    const json = res.data;
    const img_url = json.data.wbi_img.img_url;
    const sub_url = json.data.wbi_img.sub_url;
    const keys = {
      img_key: img_url.slice(img_url.lastIndexOf("/") + 1, img_url.lastIndexOf(".")),
      sub_key: sub_url.slice(sub_url.lastIndexOf("/") + 1, sub_url.lastIndexOf("."))
    };
    await keysCache.set({
      val: keys,
      ts: Date.now()
    });
    return keys;
  });
  const mixinKeyEncTab = [46, 47, 18, 2, 53, 8, 23, 32, 15, 50, 10, 31, 58, 3, 45, 35, 27, 43, 5, 49, 33, 9, 42, 19, 29, 28, 14, 39, 12, 38, 41, 13, 37, 48, 7, 16, 24, 55, 40, 61, 26, 17, 0, 1, 60, 51, 30, 4, 22, 25, 54, 21, 56, 59, 6, 63, 57, 62, 11, 36, 20, 34, 44, 52];
  function getMixinKey(orig) {
    return mixinKeyEncTab.map((n2) => orig[n2]).join("").slice(0, 32);
  }
  function appSign(params, appkey2, appsec2) {
    params.appkey = appkey2;
    const searchParams2 = new URLSearchParams(params);
    searchParams2.sort();
    return sparkMd5Exports.hash(searchParams2.toString() + appsec2);
  }
  var isAbsoluteURL;
  var hasRequiredIsAbsoluteURL;
  function requireIsAbsoluteURL() {
    if (hasRequiredIsAbsoluteURL) return isAbsoluteURL;
    hasRequiredIsAbsoluteURL = 1;
    isAbsoluteURL = function isAbsoluteURL2(url) {
      return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
    };
    return isAbsoluteURL;
  }
  var combineURLs;
  var hasRequiredCombineURLs;
  function requireCombineURLs() {
    if (hasRequiredCombineURLs) return combineURLs;
    hasRequiredCombineURLs = 1;
    combineURLs = function combineURLs2(baseURL, relativeURL) {
      return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
    };
    return combineURLs;
  }
  var buildFullPath$1;
  var hasRequiredBuildFullPath;
  function requireBuildFullPath() {
    if (hasRequiredBuildFullPath) return buildFullPath$1;
    hasRequiredBuildFullPath = 1;
    var isAbsoluteURL2 = requireIsAbsoluteURL();
    var combineURLs2 = requireCombineURLs();
    buildFullPath$1 = function buildFullPath2(baseURL, requestedURL) {
      if (baseURL && !isAbsoluteURL2(requestedURL)) {
        return combineURLs2(baseURL, requestedURL);
      }
      return requestedURL;
    };
    return buildFullPath$1;
  }
  var buildFullPathExports = requireBuildFullPath();
  const buildFullPath = /* @__PURE__ */ getDefaultExportFromCjs(buildFullPathExports);
  var bind;
  var hasRequiredBind;
  function requireBind() {
    if (hasRequiredBind) return bind;
    hasRequiredBind = 1;
    bind = function bind2(fn, thisArg) {
      return function wrap() {
        var args = new Array(arguments.length);
        for (var i2 = 0; i2 < args.length; i2++) {
          args[i2] = arguments[i2];
        }
        return fn.apply(thisArg, args);
      };
    };
    return bind;
  }
  var utils$1;
  var hasRequiredUtils;
  function requireUtils() {
    if (hasRequiredUtils) return utils$1;
    hasRequiredUtils = 1;
    var bind2 = requireBind();
    var toString2 = Object.prototype.toString;
    var kindOf = /* @__PURE__ */ function(cache2) {
      return function(thing) {
        var str = toString2.call(thing);
        return cache2[str] || (cache2[str] = str.slice(8, -1).toLowerCase());
      };
    }(/* @__PURE__ */ Object.create(null));
    function kindOfTest(type) {
      type = type.toLowerCase();
      return function isKindOf(thing) {
        return kindOf(thing) === type;
      };
    }
    function isArray(val) {
      return Array.isArray(val);
    }
    function isUndefined(val) {
      return typeof val === "undefined";
    }
    function isBuffer(val) {
      return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
    }
    var isArrayBuffer = kindOfTest("ArrayBuffer");
    function isArrayBufferView(val) {
      var result;
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        result = ArrayBuffer.isView(val);
      } else {
        result = val && val.buffer && isArrayBuffer(val.buffer);
      }
      return result;
    }
    function isString2(val) {
      return typeof val === "string";
    }
    function isNumber2(val) {
      return typeof val === "number";
    }
    function isObject2(val) {
      return val !== null && typeof val === "object";
    }
    function isPlainObject2(val) {
      if (kindOf(val) !== "object") {
        return false;
      }
      var prototype = Object.getPrototypeOf(val);
      return prototype === null || prototype === Object.prototype;
    }
    var isDate = kindOfTest("Date");
    var isFile = kindOfTest("File");
    var isBlob = kindOfTest("Blob");
    var isFileList = kindOfTest("FileList");
    function isFunction2(val) {
      return toString2.call(val) === "[object Function]";
    }
    function isStream(val) {
      return isObject2(val) && isFunction2(val.pipe);
    }
    function isFormData(thing) {
      var pattern = "[object FormData]";
      return thing && (typeof FormData === "function" && thing instanceof FormData || toString2.call(thing) === pattern || isFunction2(thing.toString) && thing.toString() === pattern);
    }
    var isURLSearchParams = kindOfTest("URLSearchParams");
    function trim2(str) {
      return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
    }
    function isStandardBrowserEnv() {
      if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
        return false;
      }
      return typeof window !== "undefined" && typeof document !== "undefined";
    }
    function forEach(obj, fn) {
      if (obj === null || typeof obj === "undefined") {
        return;
      }
      if (typeof obj !== "object") {
        obj = [obj];
      }
      if (isArray(obj)) {
        for (var i2 = 0, l2 = obj.length; i2 < l2; i2++) {
          fn.call(null, obj[i2], i2, obj);
        }
      } else {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            fn.call(null, obj[key], key, obj);
          }
        }
      }
    }
    function merge2() {
      var result = {};
      function assignValue2(val, key) {
        if (isPlainObject2(result[key]) && isPlainObject2(val)) {
          result[key] = merge2(result[key], val);
        } else if (isPlainObject2(val)) {
          result[key] = merge2({}, val);
        } else if (isArray(val)) {
          result[key] = val.slice();
        } else {
          result[key] = val;
        }
      }
      for (var i2 = 0, l2 = arguments.length; i2 < l2; i2++) {
        forEach(arguments[i2], assignValue2);
      }
      return result;
    }
    function extend(a2, b, thisArg) {
      forEach(b, function assignValue2(val, key) {
        if (thisArg && typeof val === "function") {
          a2[key] = bind2(val, thisArg);
        } else {
          a2[key] = val;
        }
      });
      return a2;
    }
    function stripBOM(content) {
      if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
      }
      return content;
    }
    function inherits(constructor, superConstructor, props, descriptors2) {
      constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
      constructor.prototype.constructor = constructor;
      props && Object.assign(constructor.prototype, props);
    }
    function toFlatObject(sourceObj, destObj, filter) {
      var props;
      var i2;
      var prop;
      var merged = {};
      destObj = destObj || {};
      do {
        props = Object.getOwnPropertyNames(sourceObj);
        i2 = props.length;
        while (i2-- > 0) {
          prop = props[i2];
          if (!merged[prop]) {
            destObj[prop] = sourceObj[prop];
            merged[prop] = true;
          }
        }
        sourceObj = Object.getPrototypeOf(sourceObj);
      } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);
      return destObj;
    }
    function endsWith(str, searchString, position2) {
      str = String(str);
      if (position2 === void 0 || position2 > str.length) {
        position2 = str.length;
      }
      position2 -= searchString.length;
      var lastIndex = str.indexOf(searchString, position2);
      return lastIndex !== -1 && lastIndex === position2;
    }
    function toArray(thing) {
      if (!thing) return null;
      var i2 = thing.length;
      if (isUndefined(i2)) return null;
      var arr = new Array(i2);
      while (i2-- > 0) {
        arr[i2] = thing[i2];
      }
      return arr;
    }
    var isTypedArray2 = /* @__PURE__ */ function(TypedArray) {
      return function(thing) {
        return TypedArray && thing instanceof TypedArray;
      };
    }(typeof Uint8Array !== "undefined" && Object.getPrototypeOf(Uint8Array));
    utils$1 = {
      isArray,
      isArrayBuffer,
      isBuffer,
      isFormData,
      isArrayBufferView,
      isString: isString2,
      isNumber: isNumber2,
      isObject: isObject2,
      isPlainObject: isPlainObject2,
      isUndefined,
      isDate,
      isFile,
      isBlob,
      isFunction: isFunction2,
      isStream,
      isURLSearchParams,
      isStandardBrowserEnv,
      forEach,
      merge: merge2,
      extend,
      trim: trim2,
      stripBOM,
      inherits,
      toFlatObject,
      kindOf,
      kindOfTest,
      endsWith,
      toArray,
      isTypedArray: isTypedArray2,
      isFileList
    };
    return utils$1;
  }
  var AxiosError_1;
  var hasRequiredAxiosError;
  function requireAxiosError() {
    if (hasRequiredAxiosError) return AxiosError_1;
    hasRequiredAxiosError = 1;
    var utils2 = requireUtils();
    function AxiosError2(message2, code, config, request2, response) {
      Error.call(this);
      this.message = message2;
      this.name = "AxiosError";
      code && (this.code = code);
      config && (this.config = config);
      request2 && (this.request = request2);
      response && (this.response = response);
    }
    utils2.inherits(AxiosError2, Error, {
      toJSON: function toJSON() {
        return {
          // Standard
          message: this.message,
          name: this.name,
          // Microsoft
          description: this.description,
          number: this.number,
          // Mozilla
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          // Axios
          config: this.config,
          code: this.code,
          status: this.response && this.response.status ? this.response.status : null
        };
      }
    });
    var prototype = AxiosError2.prototype;
    var descriptors2 = {};
    [
      "ERR_BAD_OPTION_VALUE",
      "ERR_BAD_OPTION",
      "ECONNABORTED",
      "ETIMEDOUT",
      "ERR_NETWORK",
      "ERR_FR_TOO_MANY_REDIRECTS",
      "ERR_DEPRECATED",
      "ERR_BAD_RESPONSE",
      "ERR_BAD_REQUEST",
      "ERR_CANCELED"
      // eslint-disable-next-line func-names
    ].forEach(function(code) {
      descriptors2[code] = { value: code };
    });
    Object.defineProperties(AxiosError2, descriptors2);
    Object.defineProperty(prototype, "isAxiosError", { value: true });
    AxiosError2.from = function(error, code, config, request2, response, customProps) {
      var axiosError = Object.create(prototype);
      utils2.toFlatObject(error, axiosError, function filter(obj) {
        return obj !== Error.prototype;
      });
      AxiosError2.call(axiosError, error.message, code, config, request2, response);
      axiosError.name = error.name;
      customProps && Object.assign(axiosError, customProps);
      return axiosError;
    };
    AxiosError_1 = AxiosError2;
    return AxiosError_1;
  }
  var settle$1;
  var hasRequiredSettle;
  function requireSettle() {
    if (hasRequiredSettle) return settle$1;
    hasRequiredSettle = 1;
    var AxiosError2 = requireAxiosError();
    settle$1 = function settle2(resolve, reject, response) {
      var validateStatus = response.config.validateStatus;
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve(response);
      } else {
        reject(new AxiosError2(
          "Request failed with status code " + response.status,
          [AxiosError2.ERR_BAD_REQUEST, AxiosError2.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
          response.config,
          response.request,
          response
        ));
      }
    };
    return settle$1;
  }
  var settleExports = requireSettle();
  const settle = /* @__PURE__ */ getDefaultExportFromCjs(settleExports);
  var buildURL$1;
  var hasRequiredBuildURL;
  function requireBuildURL() {
    if (hasRequiredBuildURL) return buildURL$1;
    hasRequiredBuildURL = 1;
    var utils2 = requireUtils();
    function encode(val) {
      return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    }
    buildURL$1 = function buildURL2(url, params, paramsSerializer) {
      if (!params) {
        return url;
      }
      var serializedParams;
      if (paramsSerializer) {
        serializedParams = paramsSerializer(params);
      } else if (utils2.isURLSearchParams(params)) {
        serializedParams = params.toString();
      } else {
        var parts = [];
        utils2.forEach(params, function serialize2(val, key) {
          if (val === null || typeof val === "undefined") {
            return;
          }
          if (utils2.isArray(val)) {
            key = key + "[]";
          } else {
            val = [val];
          }
          utils2.forEach(val, function parseValue(v) {
            if (utils2.isDate(v)) {
              v = v.toISOString();
            } else if (utils2.isObject(v)) {
              v = JSON.stringify(v);
            }
            parts.push(encode(key) + "=" + encode(v));
          });
        });
        serializedParams = parts.join("&");
      }
      if (serializedParams) {
        var hashmarkIndex = url.indexOf("#");
        if (hashmarkIndex !== -1) {
          url = url.slice(0, hashmarkIndex);
        }
        url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
      }
      return url;
    };
    return buildURL$1;
  }
  var buildURLExports = requireBuildURL();
  const buildURL = /* @__PURE__ */ getDefaultExportFromCjs(buildURLExports);
  var parseHeaders$1;
  var hasRequiredParseHeaders;
  function requireParseHeaders() {
    if (hasRequiredParseHeaders) return parseHeaders$1;
    hasRequiredParseHeaders = 1;
    var utils2 = requireUtils();
    var ignoreDuplicateOf = [
      "age",
      "authorization",
      "content-length",
      "content-type",
      "etag",
      "expires",
      "from",
      "host",
      "if-modified-since",
      "if-unmodified-since",
      "last-modified",
      "location",
      "max-forwards",
      "proxy-authorization",
      "referer",
      "retry-after",
      "user-agent"
    ];
    parseHeaders$1 = function parseHeaders2(headers) {
      var parsed2 = {};
      var key;
      var val;
      var i2;
      if (!headers) {
        return parsed2;
      }
      utils2.forEach(headers.split("\n"), function parser(line2) {
        i2 = line2.indexOf(":");
        key = utils2.trim(line2.substr(0, i2)).toLowerCase();
        val = utils2.trim(line2.substr(i2 + 1));
        if (key) {
          if (parsed2[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
            return;
          }
          if (key === "set-cookie") {
            parsed2[key] = (parsed2[key] ? parsed2[key] : []).concat([val]);
          } else {
            parsed2[key] = parsed2[key] ? parsed2[key] + ", " + val : val;
          }
        }
      });
      return parsed2;
    };
    return parseHeaders$1;
  }
  var parseHeadersExports = requireParseHeaders();
  const parseHeaders = /* @__PURE__ */ getDefaultExportFromCjs(parseHeadersExports);
  var utilsExports = requireUtils();
  const utils = /* @__PURE__ */ getDefaultExportFromCjs(utilsExports);
  function xhrAdapter(config) {
    return new Promise((resolve, reject) => {
      let requestData = config.data;
      const requestHeaders = config.headers ?? {};
      if (utils.isFormData(requestData)) {
        delete requestHeaders["Content-Type"];
      }
      if (config.auth) {
        const username = config.auth.username || "";
        const password = config.auth.password || "";
        requestHeaders.Authorization = "Basic " + Buffer.from(username + ":" + password).toString("base64");
      }
      const onerror = function handleError() {
        reject(new axios.AxiosError("Network Error", axios.AxiosError.ERR_NETWORK, config));
      };
      const ontimeout = function handleTimeout() {
        reject(new axios.AxiosError("timeout of " + config.timeout + "ms exceeded", axios.AxiosError.ECONNABORTED, config));
      };
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
          delete requestHeaders[key];
        }
      });
      if (requestData === void 0) {
        requestData = null;
      }
      const onload = function handleLoad(resp) {
        const responseHeaders = "responseHeaders" in resp ? parseHeaders(resp.responseHeaders) : {};
        const responseData = !config.responseType || config.responseType === "text" ? resp.responseText : resp.response;
        const response = {
          data: responseData,
          status: resp.status,
          statusText: resp.statusText,
          headers: responseHeaders,
          config,
          request: {
            // can't got real XMLHttpRequest object, only some property is available
            responseURL: resp.finalUrl,
            status: resp.status,
            statusText: resp.statusText,
            responseXML: null
          }
        };
        settle(resolve, reject, response);
      };
      if (config.cancelToken) {
        config.cancelToken.promise.then(function onCanceled(cancel) {
          reject(cancel);
        });
      }
      let responseType;
      if (config.responseType && config.responseType !== "json") {
        responseType = config.responseType;
      }
      const method = config.method.toUpperCase();
      if (method === "UNLINK" || method === "PURGE" || method === "LINK") {
        reject(new axios.AxiosError(`${method} is not a supported method by GM.xmlHttpRequest`));
      } else {
        GM.xmlHttpRequest({
          method,
          url: buildURL(buildFullPath(config.baseURL, config.url), config.params, config.paramsSerializer),
          headers: Object.fromEntries(Object.entries(requestHeaders).map(([key, val]) => [key, val.toString()])),
          responseType,
          data: requestData,
          timeout: config.timeout,
          ontimeout,
          onload,
          onerror
        });
      }
    });
  }
  const request = axios.create({
    baseURL: HOST_API,
    withCredentials: true
  });
  request.interceptors.request.use(async function(config) {
    var _a2;
    config.params || (config.params = {});
    if (((_a2 = config.url) == null ? void 0 : _a2.includes("/wbi/")) && !(config.params.w_rid || config.params.wts)) {
      config.params = await encWbi(config.params);
    }
    return config;
  });
  function isWebApiSuccess(json) {
    return (json == null ? void 0 : json.code) === 0 && ((json == null ? void 0 : json.message) === "0" || (json == null ? void 0 : json.message) === "success");
  }
  const gmrequest = axios.create({
    // @ts-ignore
    adapter: xhrAdapter
  });
  const appkey = TVKeyInfo.appkey;
  const appsec = TVKeyInfo.appsec;
  gmrequest.interceptors.request.use(function(config) {
    config.params = {
      appkey,
      access_key: settings.accessKey || "",
      ...config.params
    };
    config.params.sign = appSign(config.params, appkey, appsec);
    return config;
  });
  gmrequest.interceptors.response.use((res) => {
    if (res.config.responseType === "json" && res.data && res.data instanceof ArrayBuffer) {
      const decoder = new TextDecoder();
      const u8arr = new Uint8Array(res.data);
      const text = decoder.decode(u8arr);
      res.data = text;
      try {
        res.data = JSON.parse(text);
      } catch (e2) {
      }
    }
    return res;
  });
  function parseCookie() {
    const cookies = {};
    document.cookie.split(";").map((pair) => pair.trim()).filter(Boolean).forEach((pair) => {
      const [key, val] = pair.split("=").map((s2) => s2.trim()).filter(Boolean);
      if (!key) return;
      cookies[key] = val;
    });
    return cookies;
  }
  function getCsrfToken() {
    const csrfToken = parseCookie().bili_jct;
    if (!csrfToken) {
      toast("找不到 csrf token, 请检查是否登录");
      throw new Error("找不到 csrf token, 请检查是否登录");
    }
    return csrfToken;
  }
  function getUid() {
    return parseCookie().DedeUserID;
  }
  function getHasLogined() {
    const cookies = parseCookie();
    return !!cookies.DedeUserID;
  }
  const loginState = proxy({
    cookie: document.cookie,
    logined: getHasLogined()
  });
  function checkLoginStatus() {
    Object.assign(loginState, {
      cookie: document.cookie,
      logined: getHasLogined()
    });
    return loginState.logined;
  }
  function useHasLogined() {
    return useSnapshot(loginState).logined;
  }
  async function listAll() {
    var _a2;
    const json = (await request.get("https://member.bilibili.com/x/web/draft/list")).data;
    const drafts = ((_a2 = json.artlist) == null ? void 0 : _a2.drafts) || [];
    return drafts;
  }
  async function addupdate(payload) {
    var _a2, _b2;
    const form = new URLSearchParams({
      title: "",
      banner_url: "",
      content: "",
      summary: "",
      words: "0",
      category: "15",
      tid: "0",
      reprint: "0",
      tags: "",
      image_urls: "",
      origin_image_urls: "",
      dynamic_intro: "",
      media_id: "0",
      spoiler: "0",
      original: "0",
      top_video_bvid: "",
      aid: "",
      csrf: getCsrfToken(),
      ...payload
    });
    const json = (await request.post("/x/article/creative/draft/addupdate", form)).data;
    const aid = (_b2 = (_a2 = json == null ? void 0 : json.data) == null ? void 0 : _a2.aid) == null ? void 0 : _b2.toString();
    const success = isWebApiSuccess(json);
    if (!success) {
      toast(json.message || "addupdate error");
    }
    return {
      success,
      aid
    };
  }
  async function draftView(aid) {
    var _a2;
    const json = (await request.get("/x/article/creative/draft/view", {
      params: {
        aid
      }
    })).data;
    return ((_a2 = json == null ? void 0 : json.data) == null ? void 0 : _a2.content) || "";
  }
  class BilibiliArticleDraft {
    constructor(title) {
      __publicField(this, "title");
      __publicField(this, "getData", async () => {
        const {
          title
        } = this;
        const allDrafts = await listAll();
        const draft = allDrafts.find((d2) => d2.title === title);
        if (!draft) {
          const {
            success,
            aid
          } = await addupdate({
            title
          });
          return;
        }
        const content = await draftView(draft.id);
        const parser = new DOMParser();
        const parsed2 = parser.parseFromString(content, "text/html");
        const text = (parsed2.body.textContent || "").trim();
        if (!text) return;
        try {
          return JSON.parse(text);
        } catch (e2) {
          return;
        }
      });
      // cache aid for setData
      // a refresh is needed after manual delete article draft by bilibili dashboard
      __publicField(this, "_aid");
      __publicField(this, "setData", async (data2) => {
        const {
          title
        } = this;
        if (!this._aid) {
          const allDrafts = await listAll();
          const draft = allDrafts.find((d2) => d2.title === title);
          if (!draft) {
            const {
              success: success2,
              aid: newDraftAid
            } = await addupdate({
              title
            });
            if (!success2) return false;
            this._aid = newDraftAid;
          } else {
            this._aid = draft.id.toString();
          }
        }
        const dataStr = JSON.stringify(data2);
        const {
          success
        } = await addupdate({
          aid: this._aid,
          title,
          content: `<p>${dataStr}</p>`,
          words: dataStr.length.toString()
        });
        return success;
      });
      this.title = title;
    }
  }
  const debug$f = baseDebug.extend("settings");
  const articleDraft = new BilibiliArticleDraft(APP_NAME);
  const privateKeys = ["accessKey", "accessKeyExpireAt"];
  const getBackupOmitPaths = () => [
    ...privateKeys,
    ...internalBooleanPaths,
    // the flag
    "backupSettingsToArticleDraft",
    // 无关紧要
    "fav.addSeparator",
    "watchlaterAddSeparator",
    "watchlaterItemsOrder",
    "popularWeeklyUseShuffle",
    "popularGeneralUseAnonymous"
  ];
  const restoreOmitPaths = [
    ...privateKeys,
    // the flag
    "backupSettingsToArticleDraft"
  ];
  let HAS_RESTORED_SETTINGS = false;
  function set_HAS_RESTORED_SETTINGS(val) {
    HAS_RESTORED_SETTINGS = val;
  }
  let lastBackupVal;
  const setDataThrottled = throttle$1(articleDraft.setData, ms("5s"));
  async function saveToDraft(val) {
    if (!val.backupSettingsToArticleDraft) return;
    if (HAS_RESTORED_SETTINGS) return;
    const {
      pickedSettings: currentBackupVal
    } = pickSettings(val, allowedLeafSettingsPaths, getBackupOmitPaths());
    const shouldBackup = !lastBackupVal || !isEqual$2(lastBackupVal, currentBackupVal);
    if (!shouldBackup) return;
    try {
      await setDataThrottled(currentBackupVal);
      lastBackupVal = currentBackupVal;
      debug$f("backup to article draft complete");
    } catch (e2) {
      console.error(e2.stack || e2);
    }
  }
  const debug$e = baseDebug.extend("settings");
  const initialSettings = {
    accessKey: "",
    accessKeyExpireAt: 0,
    // 窄屏模式
    useNarrowMode: false,
    // 全屏模式
    // @history
    //  - 2024-03-18 bili-feed4 以前的内测首页现在是默认首页, 这里更名为全屏模式, 默认为 true
    pureRecommend: true,
    /**
     * tab = app-recommend
     */
    appRecommend: {
      deviceParamForApi: EAppApiDevice.ipad,
      addOtherTabContents: false
      // this flag will results MUCH more requests
    },
    /**
     * 查看更多, aka ModalFeed
     */
    // 自动查看更多
    showModalFeedOnLoad: false,
    // "查看更多" 按钮
    showModalFeedEntry: false,
    // ModalFeed.全屏
    modalFeedFullScreen: false,
    /**
     * Video Card
     */
    videoCard: {
      // action buttons
      actions: {
        openInPipWindow: false,
        showLargePreview: true
      },
      // current largePreview: videoPreview
      videoPreview: {
        useMp4: false,
        // mp4 | dash (mp4: single video, dash: video only, no audio)
        useScale: true,
        // scale effect
        addTo: {
          searchPage: true
        },
        __internal: {
          preferNormalCdn: false
        }
      }
    },
    // 自动开始预览: 按键选择
    autoPreviewWhenKeyboardSelect: false,
    // 自动开始预览: 鼠标悬浮; 不再跟随鼠标位置, 默认: 跟随鼠标
    autoPreviewWhenHover: true,
    // 自动预览: 更新间隔
    // 跳跃式(400) 连续式(700)
    autoPreviewUpdateInterval: 700,
    // hover 延时
    useDelayForHover: false,
    /**
     * tab=dynamic-feed
     */
    dynamicFeed: {
      showLive: true,
      // 在动态中显示直播
      followGroup: {
        enabled: true,
        // 下拉筛选支持 - 关注分组
        forceUseMergeTimelineIds: []
      },
      whenViewAll: {
        enableHideSomeContents: false,
        // 在「全部」动态中隐藏 UP 的动态 & 在「全部」动态中隐藏此分组的动态
        hideIds: []
        // `up:${mid}` | `follow-group:${id}`
      },
      advancedSearch: false,
      __internal: {
        cacheAllItemsEntry: false,
        cacheAllItemsUpMids: [],
        // enable for these up
        externalSearchInput: false
        // more convenient
      }
    },
    /**
     * tab=watchlater
     */
    watchlaterAddSeparator: true,
    // 添加 "近期" / "更早" 分割线
    watchlaterItemsOrder: WatchlaterItemsOrder.AddTimeDesc,
    // 顺序
    /**
     * tab=fav
     */
    fav: {
      // useShuffle: false, // 打乱顺序
      addSeparator: true,
      // 收藏夹分割线
      excludedFolderIds: []
      // 忽略的收藏夹
    },
    /**
     * tab=popular-general
     */
    popularGeneralUseAnonymous: false,
    // without credentials
    /**
     * tab=popular-weekly
     */
    popularWeeklyUseShuffle: false,
    // shuffle
    /**
     * tab=live
     */
    /**
     * tab=space-upload
     */
    spaceUpload: {
      showVol: false
    },
    /**
     * 过滤器模块
     */
    filter: {
      enabled: true,
      // 时长
      minDuration: {
        enabled: false,
        value: 60
        // 60s
      },
      // 最少播放次数
      minPlayCount: {
        enabled: false,
        value: 1e4
      },
      // 最少弹幕条数
      minDanmakuCount: {
        enabled: false,
        value: 10
      },
      // 已关注豁免
      exemptForFollowed: {
        video: true,
        // 图文也是有 rcmd_reason = '已关注' 的
        picture: true
      },
      // filter out goto = 'picture' | 'bangumi'
      hideGotoTypePicture: false,
      hideGotoTypeBangumi: false,
      byAuthor: {
        enabled: false,
        keywords: []
      },
      byTitle: {
        enabled: false,
        keywords: []
      }
    },
    /**
     * 外观
     */
    style: {
      general: {
        popoverBorderColorUseColorPrimary: false
      },
      pureRecommend: {
        // sticky tabbar
        useStickyTabbar: true,
        // custom grid | default grid
        useCustomGrid: true,
        // bg1
        useWhiteBackground: true,
        // 隐藏顶部分区
        hideTopChannel: false,
        // grid | list
        cardDisplay: ECardDisplay.Grid
      },
      videoCard: {
        // 使用卡片模式
        // inspired by https://ai.taobao.com
        useBorder: true,
        useBorderOnlyOnHover: true,
        useBoxShadow: false,
        usePadding: false
      }
    },
    /**
     * 颜色主题
     */
    theme: "",
    colorPickerThemeSelectedColor: "",
    // 自定义颜色
    /**
     * 功能
     */
    // 备份
    backupSettingsToArticleDraft: false,
    // 默认打开模式
    videoLinkOpenMode: VideoLinkOpenMode.Normal,
    pipWindow: {
      defaultLocked: true,
      // 小窗默认锁定
      autoWebFullscreen: true
      // 自动网页全屏
    },
    /**
     * 隐藏的 tab, 使用黑名单, 功能迭代之后新增的 tab, 默认开启.
     * 如果使用白名单, 新增的 tab 会被隐藏
     */
    hidingTabKeys: [ETab.KeepFollowOnly, ETab.Live],
    customTabKeysOrder: [],
    /**
     * multi-select module
     */
    multiSelect: {
      clearWhenExit: true,
      showIcon: true
    },
    /**
     * internal
     */
    __internalEnableCopyBvidInfo: false,
    // ContextMenu | Button
    __internalAddCopyBvidButton: false,
    __internalHotSubUseDropdown: false,
    __internalShowGridListSwitcher: false,
    __internalRecTabRenderAsSegments: false
  };
  const settings = proxy(cloneDeep(initialSettings));
  const allowedLeafSettingsPaths = getLeafPaths(initialSettings);
  const internalBooleanPaths = allowedLeafSettingsPaths.filter((p2) => p2.includes("__internal") && typeof get(initialSettings, p2) === "boolean");
  debug$e("allowedLeafSettingsPaths = %O, internalBooleanPaths = %O", allowedLeafSettingsPaths, internalBooleanPaths);
  function useSettingsSnapshot() {
    return useSnapshot(settings);
  }
  function getSettingsSnapshot() {
    return snapshot(settings);
  }
  const storageKey$1 = `settings`;
  async function __pickSettingsFromGmStorage() {
    const saved = await GM.getValue(storageKey$1);
    if (!saved || typeof saved !== "object") return {};
    runSettingsMigration(saved);
    return pickSettings(saved, allowedLeafSettingsPaths).pickedSettings;
  }
  async function loadAndSetup() {
    const val = await __pickSettingsFromGmStorage();
    updateSettings(val);
    subscribe$3(settings, () => {
      _onSettingsChange();
    });
    reciveGmValueUpdatesFromOtherTab({
      storageKey: storageKey$1,
      setPersist(val2) {
        _persist = val2;
      },
      onUpdate(newValue) {
        updateSettings(newValue);
      }
    });
  }
  async function _onSettingsChange() {
    const snap = cloneDeep(snapshot(settings));
    await _saveToGmStorage(snap);
    await saveToDraft(snap);
  }
  let _persist = true;
  async function _saveToGmStorage(snap) {
    if (!_persist) return;
    await GM.setValue(storageKey$1, snap);
  }
  function updateSettings(payload) {
    const {
      pickedPaths
    } = pickSettings(payload, allowedLeafSettingsPaths);
    for (const p2 of pickedPaths) {
      const v = get(payload, p2);
      set(settings, p2, v);
    }
  }
  function resetSettings() {
    return updateSettings(initialSettings);
  }
  function runSettingsMigration(val) {
    if (!val) return;
    const config = [
      ["dynamicFeed.showLive", "dynamicFeedShowLive"],
      ["dynamicFeed.followGroup.enabled", "dynamicFeedFollowGroupEnabled"],
      ["dynamicFeed.followGroup.forceUseMergeTimelineIds", "dynamicFeedFollowGroupForceUseMergeTimelineIds"],
      ["dynamicFeed.whenViewAll.enableHideSomeContents", "dynamicFeedWhenViewAllEnableHideSomeContents"],
      ["dynamicFeed.whenViewAll.hideIds", "dynamicFeedWhenViewAllHideIds"],
      ["dynamicFeed.advancedSearch", "dynamicFeedAdvancedSearch"],
      // ['fav.useShuffle', 'favUseShuffle'],
      ["fav.addSeparator", "favAddSeparator"],
      ["fav.excludedFolderIds", "favExcludedFolderIds"],
      ["filter.enabled", "filterEnabled"],
      ["filter.minPlayCount.enabled", "filterMinPlayCountEnabled"],
      ["filter.minPlayCount.value", "filterMinPlayCount"],
      ["filter.minDuration.enabled", "filterMinDurationEnabled"],
      ["filter.minDuration.value", "filterMinDuration"],
      ["filter.exemptForFollowed.video", "exemptForFollowedVideo"],
      ["filter.exemptForFollowed.picture", "exemptForFollowedPicture"],
      ["filter.hideGotoTypePicture", "filterOutGotoTypePicture"],
      ["filter.hideGotoTypeBangumi", "filterOutGotoTypeBangumi"],
      ["filter.byAuthor.enabled", "filterByAuthorNameEnabled"],
      ["filter.byAuthor.keywords", "filterByAuthorNameKeywords"],
      ["filter.byTitle.enabled", "filterByTitleEnabled"],
      ["filter.byTitle.keywords", "filterByTitleKeywords"],
      // ['style.general.videoSourceTabStandardHeight', 'styleUseStandardVideoSourceTab'],
      ["style.pureRecommend.useStickyTabbar", "styleUseStickyTabbarInPureRecommend"],
      ["style.pureRecommend.useCustomGrid", "styleUseCustomGrid"],
      ["style.pureRecommend.useWhiteBackground", "styleUseWhiteBackground"],
      ["style.pureRecommend.hideTopChannel", "styleHideTopChannel"],
      ["style.videoCard.useBorder", "styleUseCardBorder"],
      ["style.videoCard.useBorderOnlyOnHover", "styleUseCardBorderOnlyOnHover"],
      ["style.videoCard.useBoxShadow", "styleUseCardBoxShadow"],
      ["style.videoCard.usePadding", "styleUseCardPadding"],
      // 2024-12-17
      ["appRecommend.deviceParamForApi", "appApiDecice"],
      // 2025-04-23
      ["pipWindow.defaultLocked", "pipWindowDefaultLocked"]
    ];
    for (const [configPath, legacyConfigPath] of config) {
      const haveValue = (v) => !isNil(v);
      if (haveValue(get(val, configPath))) {
        continue;
      }
      if (!haveValue(get(val, legacyConfigPath))) {
        continue;
      }
      set(val, configPath, get(val, legacyConfigPath));
    }
  }
  function pickSettings(source, paths, omit2 = []) {
    const pickedSettings = {};
    const pickedPaths = paths.filter((p2) => allowedLeafSettingsPaths.includes(p2) && !omit2.includes(p2) && !isNil(get(source, p2)));
    pickedPaths.forEach((p2) => {
      const v = get(source, p2);
      set(pickedSettings, p2, v);
    });
    return {
      pickedPaths,
      pickedSettings
    };
  }
  function useSettingsInnerArray(path2) {
    const snap = useSettingsSnapshot();
    return get(snap, path2);
  }
  async function getNewestValueOfSettingsInnerArray(path2) {
    const newest = await __pickSettingsFromGmStorage();
    return get(newest, path2) || get(getSettingsSnapshot(), path2);
  }
  function setSettingsInnerArray(path2, value) {
    set(settings, path2, value);
  }
  async function updateSettingsInnerArray(path2, {
    add: add2,
    remove
  }) {
    const arr = await getNewestValueOfSettingsInnerArray(path2);
    const s2 = new Set(arr);
    for (const x of add2 ?? []) s2.add(x);
    for (const x of remove ?? []) s2.delete(x);
    setSettingsInnerArray(path2, Array.from(s2));
  }
  await( loadAndSetup());
  if (IN_BILIBILI_HOMEPAGE && settings.accessKey && settings.accessKeyExpireAt && Date.now() >= settings.accessKeyExpireAt) {
    toast("access_key 已过期, 请重新获取 !!!");
  }
  const debug$d = baseDebug.extend("utility:dom");
  const DEFAULT_POLL_TIMEOUT = 10 * 1e3;
  const DEFAULT_POLL_INTERVAL = 200;
  async function poll$1(fn, options) {
    const interval = (options == null ? void 0 : options.interval) ?? DEFAULT_POLL_INTERVAL;
    let timeout = (options == null ? void 0 : options.timeout) ?? DEFAULT_POLL_TIMEOUT;
    if (timeout === 0) timeout = Infinity;
    const validate = (options == null ? void 0 : options.validate) ?? ((val) => !isNil(val));
    const start = performance.now();
    let result = fn();
    while (!validate(result) && performance.now() - start < timeout) {
      await delay(interval);
      result = fn();
    }
    return result;
  }
  async function tryAction(selector, action2, moreOptions) {
    const pollTimeout = (moreOptions == null ? void 0 : moreOptions.pollTimeout) ?? DEFAULT_POLL_TIMEOUT;
    const pollInterval = (moreOptions == null ? void 0 : moreOptions.pollInterval) ?? DEFAULT_POLL_INTERVAL;
    const selectorPredicate = moreOptions == null ? void 0 : moreOptions.selectorPredicate;
    const warnOnTimeout = (moreOptions == null ? void 0 : moreOptions.warnOnTimeout) ?? false;
    const arr = await poll$1(() => {
      let arr2 = Array.from(document.querySelectorAll(selector));
      if (selectorPredicate) arr2 = arr2.filter(selectorPredicate);
      if (arr2.length) return arr2;
    }, {
      timeout: pollTimeout,
      interval: pollInterval
    });
    if (!(arr == null ? void 0 : arr.length)) {
      debug$d("tryAction: timeout for selector = `%s`", selector);
      if (warnOnTimeout) {
        appWarn("tryAction timeout, selector = `%s`", selector);
      }
      return;
    }
    debug$d("tryAction: selector=`%s` count=%s", selector, arr.length);
    for (const el of arr) {
      await Promise.resolve(action2(el));
    }
  }
  async function tryToRemove(selector, selectorPredicate, delayMs) {
    return tryAction(selector, (el) => el.remove(), {
      selectorPredicate,
      warnOnTimeout: false
    });
  }
  function shouldDisableShortcut() {
    var _a2;
    const activeTagName = (((_a2 = document.activeElement) == null ? void 0 : _a2.tagName) || "").toLowerCase();
    if (["input", "textarea"].includes(activeTagName)) {
      return true;
    }
    if (document.querySelector(".center-search__bar.is-focus")) {
      return true;
    }
    return false;
  }
  function getElementOffset(el, rect) {
    rect ?? (rect = el.getBoundingClientRect());
    const docElem = document.documentElement;
    return {
      top: rect.top + window.scrollY - docElem.clientTop,
      left: rect.left + window.scrollX - docElem.clientLeft
    };
  }
  function whenIdle(options) {
    return new Promise((resolve) => {
      if (typeof requestIdleCallback === "function") {
        requestIdleCallback(() => resolve(), options);
      } else {
        setTimeout(resolve);
      }
    });
  }
  let ORIGINAL_TITLE = "";
  function setPageTitle(title) {
    if (!ORIGINAL_TITLE) {
      ORIGINAL_TITLE = document.title;
    }
    document.title = `${title} - ${ORIGINAL_TITLE}`;
  }
  var createUpdateEffect = function(hook) {
    return function(effect, deps) {
      var isMounted = H.useRef(false);
      hook(function() {
        return function() {
          isMounted.current = false;
        };
      }, []);
      hook(function() {
        if (!isMounted.current) {
          isMounted.current = true;
        } else {
          return effect();
        }
      }, deps);
    };
  };
  var __assign = function() {
    __assign = Object.assign || function __assign2(t2) {
      for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
        s2 = arguments[i2];
        for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2)) t2[p2] = s2[p2];
      }
      return t2;
    };
    return __assign.apply(this, arguments);
  };
  function __rest(s2, e2) {
    var t2 = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t2[p2[i2]] = s2[p2[i2]];
      }
    return t2;
  }
  function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, [])).next());
    });
  }
  function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() {
      if (t2[0] & 1) throw t2[1];
      return t2[1];
    }, trys: [], ops: [] }, f2, y, t2, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n2) {
      return function(v) {
        return step([n2, v]);
      };
    }
    function step(op) {
      if (f2) throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_ = 0)), _) try {
        if (f2 = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done) return t2;
        if (y = 0, t2) op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t2[1]) {
              _.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _.label < t2[2]) {
              _.label = t2[2];
              _.ops.push(op);
              break;
            }
            if (t2[2]) _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e2) {
        op = [6, e2];
        y = 0;
      } finally {
        f2 = t2 = 0;
      }
      if (op[0] & 5) throw op[1];
      return { value: op[0] ? op[1] : void 0, done: true };
    }
  }
  function __values(o2) {
    var s2 = typeof Symbol === "function" && Symbol.iterator, m = s2 && o2[s2], i2 = 0;
    if (m) return m.call(o2);
    if (o2 && typeof o2.length === "number") return {
      next: function() {
        if (o2 && i2 >= o2.length) o2 = void 0;
        return { value: o2 && o2[i2++], done: !o2 };
      }
    };
    throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
  }
  function __read(o2, n2) {
    var m = typeof Symbol === "function" && o2[Symbol.iterator];
    if (!m) return o2;
    var i2 = m.call(o2), r2, ar = [], e2;
    try {
      while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
    } catch (error) {
      e2 = { error };
    } finally {
      try {
        if (r2 && !r2.done && (m = i2["return"])) m.call(i2);
      } finally {
        if (e2) throw e2.error;
      }
    }
    return ar;
  }
  function __spreadArray(to, from2, pack) {
    if (arguments.length === 2) for (var i2 = 0, l2 = from2.length, ar; i2 < l2; i2++) {
      if (ar || !(i2 in from2)) {
        if (!ar) ar = Array.prototype.slice.call(from2, 0, i2);
        ar[i2] = from2[i2];
      }
    }
    return to.concat(ar || Array.prototype.slice.call(from2));
  }
  typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message2) {
    var e2 = new Error(message2);
    return e2.name = "SuppressedError", e2.error = error, e2.suppressed = suppressed, e2;
  };
  var isFunction$2 = function(value) {
    return typeof value === "function";
  };
  var isString = function(value) {
    return typeof value === "string";
  };
  var isNumber = function(value) {
    return typeof value === "number";
  };
  function useMemoizedFn(fn) {
    var fnRef = H.useRef(fn);
    fnRef.current = H.useMemo(function() {
      return fn;
    }, [fn]);
    var memoizedFn = H.useRef();
    if (!memoizedFn.current) {
      memoizedFn.current = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return fnRef.current.apply(this, args);
      };
    }
    return memoizedFn.current;
  }
  const useUpdateEffect = createUpdateEffect(H.useEffect);
  var useAutoRunPlugin = function(fetchInstance, _a2) {
    var manual = _a2.manual, _b2 = _a2.ready, ready = _b2 === void 0 ? true : _b2, _c2 = _a2.defaultParams, defaultParams = _c2 === void 0 ? [] : _c2, _d2 = _a2.refreshDeps, refreshDeps = _d2 === void 0 ? [] : _d2, refreshDepsAction = _a2.refreshDepsAction;
    var hasAutoRun = H.useRef(false);
    hasAutoRun.current = false;
    useUpdateEffect(function() {
      if (!manual && ready) {
        hasAutoRun.current = true;
        fetchInstance.run.apply(fetchInstance, __spreadArray([], __read(defaultParams), false));
      }
    }, [ready]);
    useUpdateEffect(function() {
      if (hasAutoRun.current) {
        return;
      }
      if (!manual) {
        hasAutoRun.current = true;
        if (refreshDepsAction) {
          refreshDepsAction();
        } else {
          fetchInstance.refresh();
        }
      }
    }, __spreadArray([], __read(refreshDeps), false));
    return {
      onBefore: function() {
        if (!ready) {
          return {
            stopNow: true
          };
        }
      }
    };
  };
  useAutoRunPlugin.onInit = function(_a2) {
    var _b2 = _a2.ready, ready = _b2 === void 0 ? true : _b2, manual = _a2.manual;
    return {
      loading: !manual && ready
    };
  };
  function depsAreSame(oldDeps, deps) {
    if (oldDeps === deps) return true;
    for (var i2 = 0; i2 < oldDeps.length; i2++) {
      if (!Object.is(oldDeps[i2], deps[i2])) return false;
    }
    return true;
  }
  function useCreation(factory, deps) {
    var current = H.useRef({
      deps,
      obj: void 0,
      initialized: false
    }).current;
    if (current.initialized === false || !depsAreSame(current.deps, deps)) {
      current.deps = deps;
      current.obj = factory();
      current.initialized = true;
    }
    return current.obj;
  }
  function useLatest(value) {
    var ref = H.useRef(value);
    ref.current = value;
    return ref;
  }
  var useUnmount = function(fn) {
    var fnRef = useLatest(fn);
    H.useEffect(function() {
      return function() {
        fnRef.current();
      };
    }, []);
  };
  var cache$3 = /* @__PURE__ */ new Map();
  var setCache = function(key, cacheTime, cachedData) {
    var currentCache = cache$3.get(key);
    if (currentCache === null || currentCache === void 0 ? void 0 : currentCache.timer) {
      clearTimeout(currentCache.timer);
    }
    var timer = void 0;
    if (cacheTime > -1) {
      timer = setTimeout(function() {
        cache$3.delete(key);
      }, cacheTime);
    }
    cache$3.set(key, __assign(__assign({}, cachedData), {
      timer
    }));
  };
  var getCache = function(key) {
    return cache$3.get(key);
  };
  var cachePromise = /* @__PURE__ */ new Map();
  var getCachePromise = function(cacheKey2) {
    return cachePromise.get(cacheKey2);
  };
  var setCachePromise = function(cacheKey2, promise) {
    cachePromise.set(cacheKey2, promise);
    promise.then(function(res) {
      cachePromise.delete(cacheKey2);
      return res;
    }).catch(function() {
      cachePromise.delete(cacheKey2);
    });
  };
  var listeners$2 = {};
  var trigger = function(key, data2) {
    if (listeners$2[key]) {
      listeners$2[key].forEach(function(item) {
        return item(data2);
      });
    }
  };
  var subscribe$2 = function(key, listener) {
    if (!listeners$2[key]) {
      listeners$2[key] = [];
    }
    listeners$2[key].push(listener);
    return function unsubscribe() {
      var index = listeners$2[key].indexOf(listener);
      listeners$2[key].splice(index, 1);
    };
  };
  var useCachePlugin = function(fetchInstance, _a2) {
    var cacheKey2 = _a2.cacheKey, _b2 = _a2.cacheTime, cacheTime = _b2 === void 0 ? 5 * 60 * 1e3 : _b2, _c2 = _a2.staleTime, staleTime = _c2 === void 0 ? 0 : _c2, customSetCache = _a2.setCache, customGetCache = _a2.getCache;
    var unSubscribeRef = H.useRef();
    var currentPromiseRef = H.useRef();
    var _setCache = function(key, cachedData) {
      if (customSetCache) {
        customSetCache(cachedData);
      } else {
        setCache(key, cacheTime, cachedData);
      }
      trigger(key, cachedData.data);
    };
    var _getCache = function(key, params) {
      if (params === void 0) {
        params = [];
      }
      if (customGetCache) {
        return customGetCache(params);
      }
      return getCache(key);
    };
    useCreation(function() {
      if (!cacheKey2) {
        return;
      }
      var cacheData = _getCache(cacheKey2);
      if (cacheData && Object.hasOwnProperty.call(cacheData, "data")) {
        fetchInstance.state.data = cacheData.data;
        fetchInstance.state.params = cacheData.params;
        if (staleTime === -1 || (/* @__PURE__ */ new Date()).getTime() - cacheData.time <= staleTime) {
          fetchInstance.state.loading = false;
        }
      }
      unSubscribeRef.current = subscribe$2(cacheKey2, function(data2) {
        fetchInstance.setState({
          data: data2
        });
      });
    }, []);
    useUnmount(function() {
      var _a3;
      (_a3 = unSubscribeRef.current) === null || _a3 === void 0 ? void 0 : _a3.call(unSubscribeRef);
    });
    if (!cacheKey2) {
      return {};
    }
    return {
      onBefore: function(params) {
        var cacheData = _getCache(cacheKey2, params);
        if (!cacheData || !Object.hasOwnProperty.call(cacheData, "data")) {
          return {};
        }
        if (staleTime === -1 || (/* @__PURE__ */ new Date()).getTime() - cacheData.time <= staleTime) {
          return {
            loading: false,
            data: cacheData === null || cacheData === void 0 ? void 0 : cacheData.data,
            error: void 0,
            returnNow: true
          };
        } else {
          return {
            data: cacheData === null || cacheData === void 0 ? void 0 : cacheData.data,
            error: void 0
          };
        }
      },
      onRequest: function(service, args) {
        var servicePromise = getCachePromise(cacheKey2);
        if (servicePromise && servicePromise !== currentPromiseRef.current) {
          return {
            servicePromise
          };
        }
        servicePromise = service.apply(void 0, __spreadArray([], __read(args), false));
        currentPromiseRef.current = servicePromise;
        setCachePromise(cacheKey2, servicePromise);
        return {
          servicePromise
        };
      },
      onSuccess: function(data2, params) {
        var _a3;
        if (cacheKey2) {
          (_a3 = unSubscribeRef.current) === null || _a3 === void 0 ? void 0 : _a3.call(unSubscribeRef);
          _setCache(cacheKey2, {
            data: data2,
            params,
            time: (/* @__PURE__ */ new Date()).getTime()
          });
          unSubscribeRef.current = subscribe$2(cacheKey2, function(d2) {
            fetchInstance.setState({
              data: d2
            });
          });
        }
      },
      onMutate: function(data2) {
        var _a3;
        if (cacheKey2) {
          (_a3 = unSubscribeRef.current) === null || _a3 === void 0 ? void 0 : _a3.call(unSubscribeRef);
          _setCache(cacheKey2, {
            data: data2,
            params: fetchInstance.state.params,
            time: (/* @__PURE__ */ new Date()).getTime()
          });
          unSubscribeRef.current = subscribe$2(cacheKey2, function(d2) {
            fetchInstance.setState({
              data: d2
            });
          });
        }
      }
    };
  };
  var isObject_1;
  var hasRequiredIsObject;
  function requireIsObject() {
    if (hasRequiredIsObject) return isObject_1;
    hasRequiredIsObject = 1;
    function isObject2(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    isObject_1 = isObject2;
    return isObject_1;
  }
  var _freeGlobal;
  var hasRequired_freeGlobal;
  function require_freeGlobal() {
    if (hasRequired_freeGlobal) return _freeGlobal;
    hasRequired_freeGlobal = 1;
    var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
    _freeGlobal = freeGlobal;
    return _freeGlobal;
  }
  var _root;
  var hasRequired_root;
  function require_root() {
    if (hasRequired_root) return _root;
    hasRequired_root = 1;
    var freeGlobal = require_freeGlobal();
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root2 = freeGlobal || freeSelf || Function("return this")();
    _root = root2;
    return _root;
  }
  var now_1;
  var hasRequiredNow;
  function requireNow() {
    if (hasRequiredNow) return now_1;
    hasRequiredNow = 1;
    var root2 = require_root();
    var now = function() {
      return root2.Date.now();
    };
    now_1 = now;
    return now_1;
  }
  var _trimmedEndIndex;
  var hasRequired_trimmedEndIndex;
  function require_trimmedEndIndex() {
    if (hasRequired_trimmedEndIndex) return _trimmedEndIndex;
    hasRequired_trimmedEndIndex = 1;
    var reWhitespace = /\s/;
    function trimmedEndIndex(string) {
      var index = string.length;
      while (index-- && reWhitespace.test(string.charAt(index))) {
      }
      return index;
    }
    _trimmedEndIndex = trimmedEndIndex;
    return _trimmedEndIndex;
  }
  var _baseTrim;
  var hasRequired_baseTrim;
  function require_baseTrim() {
    if (hasRequired_baseTrim) return _baseTrim;
    hasRequired_baseTrim = 1;
    var trimmedEndIndex = require_trimmedEndIndex();
    var reTrimStart = /^\s+/;
    function baseTrim(string) {
      return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
    }
    _baseTrim = baseTrim;
    return _baseTrim;
  }
  var _Symbol;
  var hasRequired_Symbol;
  function require_Symbol() {
    if (hasRequired_Symbol) return _Symbol;
    hasRequired_Symbol = 1;
    var root2 = require_root();
    var Symbol2 = root2.Symbol;
    _Symbol = Symbol2;
    return _Symbol;
  }
  var _getRawTag;
  var hasRequired_getRawTag;
  function require_getRawTag() {
    if (hasRequired_getRawTag) return _getRawTag;
    hasRequired_getRawTag = 1;
    var Symbol2 = require_Symbol();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var nativeObjectToString = objectProto.toString;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e2) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    _getRawTag = getRawTag;
    return _getRawTag;
  }
  var _objectToString;
  var hasRequired_objectToString;
  function require_objectToString() {
    if (hasRequired_objectToString) return _objectToString;
    hasRequired_objectToString = 1;
    var objectProto = Object.prototype;
    var nativeObjectToString = objectProto.toString;
    function objectToString2(value) {
      return nativeObjectToString.call(value);
    }
    _objectToString = objectToString2;
    return _objectToString;
  }
  var _baseGetTag;
  var hasRequired_baseGetTag;
  function require_baseGetTag() {
    if (hasRequired_baseGetTag) return _baseGetTag;
    hasRequired_baseGetTag = 1;
    var Symbol2 = require_Symbol(), getRawTag = require_getRawTag(), objectToString2 = require_objectToString();
    var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString2(value);
    }
    _baseGetTag = baseGetTag;
    return _baseGetTag;
  }
  var isObjectLike_1;
  var hasRequiredIsObjectLike;
  function requireIsObjectLike() {
    if (hasRequiredIsObjectLike) return isObjectLike_1;
    hasRequiredIsObjectLike = 1;
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    isObjectLike_1 = isObjectLike;
    return isObjectLike_1;
  }
  var isSymbol_1;
  var hasRequiredIsSymbol;
  function requireIsSymbol() {
    if (hasRequiredIsSymbol) return isSymbol_1;
    hasRequiredIsSymbol = 1;
    var baseGetTag = require_baseGetTag(), isObjectLike = requireIsObjectLike();
    var symbolTag2 = "[object Symbol]";
    function isSymbol2(value) {
      return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag2;
    }
    isSymbol_1 = isSymbol2;
    return isSymbol_1;
  }
  var toNumber_1;
  var hasRequiredToNumber;
  function requireToNumber() {
    if (hasRequiredToNumber) return toNumber_1;
    hasRequiredToNumber = 1;
    var baseTrim = require_baseTrim(), isObject2 = requireIsObject(), isSymbol2 = requireIsSymbol();
    var NAN = 0 / 0;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    function toNumber2(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol2(value)) {
        return NAN;
      }
      if (isObject2(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject2(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = baseTrim(value);
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    toNumber_1 = toNumber2;
    return toNumber_1;
  }
  var debounce_1;
  var hasRequiredDebounce;
  function requireDebounce() {
    if (hasRequiredDebounce) return debounce_1;
    hasRequiredDebounce = 1;
    var isObject2 = requireIsObject(), now = requireNow(), toNumber2 = requireToNumber();
    var FUNC_ERROR_TEXT = "Expected a function";
    var nativeMax = Math.max, nativeMin = Math.min;
    function debounce2(func, wait, options) {
      var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = toNumber2(wait) || 0;
      if (isObject2(options)) {
        leading = !!options.leading;
        maxing = "maxWait" in options;
        maxWait = maxing ? nativeMax(toNumber2(options.maxWait) || 0, wait) : maxWait;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      function invokeFunc(time) {
        var args = lastArgs, thisArg = lastThis;
        lastArgs = lastThis = void 0;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
      }
      function leadingEdge(time) {
        lastInvokeTime = time;
        timerId = setTimeout(timerExpired, wait);
        return leading ? invokeFunc(time) : result;
      }
      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
        return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
      }
      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
        return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
      }
      function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        timerId = setTimeout(timerExpired, remainingWait(time));
      }
      function trailingEdge(time) {
        timerId = void 0;
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = void 0;
        return result;
      }
      function cancel() {
        if (timerId !== void 0) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = void 0;
      }
      function flush() {
        return timerId === void 0 ? result : trailingEdge(now());
      }
      function debounced() {
        var time = now(), isInvoking = shouldInvoke(time);
        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;
        if (isInvoking) {
          if (timerId === void 0) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            clearTimeout(timerId);
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === void 0) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }
    debounce_1 = debounce2;
    return debounce_1;
  }
  var debounceExports = requireDebounce();
  const debounce = /* @__PURE__ */ getDefaultExportFromCjs(debounceExports);
  var useDebouncePlugin = function(fetchInstance, _a2) {
    var debounceWait = _a2.debounceWait, debounceLeading = _a2.debounceLeading, debounceTrailing = _a2.debounceTrailing, debounceMaxWait = _a2.debounceMaxWait;
    var debouncedRef = H.useRef();
    var options = H.useMemo(function() {
      var ret = {};
      if (debounceLeading !== void 0) {
        ret.leading = debounceLeading;
      }
      if (debounceTrailing !== void 0) {
        ret.trailing = debounceTrailing;
      }
      if (debounceMaxWait !== void 0) {
        ret.maxWait = debounceMaxWait;
      }
      return ret;
    }, [debounceLeading, debounceTrailing, debounceMaxWait]);
    H.useEffect(function() {
      if (debounceWait) {
        var _originRunAsync_1 = fetchInstance.runAsync.bind(fetchInstance);
        debouncedRef.current = debounce(function(callback) {
          callback();
        }, debounceWait, options);
        fetchInstance.runAsync = function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          return new Promise(function(resolve, reject) {
            var _a3;
            (_a3 = debouncedRef.current) === null || _a3 === void 0 ? void 0 : _a3.call(debouncedRef, function() {
              _originRunAsync_1.apply(void 0, __spreadArray([], __read(args), false)).then(resolve).catch(reject);
            });
          });
        };
        return function() {
          var _a3;
          (_a3 = debouncedRef.current) === null || _a3 === void 0 ? void 0 : _a3.cancel();
          fetchInstance.runAsync = _originRunAsync_1;
        };
      }
    }, [debounceWait, options]);
    if (!debounceWait) {
      return {};
    }
    return {
      onCancel: function() {
        var _a3;
        (_a3 = debouncedRef.current) === null || _a3 === void 0 ? void 0 : _a3.cancel();
      }
    };
  };
  var useLoadingDelayPlugin = function(fetchInstance, _a2) {
    var loadingDelay = _a2.loadingDelay, ready = _a2.ready;
    var timerRef = H.useRef();
    if (!loadingDelay) {
      return {};
    }
    var cancelTimeout = function() {
      if (timerRef.current) {
        clearTimeout(timerRef.current);
      }
    };
    return {
      onBefore: function() {
        cancelTimeout();
        if (ready !== false) {
          timerRef.current = setTimeout(function() {
            fetchInstance.setState({
              loading: true
            });
          }, loadingDelay);
        }
        return {
          loading: false
        };
      },
      onFinally: function() {
        cancelTimeout();
      },
      onCancel: function() {
        cancelTimeout();
      }
    };
  };
  var isBrowser = !!(typeof window !== "undefined" && window.document && window.document.createElement);
  function isDocumentVisible() {
    if (isBrowser) {
      return document.visibilityState !== "hidden";
    }
    return true;
  }
  var listeners$1 = [];
  function subscribe$1(listener) {
    listeners$1.push(listener);
    return function unsubscribe() {
      var index = listeners$1.indexOf(listener);
      listeners$1.splice(index, 1);
    };
  }
  if (isBrowser) {
    var revalidate$1 = function() {
      if (!isDocumentVisible()) return;
      for (var i2 = 0; i2 < listeners$1.length; i2++) {
        var listener = listeners$1[i2];
        listener();
      }
    };
    window.addEventListener("visibilitychange", revalidate$1, false);
  }
  var usePollingPlugin = function(fetchInstance, _a2) {
    var pollingInterval = _a2.pollingInterval, _b2 = _a2.pollingWhenHidden, pollingWhenHidden = _b2 === void 0 ? true : _b2, _c2 = _a2.pollingErrorRetryCount, pollingErrorRetryCount = _c2 === void 0 ? -1 : _c2;
    var timerRef = H.useRef();
    var unsubscribeRef = H.useRef();
    var countRef = H.useRef(0);
    var stopPolling = function() {
      var _a3;
      if (timerRef.current) {
        clearTimeout(timerRef.current);
      }
      (_a3 = unsubscribeRef.current) === null || _a3 === void 0 ? void 0 : _a3.call(unsubscribeRef);
    };
    useUpdateEffect(function() {
      if (!pollingInterval) {
        stopPolling();
      }
    }, [pollingInterval]);
    if (!pollingInterval) {
      return {};
    }
    return {
      onBefore: function() {
        stopPolling();
      },
      onError: function() {
        countRef.current += 1;
      },
      onSuccess: function() {
        countRef.current = 0;
      },
      onFinally: function() {
        if (pollingErrorRetryCount === -1 || // When an error occurs, the request is not repeated after pollingErrorRetryCount retries
        pollingErrorRetryCount !== -1 && countRef.current <= pollingErrorRetryCount) {
          timerRef.current = setTimeout(function() {
            if (!pollingWhenHidden && !isDocumentVisible()) {
              unsubscribeRef.current = subscribe$1(function() {
                fetchInstance.refresh();
              });
            } else {
              fetchInstance.refresh();
            }
          }, pollingInterval);
        } else {
          countRef.current = 0;
        }
      },
      onCancel: function() {
        stopPolling();
      }
    };
  };
  function limit(fn, timespan) {
    var pending = false;
    return function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      if (pending) return;
      pending = true;
      fn.apply(void 0, __spreadArray([], __read(args), false));
      setTimeout(function() {
        pending = false;
      }, timespan);
    };
  }
  function isOnline() {
    if (isBrowser && typeof navigator.onLine !== "undefined") {
      return navigator.onLine;
    }
    return true;
  }
  var listeners = [];
  function subscribe(listener) {
    listeners.push(listener);
    return function unsubscribe() {
      var index = listeners.indexOf(listener);
      if (index > -1) {
        listeners.splice(index, 1);
      }
    };
  }
  if (isBrowser) {
    var revalidate = function() {
      if (!isDocumentVisible() || !isOnline()) return;
      for (var i2 = 0; i2 < listeners.length; i2++) {
        var listener = listeners[i2];
        listener();
      }
    };
    window.addEventListener("visibilitychange", revalidate, false);
    window.addEventListener("focus", revalidate, false);
  }
  var useRefreshOnWindowFocusPlugin = function(fetchInstance, _a2) {
    var refreshOnWindowFocus = _a2.refreshOnWindowFocus, _b2 = _a2.focusTimespan, focusTimespan = _b2 === void 0 ? 5e3 : _b2;
    var unsubscribeRef = H.useRef();
    var stopSubscribe = function() {
      var _a3;
      (_a3 = unsubscribeRef.current) === null || _a3 === void 0 ? void 0 : _a3.call(unsubscribeRef);
    };
    H.useEffect(function() {
      if (refreshOnWindowFocus) {
        var limitRefresh_1 = limit(fetchInstance.refresh.bind(fetchInstance), focusTimespan);
        unsubscribeRef.current = subscribe(function() {
          limitRefresh_1();
        });
      }
      return function() {
        stopSubscribe();
      };
    }, [refreshOnWindowFocus, focusTimespan]);
    useUnmount(function() {
      stopSubscribe();
    });
    return {};
  };
  var useRetryPlugin = function(fetchInstance, _a2) {
    var retryInterval = _a2.retryInterval, retryCount = _a2.retryCount;
    var timerRef = H.useRef();
    var countRef = H.useRef(0);
    var triggerByRetry = H.useRef(false);
    if (!retryCount) {
      return {};
    }
    return {
      onBefore: function() {
        if (!triggerByRetry.current) {
          countRef.current = 0;
        }
        triggerByRetry.current = false;
        if (timerRef.current) {
          clearTimeout(timerRef.current);
        }
      },
      onSuccess: function() {
        countRef.current = 0;
      },
      onError: function() {
        countRef.current += 1;
        if (retryCount === -1 || countRef.current <= retryCount) {
          var timeout = retryInterval !== null && retryInterval !== void 0 ? retryInterval : Math.min(1e3 * Math.pow(2, countRef.current), 3e4);
          timerRef.current = setTimeout(function() {
            triggerByRetry.current = true;
            fetchInstance.refresh();
          }, timeout);
        } else {
          countRef.current = 0;
        }
      },
      onCancel: function() {
        countRef.current = 0;
        if (timerRef.current) {
          clearTimeout(timerRef.current);
        }
      }
    };
  };
  var throttle_1;
  var hasRequiredThrottle;
  function requireThrottle() {
    if (hasRequiredThrottle) return throttle_1;
    hasRequiredThrottle = 1;
    var debounce2 = requireDebounce(), isObject2 = requireIsObject();
    var FUNC_ERROR_TEXT = "Expected a function";
    function throttle2(func, wait, options) {
      var leading = true, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (isObject2(options)) {
        leading = "leading" in options ? !!options.leading : leading;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      return debounce2(func, wait, {
        "leading": leading,
        "maxWait": wait,
        "trailing": trailing
      });
    }
    throttle_1 = throttle2;
    return throttle_1;
  }
  var throttleExports = requireThrottle();
  const throttle = /* @__PURE__ */ getDefaultExportFromCjs(throttleExports);
  var useThrottlePlugin = function(fetchInstance, _a2) {
    var throttleWait = _a2.throttleWait, throttleLeading = _a2.throttleLeading, throttleTrailing = _a2.throttleTrailing;
    var throttledRef = H.useRef();
    var options = {};
    if (throttleLeading !== void 0) {
      options.leading = throttleLeading;
    }
    if (throttleTrailing !== void 0) {
      options.trailing = throttleTrailing;
    }
    H.useEffect(function() {
      if (throttleWait) {
        var _originRunAsync_1 = fetchInstance.runAsync.bind(fetchInstance);
        throttledRef.current = throttle(function(callback) {
          callback();
        }, throttleWait, options);
        fetchInstance.runAsync = function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          return new Promise(function(resolve, reject) {
            var _a3;
            (_a3 = throttledRef.current) === null || _a3 === void 0 ? void 0 : _a3.call(throttledRef, function() {
              _originRunAsync_1.apply(void 0, __spreadArray([], __read(args), false)).then(resolve).catch(reject);
            });
          });
        };
        return function() {
          var _a3;
          fetchInstance.runAsync = _originRunAsync_1;
          (_a3 = throttledRef.current) === null || _a3 === void 0 ? void 0 : _a3.cancel();
        };
      }
    }, [throttleWait, throttleLeading, throttleTrailing]);
    if (!throttleWait) {
      return {};
    }
    return {
      onCancel: function() {
        var _a3;
        (_a3 = throttledRef.current) === null || _a3 === void 0 ? void 0 : _a3.cancel();
      }
    };
  };
  var useMount = function(fn) {
    H.useEffect(function() {
      fn === null || fn === void 0 ? void 0 : fn();
    }, []);
  };
  var useUpdate = function() {
    var _a2 = __read(H.useState({}), 2), setState = _a2[1];
    return H.useCallback(function() {
      return setState({});
    }, []);
  };
  var Fetch = (
    /** @class */
    function() {
      function Fetch2(serviceRef, options, subscribe2, initState) {
        if (initState === void 0) {
          initState = {};
        }
        this.serviceRef = serviceRef;
        this.options = options;
        this.subscribe = subscribe2;
        this.initState = initState;
        this.count = 0;
        this.state = {
          loading: false,
          params: void 0,
          data: void 0,
          error: void 0
        };
        this.state = __assign(__assign(__assign({}, this.state), {
          loading: !options.manual
        }), initState);
      }
      Fetch2.prototype.setState = function(s2) {
        if (s2 === void 0) {
          s2 = {};
        }
        this.state = __assign(__assign({}, this.state), s2);
        this.subscribe();
      };
      Fetch2.prototype.runPluginHandler = function(event) {
        var rest = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          rest[_i - 1] = arguments[_i];
        }
        var r2 = this.pluginImpls.map(function(i2) {
          var _a2;
          return (_a2 = i2[event]) === null || _a2 === void 0 ? void 0 : _a2.call.apply(_a2, __spreadArray([i2], __read(rest), false));
        }).filter(Boolean);
        return Object.assign.apply(Object, __spreadArray([{}], __read(r2), false));
      };
      Fetch2.prototype.runAsync = function() {
        var params = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          params[_i] = arguments[_i];
        }
        return __awaiter(this, void 0, void 0, function() {
          var currentCount, _a2, _b2, stopNow, _c2, returnNow, state2, servicePromise, res, error_1;
          var _d2;
          var _e2, _f, _g, _h, _j, _k, _l, _m, _o, _p;
          return __generator(this, function(_q) {
            switch (_q.label) {
              case 0:
                this.count += 1;
                currentCount = this.count;
                _a2 = this.runPluginHandler("onBefore", params), _b2 = _a2.stopNow, stopNow = _b2 === void 0 ? false : _b2, _c2 = _a2.returnNow, returnNow = _c2 === void 0 ? false : _c2, state2 = __rest(_a2, ["stopNow", "returnNow"]);
                if (stopNow) {
                  return [2, new Promise(function() {
                  })];
                }
                this.setState(__assign({
                  loading: true,
                  params
                }, state2));
                if (returnNow) {
                  return [2, Promise.resolve(state2.data)];
                }
                (_f = (_e2 = this.options).onBefore) === null || _f === void 0 ? void 0 : _f.call(_e2, params);
                _q.label = 1;
              case 1:
                _q.trys.push([1, 3, , 4]);
                servicePromise = this.runPluginHandler("onRequest", this.serviceRef.current, params).servicePromise;
                if (!servicePromise) {
                  servicePromise = (_d2 = this.serviceRef).current.apply(_d2, __spreadArray([], __read(params), false));
                }
                return [4, servicePromise];
              case 2:
                res = _q.sent();
                if (currentCount !== this.count) {
                  return [2, new Promise(function() {
                  })];
                }
                this.setState({
                  data: res,
                  error: void 0,
                  loading: false
                });
                (_h = (_g = this.options).onSuccess) === null || _h === void 0 ? void 0 : _h.call(_g, res, params);
                this.runPluginHandler("onSuccess", res, params);
                (_k = (_j = this.options).onFinally) === null || _k === void 0 ? void 0 : _k.call(_j, params, res, void 0);
                if (currentCount === this.count) {
                  this.runPluginHandler("onFinally", params, res, void 0);
                }
                return [2, res];
              case 3:
                error_1 = _q.sent();
                if (currentCount !== this.count) {
                  return [2, new Promise(function() {
                  })];
                }
                this.setState({
                  error: error_1,
                  loading: false
                });
                (_m = (_l = this.options).onError) === null || _m === void 0 ? void 0 : _m.call(_l, error_1, params);
                this.runPluginHandler("onError", error_1, params);
                (_p = (_o = this.options).onFinally) === null || _p === void 0 ? void 0 : _p.call(_o, params, void 0, error_1);
                if (currentCount === this.count) {
                  this.runPluginHandler("onFinally", params, void 0, error_1);
                }
                throw error_1;
              case 4:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
      Fetch2.prototype.run = function() {
        var _this = this;
        var params = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          params[_i] = arguments[_i];
        }
        this.runAsync.apply(this, __spreadArray([], __read(params), false)).catch(function(error) {
          if (!_this.options.onError) {
            console.error(error);
          }
        });
      };
      Fetch2.prototype.cancel = function() {
        this.count += 1;
        this.setState({
          loading: false
        });
        this.runPluginHandler("onCancel");
      };
      Fetch2.prototype.refresh = function() {
        this.run.apply(this, __spreadArray([], __read(this.state.params || []), false));
      };
      Fetch2.prototype.refreshAsync = function() {
        return this.runAsync.apply(this, __spreadArray([], __read(this.state.params || []), false));
      };
      Fetch2.prototype.mutate = function(data2) {
        var targetData = isFunction$2(data2) ? data2(this.state.data) : data2;
        this.runPluginHandler("onMutate", targetData);
        this.setState({
          data: targetData
        });
      };
      return Fetch2;
    }()
  );
  function useRequestImplement(service, options, plugins) {
    if (options === void 0) {
      options = {};
    }
    if (plugins === void 0) {
      plugins = [];
    }
    var _a2 = options.manual, manual = _a2 === void 0 ? false : _a2, _b2 = options.ready, ready = _b2 === void 0 ? true : _b2, rest = __rest(options, ["manual", "ready"]);
    var fetchOptions = __assign({
      manual,
      ready
    }, rest);
    var serviceRef = useLatest(service);
    var update = useUpdate();
    var fetchInstance = useCreation(function() {
      var initState = plugins.map(function(p2) {
        var _a3;
        return (_a3 = p2 === null || p2 === void 0 ? void 0 : p2.onInit) === null || _a3 === void 0 ? void 0 : _a3.call(p2, fetchOptions);
      }).filter(Boolean);
      return new Fetch(serviceRef, fetchOptions, update, Object.assign.apply(Object, __spreadArray([{}], __read(initState), false)));
    }, []);
    fetchInstance.options = fetchOptions;
    fetchInstance.pluginImpls = plugins.map(function(p2) {
      return p2(fetchInstance, fetchOptions);
    });
    useMount(function() {
      if (!manual && ready) {
        var params = fetchInstance.state.params || options.defaultParams || [];
        fetchInstance.run.apply(fetchInstance, __spreadArray([], __read(params), false));
      }
    });
    useUnmount(function() {
      fetchInstance.cancel();
    });
    return {
      loading: fetchInstance.state.loading,
      data: fetchInstance.state.data,
      error: fetchInstance.state.error,
      params: fetchInstance.state.params || [],
      cancel: useMemoizedFn(fetchInstance.cancel.bind(fetchInstance)),
      refresh: useMemoizedFn(fetchInstance.refresh.bind(fetchInstance)),
      refreshAsync: useMemoizedFn(fetchInstance.refreshAsync.bind(fetchInstance)),
      run: useMemoizedFn(fetchInstance.run.bind(fetchInstance)),
      runAsync: useMemoizedFn(fetchInstance.runAsync.bind(fetchInstance)),
      mutate: useMemoizedFn(fetchInstance.mutate.bind(fetchInstance))
    };
  }
  function useRequest(service, options, plugins) {
    return useRequestImplement(service, options, __spreadArray(__spreadArray([], __read([]), false), [useDebouncePlugin, useLoadingDelayPlugin, usePollingPlugin, useRefreshOnWindowFocusPlugin, useThrottlePlugin, useAutoRunPlugin, useCachePlugin, useRetryPlugin], false));
  }
  function useToggle(defaultValue2, reverseValue) {
    if (defaultValue2 === void 0) {
      defaultValue2 = false;
    }
    var _a2 = __read(H.useState(defaultValue2), 2), state2 = _a2[0], setState = _a2[1];
    var actions = H.useMemo(function() {
      var reverseValueOrigin = !defaultValue2;
      var toggle = function() {
        return setState(function(s2) {
          return s2 === defaultValue2 ? reverseValueOrigin : defaultValue2;
        });
      };
      var set2 = function(value) {
        return setState(value);
      };
      var setLeft = function() {
        return setState(defaultValue2);
      };
      var setRight = function() {
        return setState(reverseValueOrigin);
      };
      return {
        toggle,
        set: set2,
        setLeft,
        setRight
      };
    }, []);
    return [state2, actions];
  }
  function useBoolean(defaultValue2) {
    var _a2 = __read(useToggle(false), 2), state2 = _a2[0], _b2 = _a2[1], toggle = _b2.toggle, set2 = _b2.set;
    var actions = H.useMemo(function() {
      var setTrue = function() {
        return set2(true);
      };
      var setFalse = function() {
        return set2(false);
      };
      return {
        toggle,
        set: function(v) {
          return set2(!!v);
        },
        setTrue,
        setFalse
      };
    }, []);
    return [state2, actions];
  }
  function getTargetElement(target, defaultElement) {
    if (!isBrowser) {
      return void 0;
    }
    if (!target) {
      return defaultElement;
    }
    var targetElement;
    if (isFunction$2(target)) {
      targetElement = target();
    } else if ("current" in target) {
      targetElement = target.current;
    } else {
      targetElement = target;
    }
    return targetElement;
  }
  var checkIfAllInShadow = function(targets) {
    return targets.every(function(item) {
      var targetElement = getTargetElement(item);
      if (!targetElement) return false;
      if (targetElement.getRootNode() instanceof ShadowRoot) return true;
      return false;
    });
  };
  var getShadow = function(node2) {
    if (!node2) {
      return document;
    }
    return node2.getRootNode();
  };
  var getDocumentOrShadow = function(target) {
    if (!target || !document.getRootNode) {
      return document;
    }
    var targets = Array.isArray(target) ? target : [target];
    if (checkIfAllInShadow(targets)) {
      return getShadow(getTargetElement(targets[0]));
    }
    return document;
  };
  var createEffectWithTarget = function(useEffectType) {
    var useEffectWithTarget2 = function(effect, deps, target) {
      var hasInitRef = H.useRef(false);
      var lastElementRef = H.useRef([]);
      var lastDepsRef = H.useRef([]);
      var unLoadRef = H.useRef();
      useEffectType(function() {
        var _a2;
        var targets = Array.isArray(target) ? target : [target];
        var els = targets.map(function(item) {
          return getTargetElement(item);
        });
        if (!hasInitRef.current) {
          hasInitRef.current = true;
          lastElementRef.current = els;
          lastDepsRef.current = deps;
          unLoadRef.current = effect();
          return;
        }
        if (els.length !== lastElementRef.current.length || !depsAreSame(lastElementRef.current, els) || !depsAreSame(lastDepsRef.current, deps)) {
          (_a2 = unLoadRef.current) === null || _a2 === void 0 ? void 0 : _a2.call(unLoadRef);
          lastElementRef.current = els;
          lastDepsRef.current = deps;
          unLoadRef.current = effect();
        }
      });
      useUnmount(function() {
        var _a2;
        (_a2 = unLoadRef.current) === null || _a2 === void 0 ? void 0 : _a2.call(unLoadRef);
        hasInitRef.current = false;
      });
    };
    return useEffectWithTarget2;
  };
  var useEffectWithTarget = createEffectWithTarget(H.useEffect);
  function useClickAway(onClickAway, target, eventName) {
    if (eventName === void 0) {
      eventName = "click";
    }
    var onClickAwayRef = useLatest(onClickAway);
    useEffectWithTarget(function() {
      var handler = function(event) {
        var targets = Array.isArray(target) ? target : [target];
        if (targets.some(function(item) {
          var targetElement = getTargetElement(item);
          return !targetElement || targetElement.contains(event.target);
        })) {
          return;
        }
        onClickAwayRef.current(event);
      };
      var documentOrShadow = getDocumentOrShadow(target);
      var eventNames = Array.isArray(eventName) ? eventName : [eventName];
      eventNames.forEach(function(event) {
        return documentOrShadow.addEventListener(event, handler);
      });
      return function() {
        eventNames.forEach(function(event) {
          return documentOrShadow.removeEventListener(event, handler);
        });
      };
    }, Array.isArray(eventName) ? eventName : [eventName], target);
  }
  var reactFastCompare;
  var hasRequiredReactFastCompare;
  function requireReactFastCompare() {
    if (hasRequiredReactFastCompare) return reactFastCompare;
    hasRequiredReactFastCompare = 1;
    var hasElementType = typeof Element !== "undefined";
    var hasMap = typeof Map === "function";
    var hasSet = typeof Set === "function";
    var hasArrayBuffer = typeof ArrayBuffer === "function" && !!ArrayBuffer.isView;
    function equal(a2, b) {
      if (a2 === b) return true;
      if (a2 && b && typeof a2 == "object" && typeof b == "object") {
        if (a2.constructor !== b.constructor) return false;
        var length2, i2, keys;
        if (Array.isArray(a2)) {
          length2 = a2.length;
          if (length2 != b.length) return false;
          for (i2 = length2; i2-- !== 0; )
            if (!equal(a2[i2], b[i2])) return false;
          return true;
        }
        var it;
        if (hasMap && a2 instanceof Map && b instanceof Map) {
          if (a2.size !== b.size) return false;
          it = a2.entries();
          while (!(i2 = it.next()).done)
            if (!b.has(i2.value[0])) return false;
          it = a2.entries();
          while (!(i2 = it.next()).done)
            if (!equal(i2.value[1], b.get(i2.value[0]))) return false;
          return true;
        }
        if (hasSet && a2 instanceof Set && b instanceof Set) {
          if (a2.size !== b.size) return false;
          it = a2.entries();
          while (!(i2 = it.next()).done)
            if (!b.has(i2.value[0])) return false;
          return true;
        }
        if (hasArrayBuffer && ArrayBuffer.isView(a2) && ArrayBuffer.isView(b)) {
          length2 = a2.length;
          if (length2 != b.length) return false;
          for (i2 = length2; i2-- !== 0; )
            if (a2[i2] !== b[i2]) return false;
          return true;
        }
        if (a2.constructor === RegExp) return a2.source === b.source && a2.flags === b.flags;
        if (a2.valueOf !== Object.prototype.valueOf && typeof a2.valueOf === "function" && typeof b.valueOf === "function") return a2.valueOf() === b.valueOf();
        if (a2.toString !== Object.prototype.toString && typeof a2.toString === "function" && typeof b.toString === "function") return a2.toString() === b.toString();
        keys = Object.keys(a2);
        length2 = keys.length;
        if (length2 !== Object.keys(b).length) return false;
        for (i2 = length2; i2-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b, keys[i2])) return false;
        if (hasElementType && a2 instanceof Element) return false;
        for (i2 = length2; i2-- !== 0; ) {
          if ((keys[i2] === "_owner" || keys[i2] === "__v" || keys[i2] === "__o") && a2.$$typeof) {
            continue;
          }
          if (!equal(a2[keys[i2]], b[keys[i2]])) return false;
        }
        return true;
      }
      return a2 !== a2 && b !== b;
    }
    reactFastCompare = function isEqual2(a2, b) {
      try {
        return equal(a2, b);
      } catch (error) {
        if ((error.message || "").match(/stack|recursion/i)) {
          console.warn("react-fast-compare cannot handle circular refs");
          return false;
        }
        throw error;
      }
    };
    return reactFastCompare;
  }
  var reactFastCompareExports = requireReactFastCompare();
  const isEqual$1 = /* @__PURE__ */ getDefaultExportFromCjs(reactFastCompareExports);
  var depsEqual = function(aDeps, bDeps) {
    if (aDeps === void 0) {
      aDeps = [];
    }
    if (bDeps === void 0) {
      bDeps = [];
    }
    return isEqual$1(aDeps, bDeps);
  };
  function useEventListener(eventName, handler, options) {
    if (options === void 0) {
      options = {};
    }
    var _a2 = options.enable, enable = _a2 === void 0 ? true : _a2;
    var handlerRef = useLatest(handler);
    useEffectWithTarget(function() {
      if (!enable) {
        return;
      }
      var targetElement = getTargetElement(options.target, window);
      if (!(targetElement === null || targetElement === void 0 ? void 0 : targetElement.addEventListener)) {
        return;
      }
      var eventListener = function(event) {
        return handlerRef.current(event);
      };
      var eventNameArray = Array.isArray(eventName) ? eventName : [eventName];
      eventNameArray.forEach(function(event) {
        targetElement.addEventListener(event, eventListener, {
          capture: options.capture,
          once: options.once,
          passive: options.passive
        });
      });
      return function() {
        eventNameArray.forEach(function(event) {
          targetElement.removeEventListener(event, eventListener, {
            capture: options.capture
          });
        });
      };
    }, [eventName, options.capture, options.once, options.passive, enable], options.target);
  }
  const useHover = function(target, options) {
    var _a2 = {}, onEnter = _a2.onEnter, onLeave = _a2.onLeave, onChange = _a2.onChange;
    var _b2 = __read(useBoolean(), 2), state2 = _b2[0], _c2 = _b2[1], setTrue = _c2.setTrue, setFalse = _c2.setFalse;
    useEventListener("mouseenter", function() {
      onEnter === null || onEnter === void 0 ? void 0 : onEnter();
      setTrue();
      onChange === null || onChange === void 0 ? void 0 : onChange(true);
    }, {
      target
    });
    useEventListener("mouseleave", function() {
      onLeave === null || onLeave === void 0 ? void 0 : onLeave();
      setFalse();
      onChange === null || onChange === void 0 ? void 0 : onChange(false);
    }, {
      target
    });
    return state2;
  };
  var useDeepCompareEffectWithTarget = function(effect, deps, target) {
    var ref = H.useRef();
    var signalRef = H.useRef(0);
    if (!depsEqual(deps, ref.current)) {
      signalRef.current += 1;
    }
    ref.current = deps;
    useEffectWithTarget(effect, [signalRef.current], target);
  };
  var isAppleDevice = /(mac|iphone|ipod|ipad)/i.test(typeof navigator !== "undefined" ? navigator === null || navigator === void 0 ? void 0 : navigator.platform : "");
  var aliasKeyCodeMap = {
    "0": 48,
    "1": 49,
    "2": 50,
    "3": 51,
    "4": 52,
    "5": 53,
    "6": 54,
    "7": 55,
    "8": 56,
    "9": 57,
    backspace: 8,
    tab: 9,
    enter: 13,
    shift: 16,
    ctrl: 17,
    alt: 18,
    pausebreak: 19,
    capslock: 20,
    esc: 27,
    space: 32,
    pageup: 33,
    pagedown: 34,
    end: 35,
    home: 36,
    leftarrow: 37,
    uparrow: 38,
    rightarrow: 39,
    downarrow: 40,
    insert: 45,
    delete: 46,
    a: 65,
    b: 66,
    c: 67,
    d: 68,
    e: 69,
    f: 70,
    g: 71,
    h: 72,
    i: 73,
    j: 74,
    k: 75,
    l: 76,
    m: 77,
    n: 78,
    o: 79,
    p: 80,
    q: 81,
    r: 82,
    s: 83,
    t: 84,
    u: 85,
    v: 86,
    w: 87,
    x: 88,
    y: 89,
    z: 90,
    leftwindowkey: 91,
    rightwindowkey: 92,
    meta: isAppleDevice ? [91, 93] : [91, 92],
    selectkey: 93,
    numpad0: 96,
    numpad1: 97,
    numpad2: 98,
    numpad3: 99,
    numpad4: 100,
    numpad5: 101,
    numpad6: 102,
    numpad7: 103,
    numpad8: 104,
    numpad9: 105,
    multiply: 106,
    add: 107,
    subtract: 109,
    decimalpoint: 110,
    divide: 111,
    f1: 112,
    f2: 113,
    f3: 114,
    f4: 115,
    f5: 116,
    f6: 117,
    f7: 118,
    f8: 119,
    f9: 120,
    f10: 121,
    f11: 122,
    f12: 123,
    numlock: 144,
    scrolllock: 145,
    semicolon: 186,
    equalsign: 187,
    comma: 188,
    dash: 189,
    period: 190,
    forwardslash: 191,
    graveaccent: 192,
    openbracket: 219,
    backslash: 220,
    closebracket: 221,
    singlequote: 222
  };
  var modifierKey = {
    ctrl: function(event) {
      return event.ctrlKey;
    },
    shift: function(event) {
      return event.shiftKey;
    },
    alt: function(event) {
      return event.altKey;
    },
    meta: function(event) {
      if (event.type === "keyup") {
        return aliasKeyCodeMap.meta.includes(event.keyCode);
      }
      return event.metaKey;
    }
  };
  function isValidKeyType(value) {
    return isString(value) || isNumber(value);
  }
  function countKeyByEvent(event) {
    var countOfModifier = Object.keys(modifierKey).reduce(function(total, key) {
      if (modifierKey[key](event)) {
        return total + 1;
      }
      return total;
    }, 0);
    return [16, 17, 18, 91, 92].includes(event.keyCode) ? countOfModifier : countOfModifier + 1;
  }
  function genFilterKey(event, keyFilter, exactMatch) {
    var e_1, _a2;
    if (!event.key) {
      return false;
    }
    if (isNumber(keyFilter)) {
      return event.keyCode === keyFilter ? keyFilter : false;
    }
    var genArr = keyFilter.split(".");
    var genLen = 0;
    try {
      for (var genArr_1 = __values(genArr), genArr_1_1 = genArr_1.next(); !genArr_1_1.done; genArr_1_1 = genArr_1.next()) {
        var key = genArr_1_1.value;
        var genModifier = modifierKey[key];
        var aliasKeyCode = aliasKeyCodeMap[key.toLowerCase()];
        if (genModifier && genModifier(event) || aliasKeyCode && aliasKeyCode === event.keyCode) {
          genLen++;
        }
      }
    } catch (e_1_1) {
      e_1 = {
        error: e_1_1
      };
    } finally {
      try {
        if (genArr_1_1 && !genArr_1_1.done && (_a2 = genArr_1.return)) _a2.call(genArr_1);
      } finally {
        if (e_1) throw e_1.error;
      }
    }
    if (exactMatch) {
      return genLen === genArr.length && countKeyByEvent(event) === genArr.length ? keyFilter : false;
    }
    return genLen === genArr.length ? keyFilter : false;
  }
  function genKeyFormatter(keyFilter, exactMatch) {
    if (isFunction$2(keyFilter)) {
      return keyFilter;
    }
    if (isValidKeyType(keyFilter)) {
      return function(event) {
        return genFilterKey(event, keyFilter, exactMatch);
      };
    }
    if (Array.isArray(keyFilter)) {
      return function(event) {
        return keyFilter.find(function(item) {
          return genFilterKey(event, item, exactMatch);
        });
      };
    }
    return function() {
      return Boolean(keyFilter);
    };
  }
  var defaultEvents = ["keydown"];
  function useKeyPress(keyFilter, eventHandler, option) {
    var _a2 = option || {}, _b2 = _a2.events, events2 = _b2 === void 0 ? defaultEvents : _b2, target = _a2.target, _c2 = _a2.exactMatch, exactMatch = _c2 === void 0 ? false : _c2, _d2 = _a2.useCapture, useCapture = _d2 === void 0 ? false : _d2;
    var eventHandlerRef = useLatest(eventHandler);
    var keyFilterRef = useLatest(keyFilter);
    useDeepCompareEffectWithTarget(function() {
      var e_2, _a3;
      var _b3;
      var el = getTargetElement(target, window);
      if (!el) {
        return;
      }
      var callbackHandler = function(event) {
        var _a4;
        var genGuard = genKeyFormatter(keyFilterRef.current, exactMatch);
        var keyGuard = genGuard(event);
        var firedKey = isValidKeyType(keyGuard) ? keyGuard : event.key;
        if (keyGuard) {
          return (_a4 = eventHandlerRef.current) === null || _a4 === void 0 ? void 0 : _a4.call(eventHandlerRef, event, firedKey);
        }
      };
      try {
        for (var events_1 = __values(events2), events_1_1 = events_1.next(); !events_1_1.done; events_1_1 = events_1.next()) {
          var eventName = events_1_1.value;
          (_b3 = el === null || el === void 0 ? void 0 : el.addEventListener) === null || _b3 === void 0 ? void 0 : _b3.call(el, eventName, callbackHandler, useCapture);
        }
      } catch (e_2_1) {
        e_2 = {
          error: e_2_1
        };
      } finally {
        try {
          if (events_1_1 && !events_1_1.done && (_a3 = events_1.return)) _a3.call(events_1);
        } finally {
          if (e_2) throw e_2.error;
        }
      }
      return function() {
        var e_3, _a4;
        var _b4;
        try {
          for (var events_2 = __values(events2), events_2_1 = events_2.next(); !events_2_1.done; events_2_1 = events_2.next()) {
            var eventName2 = events_2_1.value;
            (_b4 = el === null || el === void 0 ? void 0 : el.removeEventListener) === null || _b4 === void 0 ? void 0 : _b4.call(el, eventName2, callbackHandler, useCapture);
          }
        } catch (e_3_1) {
          e_3 = {
            error: e_3_1
          };
        } finally {
          try {
            if (events_2_1 && !events_2_1.done && (_a4 = events_2.return)) _a4.call(events_2);
          } finally {
            if (e_3) throw e_3.error;
          }
        }
      };
    }, [events2], target);
  }
  function useLockFn(fn) {
    var _this = this;
    var lockRef = H.useRef(false);
    return H.useCallback(function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return __awaiter(_this, void 0, void 0, function() {
        var ret, e_1;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              if (lockRef.current) return [
                2
                /*return*/
              ];
              lockRef.current = true;
              _a2.label = 1;
            case 1:
              _a2.trys.push([1, 3, 4, 5]);
              return [4, fn.apply(void 0, __spreadArray([], __read(args), false))];
            case 2:
              ret = _a2.sent();
              return [2, ret];
            case 3:
              e_1 = _a2.sent();
              throw e_1;
            case 4:
              lockRef.current = false;
              return [
                7
                /*endfinally*/
              ];
            case 5:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }, [fn]);
  }
  function useRafState(initialState) {
    var ref = H.useRef(0);
    var _a2 = __read(H.useState(initialState), 2), state2 = _a2[0], setState = _a2[1];
    var setRafState = H.useCallback(function(value) {
      cancelAnimationFrame(ref.current);
      ref.current = requestAnimationFrame(function() {
        setState(value);
      });
    }, []);
    useUnmount(function() {
      cancelAnimationFrame(ref.current);
    });
    return [state2, setRafState];
  }
  var defaultShouldUpdate = function(a2, b) {
    return !Object.is(a2, b);
  };
  function usePrevious$1(state2, shouldUpdate) {
    if (shouldUpdate === void 0) {
      shouldUpdate = defaultShouldUpdate;
    }
    var prevRef = H.useRef();
    var curRef = H.useRef();
    if (shouldUpdate(curRef.current, state2)) {
      prevRef.current = curRef.current;
      curRef.current = state2;
    }
    return prevRef.current;
  }
  var useUnmountedRef = function() {
    var unmountedRef = H.useRef(false);
    H.useEffect(function() {
      unmountedRef.current = false;
      return function() {
        unmountedRef.current = true;
      };
    }, []);
    return unmountedRef;
  };
  const useUpdateLayoutEffect = createUpdateEffect(H.useLayoutEffect);
  const $darkMode = valtioFactory(() => {
    return document.body.classList.contains("dark") || document.body.classList.contains("bilibili-helper-dark-mode") || document.documentElement.classList.contains("dark");
  });
  function useIsDarkMode() {
    return $darkMode.use();
  }
  const $colors = valtioFactory(() => {
    const bg = window.getComputedStyle(document.body).backgroundColor;
    const c2 = window.getComputedStyle(document.body).color;
    return {
      bg,
      c: c2
    };
  });
  setTimeout($colors.updateThrottled, 2e3);
  const onDarkModeChange = () => {
    $colors.updateThrottled();
    $darkMode.get() ? document.documentElement.classList.add(appClsDark) : document.documentElement.classList.remove(appClsDark);
  };
  onDarkModeChange();
  subscribe$3($darkMode.state, onDarkModeChange);
  subscribeOnKeys(settings.style.pureRecommend, ["useWhiteBackground"], () => setTimeout($colors.updateThrottled, 500));
  const ob = new MutationObserver(() => {
    setTimeout(() => {
      $darkMode.updateThrottled();
      setTimeout($colors.updateThrottled);
    });
  });
  ob.observe(document.body, {
    attributes: true,
    attributeFilter: ["class"]
  });
  ob.observe(document.documentElement, {
    attributes: true,
    attributeFilter: ["data-darkreader-scheme"]
  });
  document.addEventListener("click", evolvedDarkModeClickHandler, {
    passive: true
  });
  async function evolvedDarkModeClickHandler(e2) {
    const t2 = e2.target;
    if (!t2.closest(EVOLVED_DARK_MODE_SELECTOR)) return;
    await delay(0);
    $darkMode.updateThrottled();
    $colors.updateThrottled();
  }
  window.addEventListener("unload", () => {
    ob.disconnect();
    document.removeEventListener("click", evolvedDarkModeClickHandler);
  });
  const EVOLVED_DARK_MODE_SELECTOR = '.custom-navbar-item[role="listitem"][data-name="darkMode"]';
  const EVOLVED_DARK_MODE_INNER_SELECTOR = '.navbar-dark-mode[item="darkMode"]';
  function toggleEvolvedDarkMode() {
    var _a2;
    (_a2 = document.querySelector(EVOLVED_DARK_MODE_INNER_SELECTOR)) == null ? void 0 : _a2.click();
  }
  function useHotkeyForToggleEvolvedDarkMode() {
    return useKeyPress(
      ["shift.d", "shift.h"],
      // shift + d 被什么 prevent 了
      () => {
        if (shouldDisableShortcut()) return;
        toggleEvolvedDarkMode();
      },
      {
        exactMatch: true
      }
    );
  }
  var jsx2 = function jsx3(type, props) {
    var args = arguments;
    if (props == null || !hasOwn.call(props, "css")) {
      return H__namespace.createElement.apply(void 0, args);
    }
    var argsLength = args.length;
    var createElementArgArray = new Array(argsLength);
    createElementArgArray[0] = Emotion$1;
    createElementArgArray[1] = createEmotionProps(type, props);
    for (var i2 = 2; i2 < argsLength; i2++) {
      createElementArgArray[i2] = args[i2];
    }
    return H__namespace.createElement.apply(null, createElementArgArray);
  };
  (function(_jsx) {
    var JSX;
    /* @__PURE__ */ (function(_JSX) {
    })(JSX || (JSX = _jsx.JSX || (_jsx.JSX = {})));
  })(jsx2 || (jsx2 = {}));
  var Global = /* @__PURE__ */ withEmotionCache(function(props, cache2) {
    var styles = props.styles;
    var serialized = serializeStyles([styles], void 0, H__namespace.useContext(ThemeContext));
    var sheetRef = H__namespace.useRef();
    useInsertionEffectWithLayoutFallback(function() {
      var key = cache2.key + "-global";
      var sheet = new cache2.sheet.constructor({
        key,
        nonce: cache2.sheet.nonce,
        container: cache2.sheet.container,
        speedy: cache2.sheet.isSpeedy
      });
      var rehydrating = false;
      var node2 = document.querySelector('style[data-emotion="' + key + " " + serialized.name + '"]');
      if (cache2.sheet.tags.length) {
        sheet.before = cache2.sheet.tags[0];
      }
      if (node2 !== null) {
        rehydrating = true;
        node2.setAttribute("data-emotion", key);
        sheet.hydrate([node2]);
      }
      sheetRef.current = [sheet, rehydrating];
      return function() {
        sheet.flush();
      };
    }, [cache2]);
    useInsertionEffectWithLayoutFallback(function() {
      var sheetRefCurrent = sheetRef.current;
      var sheet = sheetRefCurrent[0], rehydrating = sheetRefCurrent[1];
      if (rehydrating) {
        sheetRefCurrent[1] = false;
        return;
      }
      if (serialized.next !== void 0) {
        insertStyles(cache2, serialized.next, true);
      }
      if (sheet.tags.length) {
        var element = sheet.tags[sheet.tags.length - 1].nextElementSibling;
        sheet.before = element;
        sheet.flush();
      }
      cache2.insert("", serialized, sheet, false);
    }, [cache2, serialized.name]);
    return null;
  });
  function css() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return serializeStyles(args);
  }
  const buttonOpenCss = {
    name: "rmyi3a",
    styles: "color:var(--ant-button-default-hover-color);border-color:var(--ant-button-default-hover-border-color);background:var(--ant-button-default-hover-bg)"
  };
  function useButtonOpenColor() {
    return antd.theme.useToken().token.colorPrimaryHover;
  }
  function usePopoverBorderColor() {
    const {
      popoverBorderColorUseColorPrimary
    } = useSnapshot(settings.style.general);
    const buttonOpenColor = useButtonOpenColor();
    return popoverBorderColorUseColorPrimary ? buttonOpenColor : borderColorValue;
  }
  function useAntLinkCss() {
    const {
      colorLink,
      colorLinkActive,
      colorLinkHover
    } = antd.theme.useToken().token;
    return H.useMemo(() => /* @__PURE__ */ css("color:", colorLink, ";&:visited{color:", colorLink, ";}&:hover{color:", colorLinkHover, ";}&:active{color:", colorLinkActive, ";}", ""), [colorLink, colorLinkActive, colorLinkHover]);
  }
  const APP_CLS_USE_ANT_LINK_COLOR = `${APP_NAMESPACE}--use-ant-link-color`;
  function useAntLinkColorGlobalCss() {
    const s2 = useAntLinkCss();
    return /* @__PURE__ */ css(":root .", APP_CLS_USE_ANT_LINK_COLOR, "{", s2, ";}", "");
  }
  const LX_THEMES = [
    {
      id: "green",
      name: "绿意盎然",
      isDark: false,
      isCustom: false,
      colorPrimary: "rgb(77, 175, 124)",
      colorTheme: "rgb(77, 175, 124)"
    },
    {
      id: "blue",
      name: "蓝田生玉",
      isDark: false,
      isCustom: false,
      colorPrimary: "rgb(52, 152, 219)",
      colorTheme: "rgb(52, 152, 219)"
    },
    {
      id: "blue_plus",
      name: "蛋雅深蓝",
      isDark: false,
      isCustom: false,
      colorPrimary: "rgb(77, 131, 175)",
      colorTheme: "rgb(77, 131, 175)"
    },
    {
      id: "orange",
      name: "橙黄橘绿",
      isDark: false,
      isCustom: false,
      colorPrimary: "rgb(245, 171, 53)",
      colorTheme: "rgb(245, 171, 53)"
    },
    {
      id: "red",
      name: "热情似火",
      isDark: false,
      isCustom: false,
      colorPrimary: "rgb(214, 69, 65)",
      colorTheme: "rgb(214, 69, 65)"
    },
    {
      id: "pink",
      name: "粉装玉琢",
      isDark: false,
      isCustom: false,
      colorPrimary: "rgb(241, 130, 141)",
      colorTheme: "rgb(241, 130, 141)"
    },
    {
      id: "purple",
      name: "重斤球紫",
      isDark: false,
      isCustom: false,
      colorPrimary: "rgb(155, 89, 182)",
      colorTheme: "rgb(155, 89, 182)"
    },
    {
      id: "grey",
      name: "灰常美丽",
      isDark: false,
      isCustom: false,
      colorPrimary: "rgb(108, 122, 137)",
      colorTheme: "rgb(108, 122, 137)"
    },
    {
      id: "ming",
      name: "青出于黑",
      isDark: false,
      isCustom: false,
      colorPrimary: "rgb(51, 110, 123)",
      colorTheme: "rgb(51, 110, 123)"
    },
    {
      id: "blue2",
      name: "清热板蓝",
      isDark: false,
      isCustom: false,
      colorPrimary: "rgb(79, 98, 208)",
      colorTheme: "rgb(79, 98, 208)"
    },
    {
      id: "black",
      name: "黑灯瞎火",
      isDark: true,
      isCustom: false,
      colorPrimary: "rgb(150, 150, 150)",
      colorTheme: "rgb(59,59,59)"
    },
    {
      id: "mid_autumn",
      name: "月里嫦娥",
      isDark: false,
      isCustom: false,
      colorPrimary: "rgb(74, 55, 82)",
      colorTheme: "rgb(74, 55, 82)"
    },
    {
      id: "naruto",
      name: "木叶之村",
      isDark: false,
      isCustom: false,
      colorPrimary: "rgb(87, 144, 167)",
      colorTheme: "rgb(87, 144, 167)"
    },
    {
      id: "china_ink",
      name: "近墨者黑",
      isDark: false,
      isCustom: false,
      colorPrimary: "rgba(47, 47, 47, 1)",
      colorTheme: "rgba(47, 47, 47, 1)"
    },
    {
      id: "happy_new_year",
      name: "新年快乐",
      isDark: false,
      isCustom: false,
      colorPrimary: "rgb(192, 57, 43)",
      colorTheme: "rgb(192, 57, 43)"
    }
  ];
  const DEFAULT_BILI_PINK_THEME = {
    id: "default-bili-pink",
    name: "B站粉",
    isDark: false,
    isCustom: false,
    colorPrimary: "#ff6699"
  };
  const COLOR_PICKER_THEME = {
    id: "color-picker",
    name: "自定义",
    isDark: false,
    isCustom: true,
    colorPrimary: "#ff6699"
  };
  function toThemes(groupName, definitionStr) {
    return definitionStr.split("\n").map((s2) => s2.trim()).filter(Boolean).map((line2) => {
      const [colorPrimary, name] = line2.split(" ").filter(Boolean);
      return {
        id: groupName + ":" + name,
        name,
        colorPrimary
      };
    });
  }
  const LongwashingGroupName = "UP长期洗涤";
  const LongwashingThemes = toThemes(LongwashingGroupName, `
  #0545b2 理想之蓝
  #f4cd00 柠檬黄
  #ef2729 石榴红
  #f89c00 鹿箭
  #233728 黛绿
  #f2b9b7 和熙粉
  #f3cc91 芝士黄
  #6b4c68 葡萄紫
  #ff7227 落日橙
  #004d62 碧海天
  #23909b 洗碧空
  #aeb400 芥丝绿
  #425a17 箬叶青

  #002fa7 克莱因蓝
  #003153 普鲁士蓝
  #01847f 马尔斯绿
  #fbd26a 申布伦黄
  #470024 勃艮第红
  #492d22 凡戴克棕
  `);
  const BIBIBILI_EVOLVED_SYNC_ID = "bilibili-evolved-sync";
  const ThemeGroups = [{
    name: "预设",
    themes: [DEFAULT_BILI_PINK_THEME, {
      id: "bilibili-blue",
      name: "B站蓝",
      colorPrimary: "#00aeec"
    }, {
      id: "app-靓紫",
      name: "靓紫",
      colorPrimary: "#8500ff"
    }, {
      id: BIBIBILI_EVOLVED_SYNC_ID,
      name: "B-Evolved",
      colorPrimary: "var(--theme-color, #f69)",
      tooltip: /* @__PURE__ */ jsxs(Fragment, { children: [
        "使用 Bilibili-Evolved 的主题色",
        /* @__PURE__ */ jsx$1("br", {}),
        "在 Bilibili-Evolved 设置中修改主题色后可能需要刷新页面同步"
      ] })
    }, COLOR_PICKER_THEME]
  }, {
    name: "移动端",
    themes: [{
      id: "app-custom-高能红",
      name: "高能红",
      colorPrimary: "#fd453e"
    }, {
      id: "app-custom-咸蛋黄",
      name: "咸蛋黄",
      colorPrimary: "#ffc034"
    }, {
      id: "app-custom-早苗绿",
      name: "早苗绿",
      colorPrimary: "#85c255"
    }, {
      id: "app-custom-宝石蓝",
      name: "宝石蓝",
      colorPrimary: "#0095ef"
    }, {
      id: "app-custom-罗兰紫",
      name: "罗兰紫",
      colorPrimary: "#a029ac"
    }]
  }, {
    name: "LX Themes",
    themes: LX_THEMES,
    tooltip: /* @__PURE__ */ jsxs(Fragment, { children: [
      "提取自",
      " ",
      /* @__PURE__ */ jsx$1("a", { target: "_blank", href: "https://github.com/lyswhut/lx-music-desktop/", children: "lx-music-desktop" }),
      /* @__PURE__ */ jsx$1("br", {}),
      "Apache License 2.0"
    ] })
  }, {
    name: LongwashingGroupName,
    themes: LongwashingThemes,
    tooltip: /* @__PURE__ */ jsxs(Fragment, { children: [
      "提取自",
      " ",
      /* @__PURE__ */ jsx$1("a", { target: "_blank", href: "https://www.bilibili.com/video/BV1g3411u7Lg/", children: "BV1g3411u7Lg" }),
      " ",
      "&",
      " ",
      /* @__PURE__ */ jsx$1("a", { target: "_blank", href: "https://www.bilibili.com/video/BV1xu411q7sU/", children: "BV1xu411q7sU" })
    ] })
  }];
  const ALL_THEMES = ThemeGroups.map((x) => x.themes).flat();
  function useCurrentTheme() {
    let {
      theme: themeId,
      colorPickerThemeSelectedColor
    } = useSettingsSnapshot();
    themeId || (themeId = DEFAULT_BILI_PINK_THEME.id);
    return H.useMemo(() => {
      const theme2 = ALL_THEMES.find((t2) => t2.id === themeId) || DEFAULT_BILI_PINK_THEME;
      if (theme2.id === COLOR_PICKER_THEME.id && colorPickerThemeSelectedColor) {
        return {
          ...theme2,
          colorPrimary: colorPickerThemeSelectedColor
        };
      }
      return theme2;
    }, [themeId, colorPickerThemeSelectedColor]);
  }
  function useColorPrimaryHex() {
    const currentTheme = useCurrentTheme();
    const evolvedThemeColor = $evolvedThemeColor.use();
    let colorPrimary = currentTheme.colorPrimary;
    if (currentTheme.id === BIBIBILI_EVOLVED_SYNC_ID) {
      colorPrimary = evolvedThemeColor || DEFAULT_BILI_PINK_THEME.colorPrimary;
    }
    return colorPrimary;
  }
  var _ref$f = {
    name: "1ughwg6",
    styles: ".bili-feed4 .bili-header{min-height:64px!important;}"
  };
  var _ref2$8 = {
    name: "19h4ou9",
    styles: "body,.large-header,#i_cecream,.bili-header .bili-header__channel{background-color:var(--bg2);}.bili-header .bili-header__channel .channel-entry-more__link,.bili-header .bili-header__channel .channel-link{background-color:var(--bg1);}"
  };
  var _ref3$3 = {
    name: "ykj9m0",
    styles: "body{background-color:var(--bg1);}"
  };
  var _ref4$2 = {
    name: "xrkb6a",
    styles: "#i_cecream .bili-feed4-layout{display:none;}.desktop-download-tip,.vip-login-tip,.palette-button-adcard{display:none!important;}"
  };
  function GlobalStyle() {
    const colorPrimary = useColorPrimaryHex();
    const {
      pureRecommend,
      style
    } = useSettingsSnapshot();
    const dark = useIsDarkMode();
    const backToTopRight = useBackToTopRight();
    const usingEvolevdHeader = $usingEvolevdHeader.use();
    const width = $headerWidth.use() ?? 90;
    const padding = "0 10px";
    const more = [useAntLinkColorGlobalCss()];
    return /* @__PURE__ */ jsxs(Fragment, { children: [
      /* @__PURE__ */ jsx$1(Global, { styles: [css`
            :root {
              ${appColorPrimaryId}: ${colorPrimary};
              ${appBgId}: ${dark ? "#222" : style.pureRecommend.useWhiteBackground ? `var(--bg1, #fff)` : `var(--bg2, #F6F7F8)`};
            }
          `, more, "", ""] }),
      IN_BILIBILI_HOMEPAGE && pureRecommend && /* @__PURE__ */ jsx$1(Global, { styles: [
        _ref4$2,
        style.pureRecommend.useCustomGrid && /* @__PURE__ */ css("#i_cecream,.bili-feed4 .bili-header,.bili-feed4 .bili-header .bili-header__bar{max-width:unset;}.bili-feed4-layout,.bili-feed4 .bili-header .bili-header__channel{max-width:", width, "%;padding:", padding, ";}", ""),
        style.pureRecommend.useCustomGrid && typeof backToTopRight === "number" && /* @__PURE__ */ css(".", APP_CLS_ROOT, "{--back-top-right:", backToTopRight, "px;}", ""),
        /**
         * extra background-color work for `PureRecommend`
         */
        style.pureRecommend.useWhiteBackground ? _ref3$3 : _ref2$8,
        style.pureRecommend.hideTopChannel && /* @__PURE__ */ css(".bili-header__channel,.bili-header__banner{display:none!important;}", !usingEvolevdHeader && _ref$f, " .bili-feed4 .bili-header .bili-header__bar{&.slide-down,&:not(.slide-down){animation:headerSlideDown 0.3s linear forwards!important;box-shadow:0 2px 4px ", dark ? "rgb(255 255 255 / 5%)" : "rgb(0 0 0 / 8%)", "!important;}}.bili-header__bar:not(.slide-down){background-color:var(--bg1);color:var(--text1);transition:background-color 0.2s linear;animation-name:headerSlideDown;.left-entry{.mini-header__title,.entry-title,.default-entry,.loc-mc-box__text,.download-entry,.loc-entry{color:var(--text1);}}.right-entry .right-entry__outside{.right-entry-text,.right-entry-icon{color:var(--text2);}}}.area-header-wrapper{margin-top:10px;}", ""),
        "",
        ""
      ] })
    ] });
  }
  cache$4.compat = true;
  function compose(...fns) {
    return function(c2) {
      return fns.reduceRight((content, fn) => fn(content), c2);
    };
  }
  function AppRoot({
    children,
    injectGlobalStyle = false,
    antdSetup = false,
    emotionCache = cache$4,
    styleProviderProps
  }) {
    const dark = useIsDarkMode();
    const colorPrimary = useColorPrimaryHex();
    const wrap = compose(
      // emotion cache
      (c2) => /* @__PURE__ */ jsx$1(CacheProvider, { value: emotionCache, children: c2 }),
      // antd style
      (c2) => /* @__PURE__ */ jsx$1(cssinjs.StyleProvider, { ...styleProviderProps, children: c2 }),
      // antd config
      (c2) => /* @__PURE__ */ jsx$1(antd.ConfigProvider, { locale: zhCN, button: {
        autoInsertSpace: false
      }, theme: {
        cssVar: true,
        algorithm: dark ? antd.theme.darkAlgorithm : antd.theme.defaultAlgorithm,
        token: {
          colorPrimary,
          colorBgSpotlight: colorPrimary,
          // tooltip bg
          zIndexPopupBase: Number(zIndexAntdPopupBase),
          fontFamily: appUsingFont
        },
        components: {
          Notification: {
            zIndexPopup: Number(zIndexAntdPopupBase)
          },
          Button: {
            // the `default` / `primary` shadow is ugly, `danger` shadow 看不出来
            defaultShadow: "none",
            primaryShadow: "none"
          }
        }
      }, children: c2 })
    );
    return wrap(/* @__PURE__ */ jsxs(Fragment, { children: [
      antdSetup && /* @__PURE__ */ jsx$1(AntdStaticFunctionsSetup, {}),
      injectGlobalStyle && /* @__PURE__ */ jsx$1(GlobalStyle, {}),
      children
    ] }));
  }
  function useMittOn(emitter2, type, handler) {
    const fn = useMemoizedFn(handler);
    H.useEffect(() => {
      emitter2.on(type, fn);
      return () => {
        emitter2.off(type, fn);
      };
    }, [emitter2, type]);
  }
  function useRefState(initialValue2) {
    const [state2, setState] = H.useState(initialValue2);
    const ref = H.useRef(state2);
    const setStateWraped = H.useCallback((payload) => {
      const nextState = typeof payload === "function" ? payload(ref.current) : payload;
      ref.current = nextState;
      setState(nextState);
    }, [setState]);
    const getState = H.useCallback(() => ref.current, []);
    return [state2, setStateWraped, getState];
  }
  function useRefStateBox(initialValue2) {
    const [state2, set2, get2] = useRefState(initialValue2);
    const box = H.useMemo(() => ({
      state: state2,
      // use state in render, other case use `.val`
      get: get2,
      set: set2,
      get val() {
        return get2();
      },
      set val(newValue) {
        set2(newValue);
      }
    }), [get2, set2]);
    box.state = state2;
    return box;
  }
  function useRefBox(initialValue2) {
    const ref = H.useRef(initialValue2);
    const get2 = H.useCallback(() => ref.current, []);
    const set2 = H.useCallback((newValue) => ref.current = newValue, []);
    return H.useMemo(() => ({
      get: get2,
      set: set2,
      get val() {
        return get2();
      },
      set val(newValue) {
        set2(newValue);
      }
    }), [get2, set2]);
  }
  function tweakColorWithOklch(originalColor, {
    l: l2,
    c: c2,
    h,
    alpha,
    deltaL,
    deltaC,
    deltaH,
    deltaAlpha
  } = {}) {
    const lValue = l2 ?? (deltaL ? `calc(l + ${deltaL})` : "l");
    const cValue = c2 ?? (deltaC ? `calc(c + ${deltaC})` : "c");
    const hValue = h ?? (deltaH ? `calc(h + ${deltaH})` : "h");
    const alphaValue = alpha ?? (deltaAlpha ? `calc(alpha + ${deltaAlpha})` : "");
    const alphaComponent = alphaValue ? `/ ${alphaValue}` : "";
    return `oklch(from ${originalColor} ${[lValue, cValue, hValue, alphaComponent].filter(Boolean).join(" ")})`;
  }
  function tweakLightness(originalColor, delta) {
    return tweakColorWithOklch(originalColor, {
      deltaL: delta
    });
  }
  function getClassList(className) {
    return uniq((className || "").split(" ").map((x) => x.trim()).filter(Boolean));
  }
  function hasSize(className) {
    return getClassList(className).some((x) => x.startsWith("size-"));
  }
  function hasMarginLeft(className) {
    const classList = getClassList(className);
    return classList.some((x) => x.startsWith("ml-") || x.startsWith("mx-"));
  }
  const iconParkOutlineClose = (props, ref) => /* @__PURE__ */ jsx$1("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref, ...props, children: /* @__PURE__ */ jsx$1("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 4, d: "m8 8l32 32M8 40L40 8" }) });
  const ForwardRef$I = H.forwardRef(iconParkOutlineClose);
  const BaseModalStyle = {
    modalMask: /* @__PURE__ */ css("position:fixed;left:0;top:0;right:0;bottom:0;background-color:rgba(0, 0, 0, 0.5);z-index:", zIndexBaseModal, ";display:flex;align-items:center;justify-content:center;", ""),
    modal: {
      name: "ozops8",
      styles: "width:500px;max-height:calc(90vh - 50px);background-color:#fff;border-radius:10px;padding:0 15px 15px 15px;display:flex;flex-direction:column;overflow:hidden"
    },
    modalHeader: {
      name: "18tqhux",
      styles: "padding-top:10px;padding-bottom:10px;border-bottom:none;display:flex;align-items:center"
    },
    modalBody: {
      name: "18rkbmr",
      styles: "padding-top:0;flex-grow:1;overflow-y:auto"
    },
    modalTitle: {
      name: "m8duop",
      styles: "font-size:1.5rem;margin-bottom:0;line-height:1.5;display:flex;align-items:center"
    }
  };
  let showedCount = 0;
  const modalShowCheck = () => {
    showedCount++;
    document.body.style.overflow = "hidden";
  };
  const modalHideCheck = () => {
    showedCount--;
    if (showedCount < 0) showedCount = 0;
    if (showedCount === 0) {
      document.body.style.overflow = "";
    }
  };
  function BaseModal({
    show,
    onHide: onHide2,
    children,
    clsModalMask,
    cssModalMask,
    clsModal,
    cssModal,
    width,
    hideWhenMaskOnClick = false,
    hideWhenEsc = false
  }) {
    H.useLayoutEffect(() => {
      if (show) {
        modalShowCheck();
      } else {
        modalHideCheck();
      }
    }, [show]);
    const wrapperRef = H.useRef(null);
    const isDarkMode = useIsDarkMode();
    const {
      bg,
      c: c2
    } = H.useMemo(() => {
      const bg2 = window.getComputedStyle(document.body).backgroundColor;
      const c22 = window.getComputedStyle(document.body).color;
      return {
        bg: bg2,
        c: c22
      };
    }, [isDarkMode]);
    const wrapperStyle = H.useMemo(() => {
      return isDarkMode ? {
        "--bg": bg,
        "--c": c2,
        "backgroundColor": bg,
        "color": c2
      } : (
        // 白色不用特殊处理
        {}
      );
    }, [bg, c2, isDarkMode]);
    const containerId = H.useId();
    const container = H.useMemo(() => {
      const div = document.createElement("div");
      div.classList.add(APP_CLS_ROOT);
      div.setAttribute("data-id", "base-modal-" + containerId);
      document.body.appendChild(div);
      return div;
    }, []);
    const onMaskClick = useMemoizedFn((e2) => {
      var _a2;
      const target = e2.target;
      if ((_a2 = wrapperRef.current) == null ? void 0 : _a2.contains(target)) return;
      if (target.closest('.ant-tooltip-inner[role="tooltip"]')) return;
      if (target.closest('.ant-popover-inner[role="tooltip"]')) return;
      if (target.closest(".ant-select-dropdown")) return;
      if (hideWhenMaskOnClick) {
        onHide2();
      }
    });
    useKeyPress("esc", (e2) => {
      if (!show) return;
      if (hideWhenEsc) {
        e2.preventDefault();
        e2.stopImmediatePropagation();
        setTimeout(onHide2);
      }
    });
    if (!show) {
      return null;
    }
    return require$$0.createPortal(/* @__PURE__ */ jsx$1("div", { className: clsModalMask, css: [BaseModalStyle.modalMask, cssModalMask, "", ""], onClick: onMaskClick, children: /* @__PURE__ */ jsx$1("div", { style: {
      ...wrapperStyle,
      width
    }, className: clsModal, css: [BaseModalStyle.modal, cssModal, "", ""], ref: wrapperRef, children }) }), container);
  }
  const ModalClose = ({
    className,
    ...props
  }) => {
    return /* @__PURE__ */ jsx$1(ForwardRef$I, { ...props, className: clsx("cursor-pointer", !hasSize(className) && "size-18px", !hasMarginLeft(className) && "ml-10px", className) });
  };
  function AntdTooltip(props) {
    var _a2;
    return /* @__PURE__ */ jsx$1(antd.Tooltip, { ...props, styles: {
      ...props.styles,
      root: {
        width: "max-content",
        maxWidth: "50vw",
        ...(_a2 = props.styles) == null ? void 0 : _a2.root
      }
    }, children: props.children });
  }
  const iconParkOutlineTips = (props, ref) => /* @__PURE__ */ jsx$1("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref, ...props, children: /* @__PURE__ */ jsxs("g", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 4, children: [
    /* @__PURE__ */ jsx$1("path", { d: "M40 20c0 6.808-4.252 12.622-10.244 14.934H18.244C12.252 32.622 8 26.808 8 20c0-8.837 7.163-16 16-16s16 7.163 16 16" }),
    /* @__PURE__ */ jsx$1("path", { d: "m29.756 34.934l-.68 8.15a1 1 0 0 1-.996.916h-8.16a1 1 0 0 1-.996-.917l-.68-8.15M18 17v6l6-3l6 3v-6" })
  ] }) });
  const ForwardRef$H = H.forwardRef(iconParkOutlineTips);
  const DefaultIconComponent = ForwardRef$H;
  function HelpInfo({
    children,
    tooltipProps,
    IconComponent,
    className,
    ...restSvgProps
  }) {
    const _className = H.useMemo(() => {
      return clsx("cursor-pointer", !hasSize(className) && "size-16px", !hasMarginLeft(className) && "ml-4px", className);
    }, [className]);
    IconComponent ?? (IconComponent = DefaultIconComponent);
    const icon = /* @__PURE__ */ jsx$1(IconComponent, { ...restSvgProps, className: _className });
    return !!children && /* @__PURE__ */ jsx$1(AntdTooltip, { ...tooltipProps, title: children, children: icon });
  }
  function IconAnimatedChecked({
    size = 18,
    useAnimation = false,
    color = "currentColor",
    ...restProps
  }) {
    return /* @__PURE__ */ jsx$1("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", width: size, height: size, ...restProps, children: /* @__PURE__ */ jsx$1(framerMotion.motion.path, { fill: "transparent", stroke: color, strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "2", d: "M5 11L11 17L21 7", ...useAnimation ? {
      initial: {
        pathLength: 0
      },
      animate: {
        pathLength: 1
      },
      transition: {
        duration: 0.2,
        ease: "easeInOut"
      }
    } : void 0 }) });
  }
  var client = {};
  var hasRequiredClient;
  function requireClient() {
    if (hasRequiredClient) return client;
    hasRequiredClient = 1;
    var m = require$$0;
    {
      client.createRoot = m.createRoot;
      client.hydrateRoot = m.hydrateRoot;
    }
    return client;
  }
  var clientExports = requireClient();
  var castComparer = function(comparer) {
    return function(a2, b, order) {
      return comparer(a2, b, order) * order;
    };
  };
  var throwInvalidConfigErrorIfTrue = function(condition, context) {
    if (condition)
      throw Error("Invalid sort config: " + context);
  };
  var unpackObjectSorter = function(sortByObj) {
    var _a2 = sortByObj || {}, asc = _a2.asc, desc = _a2.desc;
    var order = asc ? 1 : -1;
    var sortBy = asc || desc;
    throwInvalidConfigErrorIfTrue(!sortBy, "Expected `asc` or `desc` property");
    throwInvalidConfigErrorIfTrue(asc && desc, "Ambiguous object with `asc` and `desc` config properties");
    var comparer = sortByObj.comparer && castComparer(sortByObj.comparer);
    return { order, sortBy, comparer };
  };
  var multiPropertySorterProvider = function(defaultComparer2) {
    return function multiPropertySorter(sortBy, sortByArr, depth, order, comparer, a2, b) {
      var valA;
      var valB;
      if (typeof sortBy === "string") {
        valA = a2[sortBy];
        valB = b[sortBy];
      } else if (typeof sortBy === "function") {
        valA = sortBy(a2);
        valB = sortBy(b);
      } else {
        var objectSorterConfig = unpackObjectSorter(sortBy);
        return multiPropertySorter(objectSorterConfig.sortBy, sortByArr, depth, objectSorterConfig.order, objectSorterConfig.comparer || defaultComparer2, a2, b);
      }
      var equality = comparer(valA, valB, order);
      if ((equality === 0 || valA == null && valB == null) && sortByArr.length > depth) {
        return multiPropertySorter(sortByArr[depth], sortByArr, depth + 1, order, comparer, a2, b);
      }
      return equality;
    };
  };
  function getSortStrategy(sortBy, comparer, order) {
    if (sortBy === void 0 || sortBy === true) {
      return function(a2, b) {
        return comparer(a2, b, order);
      };
    }
    if (typeof sortBy === "string") {
      throwInvalidConfigErrorIfTrue(sortBy.includes("."), "String syntax not allowed for nested properties.");
      return function(a2, b) {
        return comparer(a2[sortBy], b[sortBy], order);
      };
    }
    if (typeof sortBy === "function") {
      return function(a2, b) {
        return comparer(sortBy(a2), sortBy(b), order);
      };
    }
    if (Array.isArray(sortBy)) {
      var multiPropSorter_1 = multiPropertySorterProvider(comparer);
      return function(a2, b) {
        return multiPropSorter_1(sortBy[0], sortBy, 1, order, comparer, a2, b);
      };
    }
    var objectSorterConfig = unpackObjectSorter(sortBy);
    return getSortStrategy(objectSorterConfig.sortBy, objectSorterConfig.comparer || comparer, objectSorterConfig.order);
  }
  var sortArray = function(order, ctx, sortBy, comparer) {
    var _a2;
    if (!Array.isArray(ctx)) {
      return ctx;
    }
    if (Array.isArray(sortBy) && sortBy.length < 2) {
      _a2 = sortBy, sortBy = _a2[0];
    }
    return ctx.sort(getSortStrategy(sortBy, comparer, order));
  };
  function createNewSortInstance(opts) {
    var comparer = castComparer(opts.comparer);
    return function(arrayToSort) {
      var ctx = Array.isArray(arrayToSort) && !opts.inPlaceSorting ? arrayToSort.slice() : arrayToSort;
      return {
        asc: function(sortBy) {
          return sortArray(1, ctx, sortBy, comparer);
        },
        desc: function(sortBy) {
          return sortArray(-1, ctx, sortBy, comparer);
        },
        by: function(sortBy) {
          return sortArray(1, ctx, sortBy, comparer);
        }
      };
    };
  }
  var defaultComparer = function(a2, b, order) {
    if (a2 == null)
      return order;
    if (b == null)
      return -order;
    if (typeof a2 !== typeof b) {
      return typeof a2 < typeof b ? -1 : 1;
    }
    if (a2 < b)
      return -1;
    if (a2 > b)
      return 1;
    return 0;
  };
  var sort = createNewSortInstance({
    comparer: defaultComparer
  });
  createNewSortInstance({
    comparer: defaultComparer,
    inPlaceSorting: true
  });
  function fastOrderBy(list2, props, orders) {
    if (props.length !== orders.length) {
      throw new Error("props & orders length not match");
    }
    const _by = props.map((prop, index) => {
      const order = orders[index];
      if (order === "asc") return { asc: prop };
      else if (order === "desc") return { desc: prop };
      return {
        asc: prop,
        comparer: order
      };
    });
    return sort(list2).by(_by);
  }
  function fastSortWithOrders(list2, orders) {
    const _by = orders.map(({ order, prop }) => {
      if (order === "asc") return { asc: prop };
      else if (order === "desc") return { desc: prop };
      return { asc: prop, comparer: order };
    });
    return sort(list2).by(_by);
  }
  async function getVideoPlayUrl(videoId, cid, useMp4 = false, preferNormalCdn = false) {
    var _a2, _b2, _c2;
    const params = {
      cid,
      fnver: 0,
      fnval: useMp4 ? 1 : 16
      // 1:mp4, 16:dash
    };
    const _videoId = videoId.toString();
    if (_videoId.startsWith("BV")) {
      params.bvid = _videoId;
    } else if (/^\d+$/.test(_videoId)) {
      params.avid = _videoId;
    } else {
      throw new Error("Invalid videoId provided, must be avid | bvid");
    }
    const res = await request.get("/x/player/wbi/playurl", {
      params
    });
    const json = res.data;
    function getUrlPriority(url) {
      const {
        hostname: hostname2
      } = new URL(url);
      if (preferNormalCdn && (hostname2.includes("mcdn") || hostname2.includes("pcdn"))) {
        return 1;
      }
      return 10;
    }
    function reOrderUrls(urls) {
      return fastOrderBy(urls, [getUrlPriority], ["desc"]);
    }
    if ((_a2 = json == null ? void 0 : json.data) == null ? void 0 : _a2.durl) {
      const urls = (json.data.durl || []).map((x) => [x.url, ...x.backup_url || []]).flat().filter(Boolean);
      if (urls.length) return reOrderUrls(urls);
    }
    const video = fastOrderBy(((_c2 = (_b2 = json.data) == null ? void 0 : _b2.dash) == null ? void 0 : _c2.video) || [], ["id", "codecid"], ["desc", "desc"]);
    const dashUrls = video.map((x) => reOrderUrls([x.baseUrl, ...x.backupUrl || []])[0]).filter(Boolean);
    return dashUrls;
  }
  function getIdbCache(tableName) {
    const db = localforage.createInstance({
      driver: localforage.INDEXEDDB,
      name: APP_NAMESPACE,
      storeName: tableName
    });
    return {
      db,
      get(key) {
        return db.getItem(key.toString());
      },
      set(key, entry) {
        return db.setItem(key.toString(), entry);
      },
      delete(key) {
        return db.removeItem(key.toString());
      }
    };
  }
  function wrapWithIdbCache({
    fn,
    generateKey,
    tableName,
    ttl,
    concurrency,
    // concurrency for `fn`
    autoCleanUp = true
  }) {
    const cache2 = getIdbCache(tableName);
    const cleanUp = throttle$1(async () => {
      cache2.db.iterate((cached, key) => {
        if (!shouldReuseCached(cached)) {
          cache2.db.removeItem(key);
        }
      });
    }, 1e3);
    if (autoCleanUp) {
      whenIdle().then(cleanUp);
    }
    function shouldReuseCached(cached) {
      return Boolean(cached && cached.val && cached.ts && Date.now() - cached.ts <= ttl);
    }
    async function queryCache(...args) {
      const key = generateKey(...args);
      const cached = await cache2.get(key);
      if (cached && shouldReuseCached(cached)) {
        return cached.val;
      }
    }
    const fnMemoized = pMemoize(fn, {
      cacheKey(args) {
        return generateKey(...args);
      },
      cache: {
        async has(key) {
          const cached = await cache2.get(key);
          return shouldReuseCached(cached);
        },
        async get(key) {
          const cached = await cache2.get(key);
          if (cached && shouldReuseCached(cached)) return cached.val;
        },
        async set(key, val) {
          if (isNil(val)) return;
          await cache2.set(key, {
            val,
            ts: Date.now()
          });
        },
        async delete(key) {
          await cache2.delete(key);
        }
      }
    });
    const fnLimited = concurrency && concurrency > 0 ? limitFunction(fnMemoized, {
      concurrency
    }) : fnMemoized;
    Object.defineProperties(fnLimited, {
      cache: {
        value: cache2
      },
      cleanUp: {
        value: cleanUp
      },
      generateKey: {
        value: generateKey
      },
      shouldReuseCached: {
        value: shouldReuseCached
      },
      queryCache: {
        value: queryCache
      }
    });
    return fnLimited;
  }
  async function __fetchVideoDetail(bvid) {
    const res = await request.get("/x/web-interface/view", {
      params: {
        bvid
      }
    });
    const json = res.data;
    const data2 = json.data;
    return data2;
  }
  const getVideoDetail = wrapWithIdbCache({
    fn: __fetchVideoDetail,
    generateKey: (bvid) => bvid,
    tableName: "video-detail",
    ttl: ms("3M"),
    concurrency: 3
  });
  async function __fetchVideoPageList(bvid) {
    const res = await request.get("/x/player/pagelist", {
      params: {
        bvid
      }
    });
    const json = res.data;
    return (json == null ? void 0 : json.data) || [];
  }
  const getVideoPageList = wrapWithIdbCache({
    fn: __fetchVideoPageList,
    generateKey: (bvid) => bvid,
    tableName: "video-page-list",
    ttl: ms("3M"),
    concurrency: 3
  });
  class QuickLRU extends Map {
    constructor(options = {}) {
      super();
      __privateAdd(this, _QuickLRU_instances);
      __privateAdd(this, _size2, 0);
      __privateAdd(this, _cache, /* @__PURE__ */ new Map());
      __privateAdd(this, _oldCache, /* @__PURE__ */ new Map());
      __privateAdd(this, _maxSize);
      __privateAdd(this, _maxAge);
      __privateAdd(this, _onEviction);
      if (!(options.maxSize && options.maxSize > 0)) {
        throw new TypeError("`maxSize` must be a number greater than 0");
      }
      if (typeof options.maxAge === "number" && options.maxAge === 0) {
        throw new TypeError("`maxAge` must be a number greater than 0");
      }
      __privateSet(this, _maxSize, options.maxSize);
      __privateSet(this, _maxAge, options.maxAge || Number.POSITIVE_INFINITY);
      __privateSet(this, _onEviction, options.onEviction);
    }
    // For tests.
    get __oldCache() {
      return __privateGet(this, _oldCache);
    }
    get(key) {
      if (__privateGet(this, _cache).has(key)) {
        const item = __privateGet(this, _cache).get(key);
        return __privateMethod(this, _QuickLRU_instances, getItemValue_fn).call(this, key, item);
      }
      if (__privateGet(this, _oldCache).has(key)) {
        const item = __privateGet(this, _oldCache).get(key);
        if (__privateMethod(this, _QuickLRU_instances, deleteIfExpired_fn).call(this, key, item) === false) {
          __privateMethod(this, _QuickLRU_instances, moveToRecent_fn).call(this, key, item);
          return item.value;
        }
      }
    }
    set(key, value, { maxAge = __privateGet(this, _maxAge) } = {}) {
      const expiry = typeof maxAge === "number" && maxAge !== Number.POSITIVE_INFINITY ? Date.now() + maxAge : void 0;
      if (__privateGet(this, _cache).has(key)) {
        __privateGet(this, _cache).set(key, {
          value,
          expiry
        });
      } else {
        __privateMethod(this, _QuickLRU_instances, set_fn).call(this, key, { value, expiry });
      }
      return this;
    }
    has(key) {
      if (__privateGet(this, _cache).has(key)) {
        return !__privateMethod(this, _QuickLRU_instances, deleteIfExpired_fn).call(this, key, __privateGet(this, _cache).get(key));
      }
      if (__privateGet(this, _oldCache).has(key)) {
        return !__privateMethod(this, _QuickLRU_instances, deleteIfExpired_fn).call(this, key, __privateGet(this, _oldCache).get(key));
      }
      return false;
    }
    peek(key) {
      if (__privateGet(this, _cache).has(key)) {
        return __privateMethod(this, _QuickLRU_instances, peek_fn).call(this, key, __privateGet(this, _cache));
      }
      if (__privateGet(this, _oldCache).has(key)) {
        return __privateMethod(this, _QuickLRU_instances, peek_fn).call(this, key, __privateGet(this, _oldCache));
      }
    }
    delete(key) {
      const deleted = __privateGet(this, _cache).delete(key);
      if (deleted) {
        __privateWrapper(this, _size2)._--;
      }
      return __privateGet(this, _oldCache).delete(key) || deleted;
    }
    clear() {
      __privateGet(this, _cache).clear();
      __privateGet(this, _oldCache).clear();
      __privateSet(this, _size2, 0);
    }
    resize(newSize) {
      if (!(newSize && newSize > 0)) {
        throw new TypeError("`maxSize` must be a number greater than 0");
      }
      const items = [...__privateMethod(this, _QuickLRU_instances, entriesAscending_fn).call(this)];
      const removeCount = items.length - newSize;
      if (removeCount < 0) {
        __privateSet(this, _cache, new Map(items));
        __privateSet(this, _oldCache, /* @__PURE__ */ new Map());
        __privateSet(this, _size2, items.length);
      } else {
        if (removeCount > 0) {
          __privateMethod(this, _QuickLRU_instances, emitEvictions_fn).call(this, items.slice(0, removeCount));
        }
        __privateSet(this, _oldCache, new Map(items.slice(removeCount)));
        __privateSet(this, _cache, /* @__PURE__ */ new Map());
        __privateSet(this, _size2, 0);
      }
      __privateSet(this, _maxSize, newSize);
    }
    *keys() {
      for (const [key] of this) {
        yield key;
      }
    }
    *values() {
      for (const [, value] of this) {
        yield value;
      }
    }
    *[Symbol.iterator]() {
      for (const item of __privateGet(this, _cache)) {
        const [key, value] = item;
        const deleted = __privateMethod(this, _QuickLRU_instances, deleteIfExpired_fn).call(this, key, value);
        if (deleted === false) {
          yield [key, value.value];
        }
      }
      for (const item of __privateGet(this, _oldCache)) {
        const [key, value] = item;
        if (!__privateGet(this, _cache).has(key)) {
          const deleted = __privateMethod(this, _QuickLRU_instances, deleteIfExpired_fn).call(this, key, value);
          if (deleted === false) {
            yield [key, value.value];
          }
        }
      }
    }
    *entriesDescending() {
      let items = [...__privateGet(this, _cache)];
      for (let i2 = items.length - 1; i2 >= 0; --i2) {
        const item = items[i2];
        const [key, value] = item;
        const deleted = __privateMethod(this, _QuickLRU_instances, deleteIfExpired_fn).call(this, key, value);
        if (deleted === false) {
          yield [key, value.value];
        }
      }
      items = [...__privateGet(this, _oldCache)];
      for (let i2 = items.length - 1; i2 >= 0; --i2) {
        const item = items[i2];
        const [key, value] = item;
        if (!__privateGet(this, _cache).has(key)) {
          const deleted = __privateMethod(this, _QuickLRU_instances, deleteIfExpired_fn).call(this, key, value);
          if (deleted === false) {
            yield [key, value.value];
          }
        }
      }
    }
    *entriesAscending() {
      for (const [key, value] of __privateMethod(this, _QuickLRU_instances, entriesAscending_fn).call(this)) {
        yield [key, value.value];
      }
    }
    get size() {
      if (!__privateGet(this, _size2)) {
        return __privateGet(this, _oldCache).size;
      }
      let oldCacheSize = 0;
      for (const key of __privateGet(this, _oldCache).keys()) {
        if (!__privateGet(this, _cache).has(key)) {
          oldCacheSize++;
        }
      }
      return Math.min(__privateGet(this, _size2) + oldCacheSize, __privateGet(this, _maxSize));
    }
    get maxSize() {
      return __privateGet(this, _maxSize);
    }
    entries() {
      return this.entriesAscending();
    }
    forEach(callbackFunction, thisArgument = this) {
      for (const [key, value] of this.entriesAscending()) {
        callbackFunction.call(thisArgument, value, key, this);
      }
    }
    get [Symbol.toStringTag]() {
      return "QuickLRU";
    }
    toString() {
      return `QuickLRU(${this.size}/${this.maxSize})`;
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return this.toString();
    }
  }
  _size2 = new WeakMap();
  _cache = new WeakMap();
  _oldCache = new WeakMap();
  _maxSize = new WeakMap();
  _maxAge = new WeakMap();
  _onEviction = new WeakMap();
  _QuickLRU_instances = new WeakSet();
  emitEvictions_fn = function(cache2) {
    if (typeof __privateGet(this, _onEviction) !== "function") {
      return;
    }
    for (const [key, item] of cache2) {
      __privateGet(this, _onEviction).call(this, key, item.value);
    }
  };
  deleteIfExpired_fn = function(key, item) {
    if (typeof item.expiry === "number" && item.expiry <= Date.now()) {
      if (typeof __privateGet(this, _onEviction) === "function") {
        __privateGet(this, _onEviction).call(this, key, item.value);
      }
      return this.delete(key);
    }
    return false;
  };
  getOrDeleteIfExpired_fn = function(key, item) {
    const deleted = __privateMethod(this, _QuickLRU_instances, deleteIfExpired_fn).call(this, key, item);
    if (deleted === false) {
      return item.value;
    }
  };
  getItemValue_fn = function(key, item) {
    return item.expiry ? __privateMethod(this, _QuickLRU_instances, getOrDeleteIfExpired_fn).call(this, key, item) : item.value;
  };
  peek_fn = function(key, cache2) {
    const item = cache2.get(key);
    return __privateMethod(this, _QuickLRU_instances, getItemValue_fn).call(this, key, item);
  };
  set_fn = function(key, value) {
    __privateGet(this, _cache).set(key, value);
    __privateWrapper(this, _size2)._++;
    if (__privateGet(this, _size2) >= __privateGet(this, _maxSize)) {
      __privateSet(this, _size2, 0);
      __privateMethod(this, _QuickLRU_instances, emitEvictions_fn).call(this, __privateGet(this, _oldCache));
      __privateSet(this, _oldCache, __privateGet(this, _cache));
      __privateSet(this, _cache, /* @__PURE__ */ new Map());
    }
  };
  moveToRecent_fn = function(key, item) {
    __privateGet(this, _oldCache).delete(key);
    __privateMethod(this, _QuickLRU_instances, set_fn).call(this, key, item);
  };
  entriesAscending_fn = function* () {
    for (const item of __privateGet(this, _oldCache)) {
      const [key, value] = item;
      if (!__privateGet(this, _cache).has(key)) {
        const deleted = __privateMethod(this, _QuickLRU_instances, deleteIfExpired_fn).call(this, key, value);
        if (deleted === false) {
          yield item;
        }
      }
    }
    for (const item of __privateGet(this, _cache)) {
      const [key, value] = item;
      const deleted = __privateMethod(this, _QuickLRU_instances, deleteIfExpired_fn).call(this, key, value);
      if (deleted === false) {
        yield item;
      }
    }
  };
  function supportAvif() {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => resolve(true);
      img.onerror = (err) => resolve(false);
      img.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A=";
    });
  }
  const shouldUseAvif = !isSafari && await( supportAvif());
  function getAvatarSrc(avatar) {
    const suffix = shouldUseAvif ? ".avif" : ".webp";
    return `${avatar}@96w_96h_1c_1s_!web-avatar${suffix}`;
  }
  function preloadImg(src) {
    return new Promise((resolve) => {
      const img = new Image();
      img.src = src;
      img.onload = () => resolve(true);
      img.onerror = () => resolve(false);
    });
  }
  function isVideoshotDataValid(videoshotData) {
    var _a2, _b2;
    return Boolean(((_a2 = videoshotData == null ? void 0 : videoshotData.image) == null ? void 0 : _a2.length) && ((_b2 = videoshotData == null ? void 0 : videoshotData.index) == null ? void 0 : _b2.length));
  }
  function isVideoshotJsonCacheable(json) {
    const success = isWebApiSuccess(json);
    if (!success) {
      return true;
    } else {
      return isVideoshotDataValid(json.data);
    }
  }
  async function __fetchVideoshotJson(bvid) {
    const res = await request.get("/x/player/videoshot", {
      params: {
        bvid,
        index: "1"
      }
    });
    const json = res.data;
    if (!isWebApiSuccess(json)) {
      appWarn("videoshot error for %s: %o", bvid, json);
    }
    if (!isVideoshotDataValid(json.data)) {
      appWarn("videoshot data invalid bvid=%s: %o", bvid, json.data);
    }
    return json;
  }
  const videoshotCache = new QuickLRU({
    maxSize: 1e4
  });
  const getVideoshotJson = reusePendingPromise(async (bvid) => {
    if (videoshotCache.has(bvid)) {
      const cached = videoshotCache.get(bvid);
      if (cached) return cached;
    }
    const MAX_RETRY = 5;
    const DELAY = 200;
    let retryTimes = 0;
    let videoshotJson;
    do {
      retryTimes++;
      videoshotJson = await __fetchVideoshotJson(bvid);
      if (isVideoshotJsonCacheable(videoshotJson)) {
        break;
      } else {
        await delay(DELAY);
      }
    } while (retryTimes < MAX_RETRY);
    if (isVideoshotJsonCacheable(videoshotJson)) {
      videoshotCache.set(bvid, videoshotJson);
    }
    const videoshotData = videoshotJson.data;
    if (settings.autoPreviewWhenHover) {
      const imgs = (videoshotData == null ? void 0 : videoshotData.image) || [];
      await preloadImg(imgs[0]);
      (async () => {
        for (const src of imgs.slice(1)) {
          await preloadImg(src);
        }
      })();
    }
    return videoshotJson;
  });
  const debug$c = baseDebug.extend("VideoCard:services");
  function watchlaterFactory(action2) {
    return async function watchlaterOp(avid) {
      const form = new URLSearchParams({
        aid: avid,
        csrf: getCsrfToken()
      });
      const res = await request.post("/x/v2/history/toview/" + action2, form);
      const json = res.data;
      const success = isWebApiSuccess(json);
      if (!success) {
        toast((json == null ? void 0 : json.message) || "出错了");
      }
      return success;
    };
  }
  const watchlaterAdd = watchlaterFactory("add");
  const watchlaterDel = watchlaterFactory("del");
  const dislikeFactory = (type) => {
    const pathname2 = {
      dislike: "/x/feed/dislike",
      cancel: "/x/feed/dislike/cancel"
    }[type];
    return async function(item, reasonId) {
      const res = await gmrequest.get(HOST_APP + pathname2, {
        params: {
          goto: item.goto,
          id: item.param,
          // mid: item.mid,
          // rid: item.tid,
          // tag_id: item.tag?.tag_id,
          reason_id: reasonId,
          // other stuffs
          build: "1",
          mobi_app: "android",
          idx: (Date.now() / 1e3).toFixed(0)
        }
      });
      const json = res.data;
      const success = isWebApiSuccess(json);
      let message2 = json.message;
      if (!success) {
        message2 || (message2 = OPERATION_FAIL_MSG);
        message2 += `(code ${json.code})`;
        message2 += "\n请重新获取 access_key 后重试";
      }
      return {
        success,
        json,
        message: message2
      };
    };
  };
  const dislike = dislikeFactory("dislike");
  const cancelDislike = dislikeFactory("cancel");
  async function fetchImagePreviewData(bvid) {
    const videoshotJson = await getVideoshotJson(bvid);
    return {
      videoshotJson
    };
  }
  function isImagePreviewDataValid(data2) {
    var _a2;
    return isVideoshotDataValid((_a2 = data2 == null ? void 0 : data2.videoshotJson) == null ? void 0 : _a2.data);
  }
  const isVideoPreviewDataValid = (data2) => {
    var _a2;
    return !!((_a2 = data2 == null ? void 0 : data2.playUrls) == null ? void 0 : _a2.length);
  };
  const videoPreviewCache = new QuickLRU({
    maxSize: 1e4,
    maxAge: ms("1h")
  });
  const fetchVideoPreviewData = reusePendingPromise(async ({
    bvid,
    cid,
    useMp4,
    preferNormalCdn,
    aspectRatioFromItem
  }) => {
    var _a2, _b2;
    const cacheKey2 = JSON.stringify([bvid, useMp4, preferNormalCdn]);
    const cached = videoPreviewCache.get(cacheKey2);
    if (cached) return cached;
    let playUrls = [];
    let dimension;
    if (typeof cid === "undefined" || typeof aspectRatioFromItem === "undefined") {
      const pages = await getVideoPageList(bvid);
      cid = (_a2 = pages[0]) == null ? void 0 : _a2.cid;
      dimension = (_b2 = pages[0]) == null ? void 0 : _b2.dimension;
      if (typeof cid === "undefined") {
        throw new Error(`can not get cid by bvid=${bvid}`);
      }
    }
    playUrls = await getVideoPlayUrl(bvid, cid, useMp4, preferNormalCdn);
    debug$c("playUrl: bvid=%s cid=%s %s", bvid, cid, playUrls);
    if (playUrls) {
      videoPreviewCache.set(cacheKey2, {
        playUrls,
        dimension
      });
    }
    return {
      playUrls,
      dimension
    };
  });
  const dislikedIds = proxyMap();
  function useDislikedIds() {
    return useSnapshot(dislikedIds);
  }
  function useDislikedReason(id) {
    const map = useDislikedIds();
    if (!id) return void 0;
    return map.get(id);
  }
  function delDislikeId(id) {
    dislikedIds.delete(id);
  }
  var _ref$e = {
    name: "y8ykai",
    styles: ".ant-spin .ant-spin-dot&{width:25px;height:25px;}"
  };
  function ModalDislike({
    show,
    onHide: onHide2,
    item
  }) {
    const $req = useRequest(async (item2, reason) => dislike(item2, reason.id), {
      manual: true
    });
    const onDislike = useLockFn(async (reason) => {
      if (!item) return;
      let success = false;
      let message2 = "";
      let err;
      try {
        ;
        ({
          success,
          message: message2
        } = await $req.runAsync(item, reason));
      } catch (e2) {
        err = e2;
      }
      if (err) {
        console.error(err.stack || err);
        return toastRequestFail();
      }
      if (success) {
        antMessage.success("已标记不想看");
        dislikedIds.set(item.param, {
          ...reason
        });
        await delay(100);
        onHide2();
      } else {
        antMessage.error(message2 || OPERATION_FAIL_MSG);
      }
    });
    const reasons = H.useMemo(() => {
      var _a2;
      return ((_a2 = item == null ? void 0 : item.three_point) == null ? void 0 : _a2.dislike_reasons) || [];
    }, [item]);
    const modalBodyRef = H.useRef(null);
    const keyPressEnabled = () => !!show && !!item;
    const KEYS = ["1", "2", "3", "4", "5", "6"];
    useKeyPress(KEYS, (e2) => {
      var _a2;
      if (!keyPressEnabled()) return;
      if (!KEYS.includes(e2.key)) return;
      const index = Number(e2.key) - 1;
      if (!(index >= 0 && index < reasons.length)) return;
      setActiveIndex(index);
      const btn = (_a2 = modalBodyRef.current) == null ? void 0 : _a2.querySelectorAll(".reason")[index];
      btn == null ? void 0 : btn.click();
    });
    const [activeIndex, setActiveIndex] = H.useState(reasons.length - 1);
    useUpdateLayoutEffect(() => {
      setActiveIndex(reasons.length - 1);
    }, [reasons]);
    const increaseIndex = useMemoizedFn((by) => {
      if (!keyPressEnabled()) return;
      if (shouldDisableShortcut()) return;
      const len = reasons.length;
      let newIndex = activeIndex + by;
      if (newIndex < 0) newIndex = newIndex % len + len;
      if (newIndex > len - 1) newIndex = newIndex % len;
      setActiveIndex(newIndex);
    });
    useKeyPress("uparrow", () => increaseIndex(-1), {
      exactMatch: true
    });
    useKeyPress("downarrow", () => increaseIndex(1), {
      exactMatch: true
    });
    useKeyPress("enter", (e2) => {
      var _a2;
      if (!keyPressEnabled()) return;
      if (activeIndex < 0 || activeIndex > reasons.length - 1) return;
      e2.preventDefault();
      e2.stopImmediatePropagation();
      const btn = (_a2 = modalBodyRef.current) == null ? void 0 : _a2.querySelector(".reason.active");
      btn == null ? void 0 : btn.click();
    }, {
      exactMatch: true
    });
    return /* @__PURE__ */ jsxs(BaseModal, { show, onHide: onHide2, hideWhenMaskOnClick: true, hideWhenEsc: true, width: 350, clsModal: "rounded-15px", children: [
      /* @__PURE__ */ jsxs("div", { css: BaseModalStyle.modalHeader, className: "justify-between", children: [
        /* @__PURE__ */ jsxs("div", { css: BaseModalStyle.modalTitle, children: [
          /* @__PURE__ */ jsx$1(IconForDislike, { className: "size-25px" }),
          /* @__PURE__ */ jsx$1("span", { className: "ml-5px", children: "我不想看" }),
          /* @__PURE__ */ jsxs(HelpInfo, { children: [
            "选择后将减少相似内容推荐 ",
            /* @__PURE__ */ jsx$1("br", {}),
            "操作说明: ",
            /* @__PURE__ */ jsx$1("br", {}),
            /* @__PURE__ */ jsxs("div", { className: "ml-10px", children: [
              "1. 使用删除键打开弹窗, Esc 关闭 ",
              /* @__PURE__ */ jsx$1("br", {}),
              "2. 数字键直接选择并提交 ",
              /* @__PURE__ */ jsx$1("br", {}),
              "3. 也可以使用方向键选择, 回车键提交 ",
              /* @__PURE__ */ jsx$1("br", {})
            ] })
          ] })
        ] }),
        /* @__PURE__ */ jsx$1(ModalClose, { onClick: onHide2 })
      ] }),
      /* @__PURE__ */ jsx$1("div", { css: BaseModalStyle.modalBody, ref: modalBodyRef, children: /* @__PURE__ */ jsx$1(antd.Spin, { spinning: $req.loading, indicator: /* @__PURE__ */ jsx$1(ForwardRef$P, { className: "text-gate-primary", css: _ref$e }), children: /* @__PURE__ */ jsx$1("div", { className: "reason-list flex flex-col gap-y-10px mt-20px mb-20px", children: reasons.map((reason, index) => {
        const active = index === activeIndex;
        return /* @__PURE__ */ jsxs("button", { "data-id": reason.id, className: clsx("reason", {
          active
        }, "relative flex items-center py-12px rounded-6px b-2px b-solid", active ? "b-gate-primary" : "b-gate-border"), disabled: $req.loading, onClick: () => {
          setActiveIndex(index);
          onDislike(reason);
        }, children: [
          /* @__PURE__ */ jsx$1("span", { "data-cls": "reason-no", className: "flex-none size-20px ml-6px rounded-full flex items-center justify-center color-white", style: {
            backgroundColor: colorPrimaryValue
          }, children: index + 1 }),
          /* @__PURE__ */ jsx$1("span", { className: "flex-1 px-4px", children: reason.name }),
          /* @__PURE__ */ jsx$1("span", { className: "flex-none size-20px mr-6px", children: active && /* @__PURE__ */ jsx$1(IconAnimatedChecked, { className: "w-100% h-100%", color: colorPrimaryValue, useAnimation: true }) })
        ] }, reason.id);
      }) }) }) })
    ] });
  }
  const currentProps = {
    show: false,
    onHide,
    item: null
  };
  const modalDislikeVisibleState = proxy({
    value: currentProps.show
  });
  const useModalDislikeVisible = function() {
    return useSnapshot(modalDislikeVisibleState).value;
  };
  function onHide() {
    setTimeout(() => {
      updateProps({
        show: false,
        item: null
      });
    });
  }
  function updateProps(newProps) {
    Object.assign(currentProps, newProps);
    modalDislikeVisibleState.value = currentProps.show;
    getRoot().render(/* @__PURE__ */ jsx$1(AppRoot, { children: /* @__PURE__ */ jsx$1(ModalDislike, { ...currentProps, onHide }) }));
  }
  let root$1;
  function getRoot() {
    if (!root$1) {
      const container = document.createElement("div");
      container.classList.add("show-dislike-container", APP_CLS_ROOT);
      document.body.appendChild(container);
      root$1 = clientExports.createRoot(container);
    }
    return root$1;
  }
  function showModalDislike(item) {
    if ((item == null ? void 0 : item.param) && dislikedIds.has(item.param)) return;
    updateProps({
      show: true,
      item
    });
  }
  const radixIconsPerson = (props, ref) => /* @__PURE__ */ jsx$1("svg", { viewBox: "0 0 15 15", width: "1.2em", height: "1.2em", ref, ...props, children: /* @__PURE__ */ jsx$1("path", { fill: "currentColor", fillRule: "evenodd", d: "M7.5.875a3.625 3.625 0 0 0-1.006 7.109c-1.194.145-2.218.567-2.99 1.328c-.982.967-1.479 2.408-1.479 4.288a.475.475 0 1 0 .95 0c0-1.72.453-2.88 1.196-3.612c.744-.733 1.856-1.113 3.329-1.113s2.585.38 3.33 1.113c.742.733 1.195 1.892 1.195 3.612a.475.475 0 1 0 .95 0c0-1.88-.497-3.32-1.48-4.288c-.77-.76-1.795-1.183-2.989-1.328A3.627 3.627 0 0 0 7.5.875M4.825 4.5a2.675 2.675 0 1 1 5.35 0a2.675 2.675 0 0 1-5.35 0", clipRule: "evenodd" }) });
  const ForwardRef$G = H.forwardRef(radixIconsPerson);
  const mynauiUsersGroup = (props, ref) => /* @__PURE__ */ jsx$1("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref, ...props, children: /* @__PURE__ */ jsx$1("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 1.5, d: "M17 19.5c0-1.657-2.239-3-5-3s-5 1.343-5 3m14-3c0-1.23-1.234-2.287-3-2.75M3 16.5c0-1.23 1.234-2.287 3-2.75m12-4.014a3 3 0 1 0-4-4.472M6 9.736a3 3 0 0 1 4-4.472m2 8.236a3 3 0 1 1 0-6a3 3 0 0 1 0 6" }) });
  const ForwardRef$F = H.forwardRef(mynauiUsersGroup);
  const tablerPlus = (props, ref) => /* @__PURE__ */ jsx$1("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref, ...props, children: /* @__PURE__ */ jsx$1("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M12 5v14m-7-7h14" }) });
  const ForwardRef$E = H.forwardRef(tablerPlus);
  const IconForUp = ForwardRef$G;
  const IconForGroup = ForwardRef$F;
  const IconForPopoverTrigger = ForwardRef$E;
  function formatFollowGroupUrl(followGroupId) {
    return `https://space.bilibili.com/${getUid()}/fans/follow?tagid=${followGroupId}`;
  }
  function formatSpaceUrl(mid) {
    return `https://space.bilibili.com/${mid}`;
  }
  const cache$2 = dailyCache("w_webid");
  async function get_w_webId() {
    const cached = await cache$2.get();
    if (cached) return cached;
    return __fetch_w_webId();
  }
  const __fetch_w_webId = reusePendingPromise(async () => {
    var _a2, _b2;
    const mid = getUid();
    if (!mid) return;
    const spacePageUrl = formatSpaceUrl(mid);
    const res = await request.get(spacePageUrl, {
      responseType: "text",
      withCredentials: true
    });
    const html2 = res.data;
    const parser = new DOMParser();
    const parsed2 = parser.parseFromString(html2, "text/html");
    const jsonText = decodeURIComponent(((_a2 = parsed2.getElementById("__RENDER_DATA__")) == null ? void 0 : _a2.innerText.trim()) || "");
    if (!jsonText) return;
    const id = (_b2 = JSON.parse(jsonText)) == null ? void 0 : _b2.access_id;
    if (id) await cache$2.set(id);
    return id;
  });
  async function getAllFollowGroups({
    removeEmpty = true
  } = {}) {
    const params = await encWbi({
      web_location: "0.0",
      w_webid: await get_w_webId() || ""
    });
    const res = await request.get("/x/relation/tags", {
      params
    });
    const json = res.data;
    const groups = json.data || [];
    if (removeEmpty) {
      return groups.filter((x) => !!x.count);
    }
    return groups;
  }
  async function getFollowGroupContent(tagid) {
    const ps = 20;
    const singleRequest = async (page) => {
      const res = await request.get("/x/relation/tag", {
        params: {
          mid: getUid(),
          tagid,
          pn: page,
          ps
        }
      });
      const json = res.data;
      return json.data || [];
    };
    let pn = 1;
    let items = [];
    let currentPageItems = [];
    do {
      currentPageItems = await singleRequest(pn++);
      items = items.concat(currentPageItems);
    } while (currentPageItems.length > 0);
    const mids2 = uniq(items.map((x) => x.mid));
    return mids2;
  }
  async function getRecentUpdateUpList() {
    var _a2;
    const res = await request.get("/x/polymer/web-dynamic/v1/portal");
    const json = res.data;
    const list2 = ((_a2 = json == null ? void 0 : json.data) == null ? void 0 : _a2.up_list) || [];
    return list2;
  }
  var DynamicFeedQueryKey = /* @__PURE__ */ ((DynamicFeedQueryKey2) => {
    DynamicFeedQueryKey2["Mid"] = "dyn-mid";
    DynamicFeedQueryKey2["SearchTextFull"] = "dyn-search-text";
    DynamicFeedQueryKey2["SearchTextShort"] = "dyn-search";
    DynamicFeedQueryKey2["Offset"] = "dyn-offset";
    DynamicFeedQueryKey2["MinId"] = "dyn-min-id";
    DynamicFeedQueryKey2["MinTs"] = "dyn-min-ts";
    return DynamicFeedQueryKey2;
  })(DynamicFeedQueryKey || {});
  const searchParams$2 = new URLSearchParams(location.search);
  const QUERY_DYNAMIC_UP_MID = (_b = searchParams$2.get(
    "dyn-mid"
    /* Mid */
  )) == null ? void 0 : _b.trim();
  const QUERY_DYNAMIC_OFFSET = searchParams$2.get(
    "dyn-offset"
    /* Offset */
  ) || void 0;
  const QUERY_DYNAMIC_SEARCH_TEXT = QUERY_DYNAMIC_UP_MID ? searchParams$2.get(
    "dyn-search-text"
    /* SearchTextFull */
  ) || searchParams$2.get(
    "dyn-search"
    /* SearchTextShort */
  ) || void 0 : void 0;
  const QUERY_DYNAMIC_MIN_ID = QUERY_DYNAMIC_UP_MID ? searchParams$2.get(
    "dyn-min-id"
    /* MinId */
  ) : void 0;
  const QUERY_DYNAMIC_MIN_TS = QUERY_DYNAMIC_MIN_ID ? searchParams$2.get(
    "dyn-min-ts"
    /* MinTs */
  ) : void 0;
  const SHOW_DYNAMIC_FEED_ONLY = IN_BILIBILI_HOMEPAGE && !!QUERY_DYNAMIC_UP_MID;
  let upMidInitial = void 0;
  let upNameInitial = void 0;
  if (SHOW_DYNAMIC_FEED_ONLY) {
    upMidInitial = QUERY_DYNAMIC_UP_MID;
    upNameInitial = searchParams$2.get("dyn-name") ?? (upMidInitial == null ? void 0 : upMidInitial.toString()) ?? void 0;
  }
  var DynamicFeedVideoType = /* @__PURE__ */ ((DynamicFeedVideoType2) => {
    DynamicFeedVideoType2["All"] = "all";
    DynamicFeedVideoType2["UploadOnly"] = "upload-only";
    DynamicFeedVideoType2["DynamicOnly"] = "dynamic-only";
    return DynamicFeedVideoType2;
  })(DynamicFeedVideoType || {});
  const DynamicFeedVideoTypeLabel = {
    [
      "all"
      /* All */
    ]: "全部",
    [
      "upload-only"
      /* UploadOnly */
    ]: "仅投稿视频",
    [
      "dynamic-only"
      /* DynamicOnly */
    ]: "仅动态视频"
  };
  var DynamicFeedVideoMinDuration = /* @__PURE__ */ ((DynamicFeedVideoMinDuration2) => {
    DynamicFeedVideoMinDuration2["All"] = "all";
    DynamicFeedVideoMinDuration2["_5m"] = "5min";
    DynamicFeedVideoMinDuration2["_2m"] = "2min";
    DynamicFeedVideoMinDuration2["_1m"] = "1min";
    DynamicFeedVideoMinDuration2["_30s"] = "30s";
    DynamicFeedVideoMinDuration2["_10s"] = "10s";
    return DynamicFeedVideoMinDuration2;
  })(DynamicFeedVideoMinDuration || {});
  const DynamicFeedVideoMinDurationConfig = {
    // 及以上
    [
      "all"
      /* All */
    ]: {
      label: "全部时长",
      duration: 0
    },
    [
      "5min"
      /* _5m */
    ]: {
      label: "5分钟",
      duration: 5 * 60
    },
    [
      "2min"
      /* _2m */
    ]: {
      label: "2分钟",
      duration: 2 * 60
    },
    [
      "1min"
      /* _1m */
    ]: {
      label: "1分钟",
      duration: 60
    },
    [
      "30s"
      /* _30s */
    ]: {
      label: "30秒",
      duration: 30
    },
    [
      "10s"
      /* _10s */
    ]: {
      label: "10秒",
      duration: 10
    }
  };
  const DF_SELECTED_KEY_ALL = "all";
  const DF_SELECTED_KEY_PREFIX_UP = "up:";
  const DF_SELECTED_KEY_PREFIX_GROUP = "group:";
  const hideChargeOnlyVideosForKeysSet = (await( proxySetWithGmStorage("dynamic-feed:hide-charge-only-videos-for-keys"))).set;
  const addSeparatorsMap = (await( proxyMapWithGmStorage("dynamic-feed:add-separators"))).map;
  const dfStore = createDfStore();
  function createDfStore() {
    return proxy({
      upMid: upMidInitial,
      upName: upNameInitial,
      upFace: void 0,
      upList: [],
      upListUpdatedAt: 0,
      groups: [],
      groupsUpdatedAt: 0,
      selectedGroupId: void 0,
      get selectedGroup() {
        if (typeof this.selectedGroupId !== "number") return;
        return this.groups.find((x) => x.tagid === this.selectedGroupId);
      },
      dynamicFeedVideoType: "all",
      searchText: QUERY_DYNAMIC_SEARCH_TEXT ?? void 0,
      // 选择状态
      get viewingAll() {
        return this.selectedKey === DF_SELECTED_KEY_ALL;
      },
      get viewingSomeUp() {
        return !!this.upMid;
      },
      get viewingSomeGroup() {
        return typeof this.selectedGroupId === "number";
      },
      // 筛选 UP & 分组 select 控件的 key
      get selectedKey() {
        if (this.upMid) return `${DF_SELECTED_KEY_PREFIX_UP}${this.upMid}`;
        if (this.selectedGroup) return `${DF_SELECTED_KEY_PREFIX_GROUP}${this.selectedGroup.tagid}`;
        return DF_SELECTED_KEY_ALL;
      },
      hideChargeOnlyVideosForKeysSet,
      get hideChargeOnlyVideos() {
        return this.hideChargeOnlyVideosForKeysSet.has(this.selectedKey);
      },
      addSeparatorsMap,
      get addSeparators() {
        return this.addSeparatorsMap.get("global") ?? false;
      },
      filterMinDuration: "all",
      get filterMinDurationValue() {
        return DynamicFeedVideoMinDurationConfig[this.filterMinDuration].duration;
      },
      /**
       * methods
       */
      updateUpList,
      updateGroups
    });
  }
  proxy({
    followGroupInfo: {}
  });
  async function updateUpList(force = false) {
    const cacheHit = !force && dfStore.upList.length && dfStore.upListUpdatedAt && dfStore.upListUpdatedAt - Date.now() < ms("5min");
    if (cacheHit) return;
    const list2 = await getRecentUpdateUpList();
    dfStore.upList = list2;
    dfStore.upListUpdatedAt = Date.now();
  }
  async function updateGroups(force = false) {
    {
      const {
        followGroup,
        whenViewAll
      } = settings.dynamicFeed;
      const enabled = followGroup.enabled || !!whenViewAll.hideIds.filter((x) => x.startsWith(DF_SELECTED_KEY_PREFIX_GROUP)).length;
      if (!enabled) return;
    }
    const cacheHit = !force && dfStore.groups.length && dfStore.groupsUpdatedAt && dfStore.groupsUpdatedAt - Date.now() < ms("1h");
    if (cacheHit) return;
    dfStore.groups = await getAllFollowGroups({
      removeEmpty: true
    });
    dfStore.groupsUpdatedAt = Date.now();
  }
  async function updateFilterData() {
    if (!getUid()) return;
    return Promise.all([updateUpList(), updateGroups()]);
  }
  void (async () => {
    if (!IN_BILIBILI_HOMEPAGE) return;
    await delay(5e3);
    if (!dfStore.upList.length || !dfStore.groups.length) {
      await whenIdle();
      updateFilterData();
    }
  })();
  if (QUERY_DYNAMIC_UP_MID) {
    subscribeOnKeys(dfStore, ["upName", "searchText", "selectedGroup", "viewingSomeUp", "viewingAll"], ({
      upName,
      searchText,
      selectedGroup,
      viewingSomeUp,
      viewingAll
    }) => {
      let title = viewingAll ? "动态" : viewingSomeUp ? `「${upName}」的动态` : `「${selectedGroup == null ? void 0 : selectedGroup.name}」分组动态`;
      if (searchText) {
        title = `🔍【${searchText}】 - ` + title;
      }
      setPageTitle(title);
    });
  }
  async function fetchFavCollections(page) {
    const res = await request.get("/x/v3/fav/folder/collected/list", {
      params: {
        up_mid: getUid(),
        platform: "web",
        ps: 20,
        pn: page
      }
    });
    const json = res.data;
    return json.data;
  }
  async function fetchAllFavCollections() {
    let page = 1;
    let hasMore = true;
    let items = [];
    while (hasMore) {
      const data2 = await fetchFavCollections(page);
      items.push(...data2.list);
      hasMore = data2.has_more;
      page++;
    }
    items = items.filter((x) => {
      if (x.title === "该合集已失效" && x.upper.mid === 0) return false;
      return true;
    });
    items = uniqBy(items, (x) => x.id);
    return items;
  }
  async function fetchCollectionDetail(collectionId, page) {
    const res = await request.get("/x/space/fav/season/list", {
      params: {
        season_id: collectionId,
        ps: 20,
        pn: page
      }
    });
    const json = res.data;
    return json.data;
  }
  var FavItemsOrder = /* @__PURE__ */ ((FavItemsOrder2) => {
    FavItemsOrder2["Initial"] = "initial";
    FavItemsOrder2["Shuffle"] = "shuffle";
    FavItemsOrder2["PubTimeDesc"] = "pub-time-desc";
    FavItemsOrder2["PubTimeAsc"] = "pub-time-asc";
    FavItemsOrder2["PlayCountDesc"] = "play-count-desc";
    FavItemsOrder2["CollectCountDesc"] = "collect-count-desc";
    FavItemsOrder2["FavTimeDesc"] = "fav-time-desc";
    FavItemsOrder2["FavTimeAsc"] = "fav-time-asc";
    return FavItemsOrder2;
  })(FavItemsOrder || {});
  function handleItemsOrder(items, itemsOrder) {
    if (itemsOrder === "initial") {
      return items;
    }
    if (itemsOrder === "shuffle") {
      return shuffle(items);
    }
    if (itemsOrder === "pub-time-desc" || itemsOrder === "pub-time-asc") {
      const order = itemsOrder === "pub-time-desc" ? "desc" : "asc";
      return orderBy(items, [(x) => x.pubtime], [order]);
    }
    if ((itemsOrder === "fav-time-desc" || itemsOrder === "fav-time-asc") && items.every((x) => x.from === "fav-folder")) {
      const order = itemsOrder === "fav-time-desc" ? "desc" : "asc";
      return orderBy(items, [(x) => x.fav_time], [order]);
    }
    if (itemsOrder === "play-count-desc") {
      return orderBy(items, [(x) => x.cnt_info.play], ["desc"]);
    }
    if (itemsOrder === "collect-count-desc") {
      return orderBy(items, [(x) => x.cnt_info.collect], ["desc"]);
    }
    return items;
  }
  const styled = {
    createClass: css$1,
    c: css$1
  };
  class BaseTabService {
    constructor(qsPageSize) {
      __publicField(this, "qs");
      this.qs = new QueueStrategy(qsPageSize);
    }
    get hasMore() {
      return !!this.qs.bufferQueue.length || this.hasMoreExceptQueue;
    }
    restore() {
      this.qs.restore();
    }
    async loadMore(abortSignal) {
      if (!this.hasMore) return;
      if (this.qs.bufferQueue.length) return this.qs.sliceFromQueue();
      const more = await this.fetchMore(abortSignal);
      if (more == null ? void 0 : more.length) this.qs.bufferQueue.push(...more);
      return this.qs.sliceFromQueue();
    }
  }
  class QueueStrategy {
    constructor(ps = 20) {
      // full-list = returnQueue + bufferQueue + more
      __publicField(this, "returnQueue", []);
      __publicField(this, "bufferQueue", []);
      __publicField(this, "ps");
      this.ps = ps;
    }
    get hasCache() {
      return !!this.returnQueue.length;
    }
    sliceCountFromQueue(count) {
      if (this.bufferQueue.length) {
        const sliced = this.bufferQueue.slice(0, count);
        this.bufferQueue = this.bufferQueue.slice(count);
        return this.doReturnItems(sliced) ?? [];
      } else {
        return [];
      }
    }
    sliceFromQueue(page = 1) {
      return this.sliceCountFromQueue(this.ps * page);
    }
    // add to returnQueue
    doReturnItems(items) {
      this.returnQueue = [...this.returnQueue, ...items ?? []];
      return items;
    }
    // restore from returnQueue
    restore() {
      this.bufferQueue = [...this.returnQueue, ...this.bufferQueue];
      this.returnQueue = [];
    }
    get fetchedCount() {
      return this.returnQueue.length + this.bufferQueue.length;
    }
  }
  function usePopupContainer() {
    const ref = H.useRef(null);
    const getPopupContainer = H.useCallback(() => {
      var _a2;
      return ((_a2 = ref.current) == null ? void 0 : _a2.closest("." + APP_CLS_TAB_BAR)) || document.body;
    }, []);
    return {
      ref,
      getPopupContainer
    };
  }
  function useBooleanSettingsPath(configPath, extraAction) {
    const snap = useSettingsSnapshot();
    const checked = !!get(snap, configPath, false);
    const onChange = H.useCallback((val) => {
      set(settings, configPath, val);
      extraAction == null ? void 0 : extraAction(val);
    }, []);
    const checkboxOnChange = H.useCallback((e2) => {
      onChange(e2.target.checked);
    }, []);
    const onToggle = H.useCallback(() => {
      onChange(!get(settings, configPath, false));
    }, []);
    return {
      checked,
      onChange,
      checkboxOnChange,
      onToggle
    };
  }
  function __FlagSettingItem({
    configPath,
    label,
    extraAction,
    tooltip,
    tooltipProps,
    as,
    checkboxProps,
    switchProps
  }) {
    const {
      checked,
      onChange,
      checkboxOnChange
    } = useBooleanSettingsPath(configPath, extraAction);
    const wrapTooltip = (children) => {
      if (!tooltip) return children;
      return /* @__PURE__ */ jsx$1(AntdTooltip, { ...tooltipProps, title: tooltip, children });
    };
    let usingLabel;
    if (typeof label === "function") {
      usingLabel = label(checked);
    } else {
      usingLabel = label || configPath;
    }
    if (as === "checkbox") {
      let inner = /* @__PURE__ */ jsx$1("span", { style: {
        userSelect: "none"
      }, children: usingLabel });
      if (tooltip) inner = wrapTooltip(inner);
      return /* @__PURE__ */ jsx$1(antd.Checkbox, { ...checkboxProps, checked, onChange: checkboxOnChange, children: inner });
    }
    if (as === "switch") {
      let content = /* @__PURE__ */ jsx$1(antd.Switch, { ...switchProps, checked, onChange });
      if (tooltip) content = wrapTooltip(content);
      return content;
    }
  }
  function CheckboxSettingItem({
    configPath,
    label,
    extraAction,
    tooltip,
    tooltipProps,
    ...otherProps
  }) {
    return /* @__PURE__ */ jsx$1(__FlagSettingItem, { ...{
      configPath,
      label,
      extraAction,
      tooltip,
      tooltipProps,
      as: "checkbox",
      checkboxProps: otherProps
    } });
  }
  function SwitchSettingItem({
    configPath,
    extraAction,
    tooltip,
    tooltipProps,
    ...otherProps
  }) {
    return /* @__PURE__ */ jsx$1(__FlagSettingItem, { ...{
      configPath,
      extraAction,
      tooltip,
      tooltipProps,
      as: "switch",
      switchProps: otherProps
    } });
  }
  class PopularGeneralRecService {
    constructor(anonymous) {
      __publicField(this, "hasMore", true);
      __publicField(this, "page", 1);
      this.anonymous = anonymous;
    }
    async loadMore() {
      if (!this.hasMore) return;
      const res = await request.get("/x/web-interface/popular", {
        params: {
          ps: 20,
          pn: this.page
        },
        withCredentials: !this.anonymous
      });
      const json = res.data;
      if (!isWebApiSuccess(json)) {
        return toast(json.message || REQUEST_FAIL_MSG), void 0;
      }
      this.page++;
      this.hasMore = !json.data.no_more;
      const items = (json.data.list || []).map((item) => {
        return {
          ...item,
          api: EApiType.PopularGeneral,
          uniqId: `${EApiType.PopularGeneral}-${item.bvid}`
        };
      });
      return items;
    }
    get usageInfo() {
      return /* @__PURE__ */ jsx$1(PopularGeneralUsageInfo, {});
    }
  }
  function PopularGeneralUsageInfo() {
    const onRefresh = useOnRefreshContext();
    const tooltip = /* @__PURE__ */ jsx$1(Fragment, { children: "✅ 匿名访问: 使用游客身份访问" });
    const extraAction = async () => {
      await delay(100);
      onRefresh == null ? void 0 : onRefresh();
    };
    const checkbox = /* @__PURE__ */ jsx$1(CheckboxSettingItem, { configPath: "popularGeneralUseAnonymous", tooltip, label: "匿名访问", extraAction });
    return checkbox;
  }
  function getBiliPlayerConfig() {
    const key = "bpx_player_profile";
    const str = localStorage.getItem(key);
    if (!str) return;
    try {
      const val = JSON.parse(str);
      return val;
    } catch {
      return;
    }
  }
  function getBiliPlayerConfigAutoPlay() {
    const config = getBiliPlayerConfig();
    return !!(config == null ? void 0 : config.media.autoplay);
  }
  async function fetchKvData({
    appKey,
    nscode,
    versionId
  }) {
    const params = {
      appKey,
      nscode,
      versionId
    };
    const res = await request.get("/x/kv-frontend/namespace/data", {
      params
    });
    const json = res.data;
    return json;
  }
  function generateCacheKey({
    appKey,
    nscode
  }) {
    return new URLSearchParams([["appKey", appKey], ["nscode", nscode.toString()]]).toString();
  }
  const kvVersionCache = getIdbCache("kv-latest-version");
  const revalidateKvData = reusePendingPromise(async ({
    appKey,
    nscode
  }) => {
    const cacheKey2 = generateCacheKey({
      appKey,
      nscode
    });
    const entry = await kvVersionCache.get(cacheKey2);
    let versionId = "0";
    if (entry && entry.versionId && entry.data && Object.keys(entry.data).length) {
      versionId = entry.versionId;
    }
    const fetched = await fetchKvData({
      appKey,
      nscode,
      versionId
    });
    if ((entry == null ? void 0 : entry.data) && fetched.code === -304 && fetched.message === "Not Modified") {
      return entry.data;
    }
    await kvVersionCache.set(cacheKey2, fetched.data);
    return fetched.data.data;
  });
  const getKvData = wrapWithIdbCache({
    fn: revalidateKvData,
    tableName: "get-kv-data",
    generateKey: ({
      appKey,
      nscode
    }) => generateCacheKey({
      appKey,
      nscode
    }),
    ttl: ms("1h")
  });
  function getGroupFromKvRecord(data2 = {}, prefix2) {
    if (!prefix2.endsWith(".")) prefix2 += ".";
    const grouped = {};
    if (data2) {
      Object.keys(data2).filter((k) => k.startsWith(prefix2)).forEach((k) => {
        const key = k.slice(prefix2.length);
        const val = data2[k] || "";
        grouped[key] = val;
      });
    }
    return grouped;
  }
  const STATIC_RANK_TABS = [{
    tid: 0,
    name: "全部",
    slug: "all",
    season_type: 0,
    type: "all"
  }, {
    tid: 0,
    name: "番剧",
    slug: "anime",
    season_type: 1,
    type: "anime"
  }, {
    tid: 0,
    name: "国创",
    slug: "guochuang",
    season_type: 4,
    type: "guochuang"
  }, {
    tid: 0,
    name: "纪录片",
    slug: "documentary",
    season_type: 3,
    type: "documentary"
  }, {
    tid: 0,
    name: "电影",
    slug: "movie",
    season_type: 2,
    type: "movie"
  }, {
    tid: 0,
    name: "电视剧",
    slug: "tv",
    season_type: 5,
    type: "tv"
  }, {
    tid: 0,
    name: "综艺",
    slug: "variety",
    season_type: 7,
    type: "variety"
  }, {
    tid: 1005,
    name: "动画",
    slug: "douga",
    season_type: 0,
    type: "douga"
  }, {
    tid: 1008,
    name: "游戏",
    slug: "game",
    season_type: 0,
    type: "game"
  }, {
    tid: 1007,
    name: "鬼畜",
    slug: "kichiku",
    season_type: 0,
    type: "kichiku"
  }, {
    tid: 1003,
    name: "音乐",
    slug: "music",
    season_type: 0,
    type: "music"
  }, {
    tid: 1004,
    name: "舞蹈",
    slug: "dance",
    season_type: 0,
    type: "dance"
  }, {
    tid: 1001,
    name: "影视",
    slug: "cinephile",
    season_type: 0,
    type: "cinephile"
  }, {
    tid: 1002,
    name: "娱乐",
    slug: "ent",
    season_type: 0,
    type: "ent"
  }, {
    tid: 1010,
    name: "知识",
    slug: "knowledge",
    season_type: 0,
    type: "knowledge"
  }, {
    tid: 1012,
    name: "科技数码",
    slug: "tech",
    season_type: 0,
    type: "tech"
  }, {
    tid: 1020,
    name: "美食",
    slug: "food",
    season_type: 0,
    type: "food"
  }, {
    tid: 1013,
    name: "汽车",
    slug: "car",
    season_type: 0,
    type: "car"
  }, {
    tid: 1014,
    name: "时尚美妆",
    slug: "fashion",
    season_type: 0,
    type: "fashion"
  }, {
    tid: 1018,
    name: "体育运动",
    slug: "sports",
    season_type: 0,
    type: "sports"
  }, {
    tid: 1024,
    name: "动物",
    slug: "animal",
    season_type: 0,
    type: "animal"
  }];
  const defaultRankTab = {
    name: "全站",
    tid: 0,
    slug: "all"
  };
  async function getRankTabsConfig() {
    try {
      return await parseRankTabsConfig() || STATIC_RANK_TABS;
    } catch (e2) {
      appError("parseRankTabsConfig failed", e2);
      return STATIC_RANK_TABS;
    }
  }
  async function parseRankTabsConfig() {
    const _raw = await getKvData({
      appKey: "333.1339",
      nscode: 10
    });
    const record = getGroupFromKvRecord(_raw, "channel_list");
    const popular_page_sort = JSON.parse(record.popular_page_sort || "");
    if (!popular_page_sort.length) return;
    const list2 = [];
    const push = (obj, isExtra) => {
      list2.push({
        tid: obj.tid || 0,
        name: obj.name,
        slug: obj.route,
        season_type: obj.seasonType || 0,
        type: obj.route,
        isExtra
      });
    };
    for (const slug of popular_page_sort) {
      if (!record[slug]) continue;
      const obj = JSON.parse(record[slug]);
      push(obj);
    }
    for (const [key, str] of Object.entries(record)) {
      const obj = JSON.parse(str);
      if (!obj.name || !obj.route || !obj.tid) continue;
      push(obj, true);
    }
    return uniqBy(list2, (x) => x.slug);
  }
  var ERankApiType = /* @__PURE__ */ ((ERankApiType2) => {
    ERankApiType2["Normal"] = "normal";
    ERankApiType2["PgcSeason"] = "pgc/season";
    ERankApiType2["PgcWeb"] = "pgc/web";
    return ERankApiType2;
  })(ERankApiType || {});
  function getRankTabRequestConfig(rankTab) {
    if (!["anime", "guochuang", "documentary", "movie", "tv", "variety"].includes(rankTab.type || "")) {
      return {
        apiType: "normal",
        url: `/x/web-interface/ranking/v2?rid=${rankTab.tid}&type=all`
      };
    }
    const {
      season_type
    } = rankTab;
    const query = `?day=3&season_type=${season_type}`;
    let url = "/pgc/web/rank/list" + query;
    let apiType = "pgc/web";
    if (season_type && [2, 3, 4, 5, 7].includes(season_type)) {
      url = "/pgc/season/rank/web/list" + query;
      apiType = "pgc/season";
    }
    return {
      apiType,
      url
    };
  }
  function isNormalRankItem(item) {
    return item.from == "normal";
  }
  function isPgcSeasonRankItem(item) {
    return item.from == "pgc/season";
  }
  function isPgcWebRankItem(item) {
    return item.from == "pgc/web";
  }
  function setForwardedRef(forwardedRef, value) {
    if (!forwardedRef) return;
    if (typeof forwardedRef === "function") {
      forwardedRef(value);
    } else {
      forwardedRef.current = value;
    }
  }
  function useMixedRef(forwardedRef) {
    const ref = H.useRef(null);
    return H.useMemo(() => {
      return {
        get current() {
          return ref.current;
        },
        set current(val) {
          ref.current = val;
          setForwardedRef(forwardedRef, val);
        }
      };
    }, [ref]);
  }
  const getZIndex = (inlinePosition) => {
    return {
      left: zIndexLeftMarks,
      right: zIndexRightActions
    }[inlinePosition];
  };
  const S$5 = {
    top: (inlinePosition) => /* @__PURE__ */ css("position:absolute;top:8px;", inlinePosition, ":8px;z-index:", getZIndex(inlinePosition), ";", ""),
    topContainer: (inlinePosition) => [S$5.top(inlinePosition), /* @__PURE__ */ css("display:flex;align-items:center;flex-direction:", inlinePosition === "left" ? "row" : "row-reverse", ";column-gap:5px;", "")],
    tooltip: (inlinePosition, tooltipOffset = 5) => [/* @__PURE__ */ css("position:absolute;bottom:-6px;pointer-events:none;user-select:none;transform:translateY(100%);font-size:12px;white-space:nowrap;border-radius:4px;line-height:18px;padding:4px 8px;color:#fff;background-color:rgba(0, 0, 0, 0.8);background-color:", colorPrimaryValue, ";", ""), css`
      ${inlinePosition}: -${tooltipOffset}px;
    `]
  };
  const buttonInnerSvgCss = {
    name: "8i3ta3",
    styles: "svg{pointer-events:none;user-select:none;}"
  };
  const VideoCardActionButton = H.memo(H.forwardRef(({
    inlinePosition,
    icon,
    tooltip,
    visible = true,
    active = false,
    className,
    useMotion = false,
    motionProps,
    ...divProps
  }, forwardedRef) => {
    const {
      triggerRef,
      tooltipEl
    } = useTooltip({
      inlinePosition,
      tooltip
    });
    const _className = H.useMemo(() => {
      return clsx("action-button", "relative size-28px rounded-6px cursor-pointer bg-[rgb(33_33_33_/_0.7)] color-white", "b-1px b-solid", active ? "b-gate-primary" : "b-#444", "hover:b-gate-primary", useMotion ? "inline-flex" : visible ? "inline-flex" : "hidden", "items-center justify-center", className);
    }, [active, className, visible, useMotion]);
    const sharedProps = {
      ...divProps,
      className: _className,
      css: buttonInnerSvgCss,
      ref: (el) => {
        triggerRef.current = el;
        setForwardedRef(forwardedRef, el);
      },
      children: /* @__PURE__ */ jsxs(Fragment, { children: [
        icon,
        tooltipEl
      ] })
    };
    if (!useMotion) {
      return /* @__PURE__ */ jsx$1("div", { ...sharedProps });
    } else {
      return /* @__PURE__ */ jsx$1(framerMotion.AnimatePresence, { children: visible && /* @__PURE__ */ jsx$1(framerMotion.motion.div, { ...sharedProps, ...motionProps }, "action-button") });
    }
  }));
  function useTooltip({
    inlinePosition,
    tooltip,
    tooltipOffset
  }) {
    const triggerRef = H.useRef(null);
    const hovering = useHover(triggerRef);
    const tooltipEl = /* @__PURE__ */ jsx$1("span", { style: {
      display: hovering ? "block" : "none"
    }, css: S$5.tooltip(inlinePosition, tooltipOffset), children: tooltip });
    return {
      triggerRef,
      tooltipEl
    };
  }
  function createLessFrequentFn(fn, initialTargetTimes, harder = true) {
    let times2 = 0;
    let targetTimes = initialTargetTimes;
    return (...args) => {
      times2++;
      if (times2 === targetTimes) {
        times2 = 0;
        if (harder) targetTimes++;
        return fn(...args);
      }
    };
  }
  function useLessFrequentFn(fn, initialTargetTimes, harder = true) {
    const _fn = useMemoizedFn(fn);
    return H.useMemo(() => {
      return createLessFrequentFn(_fn, initialTargetTimes, harder);
    }, [_fn, initialTargetTimes, harder]);
  }
  const radixIconsOpenInNewWindow = (props, ref) => /* @__PURE__ */ jsx$1("svg", { viewBox: "0 0 15 15", width: "1.2em", height: "1.2em", ref, ...props, children: /* @__PURE__ */ jsx$1("path", { fill: "currentColor", fillRule: "evenodd", d: "M12 13a1 1 0 0 0 1-1V3a1 1 0 0 0-1-1H3a1 1 0 0 0-1 1v3.5a.5.5 0 0 0 1 0V3h9v9H8.5a.5.5 0 0 0 0 1zM9 6.5v3a.5.5 0 0 1-1 0V7.707l-5.146 5.147a.5.5 0 0 1-.708-.708L7.293 7H5.5a.5.5 0 0 1 0-1h3a.5.5 0 0 1 .5.497", clipRule: "evenodd" }) });
  const ForwardRef$D = H.forwardRef(radixIconsOpenInNewWindow);
  const radixIconsCross2 = (props, ref) => /* @__PURE__ */ jsx$1("svg", { viewBox: "0 0 15 15", width: "1.2em", height: "1.2em", ref, ...props, children: /* @__PURE__ */ jsx$1("path", { fill: "currentColor", fillRule: "evenodd", d: "M11.782 4.032a.575.575 0 1 0-.813-.814L7.5 6.687L4.032 3.218a.575.575 0 0 0-.814.814L6.687 7.5l-3.469 3.468a.575.575 0 0 0 .814.814L7.5 8.313l3.469 3.469a.575.575 0 0 0 .813-.814L8.313 7.5z", clipRule: "evenodd" }) });
  const ForwardRef$C = H.forwardRef(radixIconsCross2);
  const radixIconsLockClosed = (props, ref) => /* @__PURE__ */ jsx$1("svg", { viewBox: "0 0 15 15", width: "1.2em", height: "1.2em", ref, ...props, children: /* @__PURE__ */ jsx$1("path", { fill: "currentColor", fillRule: "evenodd", d: "M5 4.636c0-.876.242-1.53.643-1.962c.396-.427 1.003-.696 1.858-.696s1.462.269 1.857.694c.4.431.642 1.085.642 1.961V6H5zM4 6V4.636c0-1.055.293-1.978.91-2.643c.623-.67 1.517-1.015 2.591-1.015s1.969.344 2.59 1.014c.617.664.909 1.587.909 2.641V6h1a1 1 0 0 1 1 1v6a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1zM3 7h9v6H3z", clipRule: "evenodd" }) });
  const ForwardRef$B = H.forwardRef(radixIconsLockClosed);
  const radixIconsLockOpen1 = (props, ref) => /* @__PURE__ */ jsx$1("svg", { viewBox: "0 0 15 15", width: "1.2em", height: "1.2em", ref, ...props, children: /* @__PURE__ */ jsx$1("path", { fill: "currentColor", fillRule: "evenodd", d: "M7.499 0C6.326 0 5.36.39 4.738 1.194C4.238 1.839 4 2.682 4 3.634h1c0-.79.197-1.4.528-1.828c.388-.5 1.024-.806 1.97-.806c.859 0 1.465.265 1.86.686c.4.426.642 1.074.642 1.95V6H3a1 1 0 0 0-1 1v6a1 1 0 0 0 1 1h9a1 1 0 0 0 1-1V7a1 1 0 0 0-1-1h-1V3.636c0-1.055-.293-1.974-.912-2.634C9.465.338 8.57 0 7.498 0M3 7h9v6H3z", clipRule: "evenodd" }) });
  const ForwardRef$A = H.forwardRef(radixIconsLockOpen1);
  function renderInPipWindow(newHref, pipWindow) {
    const cssInsertContainer = pipWindow.document.head;
    const {
      cache: cache2
    } = createEmotion({
      key: "pip-window",
      container: cssInsertContainer
    });
    const container = document.createElement("div");
    container.classList.add(APP_CLS_ROOT);
    container.style.lineHeight = "0";
    pipWindow.document.body.appendChild(container);
    const root2 = clientExports.createRoot(container);
    root2.render(/* @__PURE__ */ jsx$1(AppRoot, { emotionCache: cache2, styleProviderProps: {
      container: cssInsertContainer
    }, injectGlobalStyle: true, children: /* @__PURE__ */ jsx$1(antd.App, { component: false, message: {
      getContainer: () => pipWindow.document.body
    }, children: /* @__PURE__ */ jsx$1(PipWindowContent, { newHref, pipWindow }) }) }));
  }
  var _ref2$7 = {
    name: "jep5v2",
    styles: "width:100%;height:100vh;border:none"
  };
  var _ref3$2 = {
    name: "pb1257",
    styles: "*{box-sizing:border-box;}:root,body,iframe{margin:0;padding:0;overscroll-behavior:none;}"
  };
  function PipWindowContent({
    newHref,
    pipWindow
  }) {
    const hovering = useHover(pipWindow.document.documentElement);
    const [locked, setLocked] = H.useState(() => settings.pipWindow.defaultLocked);
    return /* @__PURE__ */ jsxs(Fragment, { children: [
      /* @__PURE__ */ jsx$1(Global, { styles: [_ref3$2, "", ""] }),
      /* @__PURE__ */ jsx$1("iframe", { src: newHref, css: _ref2$7 }),
      /* @__PURE__ */ jsx$1(LockOverlay, { locked }),
      /* @__PURE__ */ jsxs("div", { css: /* @__PURE__ */ css("position:fixed;z-index:9999;right:10px;top:10px;display:", hovering ? "flex" : "none", ";column-gap:6px;flex-direction:row-reverse;", ""), children: [
        /* @__PURE__ */ jsx$1(CloseThenOpenButton, { pipWindow, newHref }),
        /* @__PURE__ */ jsx$1(LockButton, { locked, setLocked })
      ] })
    ] });
  }
  const S$4 = {
    button: {
      name: "1k4rqoq",
      styles: "svg{width:14px;height:14px;}"
    }
  };
  var _ref$d = {
    name: "pesqi8",
    styles: "position:fixed;inset:0;z-index:9999;background-color:transparent;user-select:none"
  };
  function LockOverlay({
    locked
  }) {
    const {
      message: message2
    } = antd.App.useApp();
    const onOverlayClick = useLessFrequentFn(() => {
      message2.info("请先点击右上角 🔓解锁按钮 解锁");
    }, 3);
    return locked && /* @__PURE__ */ jsx$1("div", { className: "locked-overlay", css: _ref$d, onClick: onOverlayClick });
  }
  function CloseThenOpenButton({
    newHref,
    pipWindow
  }) {
    const onClick = () => {
      pipWindow.close();
      const u2 = new URL(newHref);
      u2.searchParams.delete(QueryKey.PlayerScreenMode);
      u2.searchParams.delete(QueryKey.ForceAutoPlay);
      openNewTab(u2.href);
    };
    return /* @__PURE__ */ jsx$1(VideoCardActionButton, { inlinePosition: "right", icon: /* @__PURE__ */ jsx$1(ForwardRef$D, {}), tooltip: "新窗口打开", onClick, css: S$4.button });
  }
  function LockButton({
    locked,
    setLocked
  }) {
    return /* @__PURE__ */ jsx$1(VideoCardActionButton, { inlinePosition: "right", icon: locked ? /* @__PURE__ */ jsx$1(ForwardRef$B, {}) : /* @__PURE__ */ jsx$1(ForwardRef$A, {}), tooltip: locked ? "已锁定, 点击解锁" : "已解锁, 点击锁定", css: S$4.button, onClick: (e2) => {
      setLocked((x) => !x);
    } });
  }
  const debug$b = baseDebug.extend("VideoCard:useOpenRelated");
  function useOpenRelated({
    href,
    item,
    cardData,
    actionButtonVisible,
    hasOpenInPopupActionButton,
    getLargePreviewCurrentTime,
    hideLargePreview,
    shouldUseLargePreviewCurrentTime
  }) {
    const {
      videoLinkOpenMode
    } = useSettingsSnapshot();
    function getHref(action2) {
      const u2 = new URL(href, location.href);
      action2 == null ? void 0 : action2(u2);
      const newHref = u2.href;
      return newHref;
    }
    const handleVideoLinkClick = useMemoizedFn((e2) => {
      e2.stopPropagation();
      e2.preventDefault();
      onOpenWithMode(void 0, e2);
    });
    const onOpenWithMode = useMemoizedFn((mode, e2) => {
      var _a2;
      mode || (mode = settings.videoLinkOpenMode);
      const newHref = getHref((u2) => {
        if (mode === VideoLinkOpenMode.NormalWebFullscreen || mode === VideoLinkOpenMode.Popup && settings.pipWindow.autoWebFullscreen) {
          u2.searchParams.set(QueryKey.PlayerScreenMode, PlayerScreenMode.WebFullscreen);
          if (mode === VideoLinkOpenMode.Popup && !getBiliPlayerConfigAutoPlay()) {
            u2.searchParams.set(QueryKey.ForceAutoPlay, ForceAutoPlay.ON);
          }
        }
        if (shouldUseLargePreviewCurrentTime()) {
          const largePreviewT = getLargePreviewCurrentTime();
          if (largePreviewT) {
            hideLargePreview();
            u2.searchParams.set("t", largePreviewT.toString());
          }
        }
      });
      const handleCommon = () => {
        const backgroud = mode === VideoLinkOpenMode.Background || !!((e2 == null ? void 0 : e2.metaKey) || (e2 == null ? void 0 : e2.ctrlKey));
        const active = !backgroud;
        openNewTab(newHref, active);
      };
      const handleCurrentPage = () => {
        location.href = newHref;
      };
      const handlers = {
        [VideoLinkOpenMode.Normal]: handleCommon,
        [VideoLinkOpenMode.Background]: handleCommon,
        [VideoLinkOpenMode.CurrentPage]: handleCurrentPage,
        [VideoLinkOpenMode.NormalWebFullscreen]: handleCommon,
        [VideoLinkOpenMode.Popup]: () => handlePopup(newHref),
        [VideoLinkOpenMode.Iina]: handleIINA
      };
      (_a2 = handlers[mode]) == null ? void 0 : _a2.call(handlers);
    });
    function handlePopup(newHref) {
      const {
        width,
        height
      } = getRecItemDimension({
        item
      });
      return openInPipOrPopup(newHref, cardData.bvid, width, height);
    }
    function handleIINA() {
      let usingHref = href;
      if (item.api === EApiType.Watchlater) usingHref = `/video/${item.bvid}`;
      const fullHref = new URL(usingHref, location.href).href;
      const iinaUrl = `iina://open?url=${encodeURIComponent(fullHref)}`;
      window.open(iinaUrl, "_self");
    }
    const consistentOpenMenus = H.useMemo(() => {
      return Object.values(VideoLinkOpenMode).filter((mode) => typeof VideoLinkOpenModeConfig[mode].enabled === "undefined").map((mode) => {
        return {
          key: VideoLinkOpenModeKey[mode],
          label: VideoLinkOpenModeConfig[mode].label,
          icon: VideoLinkOpenModeConfig[mode].icon,
          onClick: () => onOpenWithMode(mode)
        };
      });
    }, []);
    const conditionalOpenMenus = H.useMemo(() => {
      return Object.values(VideoLinkOpenMode).filter((mode) => typeof VideoLinkOpenModeConfig[mode].enabled === "boolean" && VideoLinkOpenModeConfig[mode].enabled).length ? Object.values(VideoLinkOpenMode).filter((mode) => typeof VideoLinkOpenModeConfig[mode].enabled === "boolean" && VideoLinkOpenModeConfig[mode].enabled).map((mode) => {
        return {
          key: VideoLinkOpenModeKey[mode],
          label: VideoLinkOpenModeConfig[mode].label,
          icon: VideoLinkOpenModeConfig[mode].icon,
          onClick: () => onOpenWithMode(mode)
        };
      }) : [];
    }, []);
    const openInPopupActionButtonEl = H.useMemo(() => {
      if (videoLinkOpenMode === VideoLinkOpenMode.Popup) return;
      if (item.api === EApiType.Live) return;
      if (!hasDocumentPictureInPicture) return;
      if (!hasOpenInPopupActionButton) return;
      return /* @__PURE__ */ jsx$1(VideoCardActionButton, { visible: actionButtonVisible, inlinePosition: "right", icon: VideoLinkOpenModeConfig.Popup.icon, tooltip: VideoLinkOpenModeConfig.Popup.label, onClick: (e2) => {
        e2.preventDefault();
        e2.stopPropagation();
        onOpenWithMode(VideoLinkOpenMode.Popup);
      } });
    }, [videoLinkOpenMode, actionButtonVisible]);
    const onOpenInPopup = useMemoizedFn(() => {
      onOpenWithMode(VideoLinkOpenMode.Popup);
    });
    return {
      onOpenWithMode,
      handleVideoLinkClick,
      consistentOpenMenus,
      conditionalOpenMenus,
      openInPopupActionButtonEl,
      onOpenInPopup
    };
  }
  function getRecItemDimension({
    item,
    dimensionFromApi
  }) {
    var _a2;
    let width;
    let height;
    let aspectRatio;
    if (dimensionFromApi) {
      [width, height] = [dimensionFromApi.width, dimensionFromApi.height];
      if (dimensionFromApi.rotate === 1) [width, height] = [height, width];
      aspectRatio = width / height;
    } else if ((item == null ? void 0 : item.api) === EApiType.AppRecommend && ((_a2 = item.uri) == null ? void 0 : _a2.startsWith("bilibili://"))) {
      const searchParams2 = new URL(item.uri).searchParams;
      const playerWidth = Number(searchParams2.get("player_width") || 0);
      const playerHeight = Number(searchParams2.get("player_height") || 0);
      const playerRotate = Number(searchParams2.get("player_rotate") || 0);
      if (playerWidth && playerHeight && !isNaN(playerWidth) && !isNaN(playerHeight)) {
        [width, height] = [playerWidth, playerHeight];
        if (playerRotate === 1) [width, height] = [height, width];
        aspectRatio = width / height;
      }
    } else if ((item == null ? void 0 : item.api) === EApiType.Rank && isNormalRankItem(item)) {
      const w = item.dimension.width;
      const h = item.dimension.height;
      const rotate = item.dimension.rotate;
      if (w && h && !isNaN(w) && !isNaN(h)) {
        [width, height] = [w, h];
        if (rotate === 1) [width, height] = [height, width];
        aspectRatio = width / height;
      }
    }
    return {
      width,
      height,
      aspectRatio
    };
  }
  const hasDocumentPictureInPicture = !!((_c = window.documentPictureInPicture) == null ? void 0 : _c.requestWindow);
  async function openInPipOrPopup(newHref, bvid, videoWidth, videoHeight) {
    var _a2, _b2;
    let popupWidth = 1e3;
    let popupHeight = Math.ceil(popupWidth / 16 * 9);
    const MAX_API_WAIT = 200;
    if ((!videoWidth || !videoHeight) && bvid) {
      const videoPages = await Promise.race([getVideoPageList(bvid), delay(MAX_API_WAIT)]);
      if ((_a2 = videoPages == null ? void 0 : videoPages[0]) == null ? void 0 : _a2.dimension) {
        const {
          dimension
        } = videoPages[0];
        videoWidth = dimension.width;
        videoHeight = dimension.height;
      }
    }
    if (videoWidth && videoHeight && videoWidth < videoHeight) {
      const maxHeight = Math.min(Math.floor(window.screen.availHeight * 0.8), 1e3);
      const maxWidth = Math.floor(maxHeight / videoHeight * videoWidth);
      popupWidth = Math.min(720, maxWidth);
      popupHeight = Math.floor(popupWidth / videoWidth * videoHeight);
    }
    debug$b("openInPipOrPopup newHref=%s size=%sx%s", newHref, popupWidth, popupHeight);
    let pipWindow;
    if (hasDocumentPictureInPicture) {
      try {
        pipWindow = await ((_b2 = window.documentPictureInPicture) == null ? void 0 : _b2.requestWindow({
          width: popupWidth,
          height: popupHeight,
          disallowReturnToOpener: true
        }));
      } catch (e2) {
      }
    }
    if (pipWindow) {
      renderInPipWindow(newHref, pipWindow);
    } else {
      openPopupWindow(newHref, popupWidth, popupHeight);
    }
  }
  function openPopupWindow(newHref, popupWidth, popupHeight) {
    const left = (window.innerWidth - popupWidth) / 2;
    const top = (window.innerHeight - popupHeight) / 2 - 50;
    const features = ["popup=true", `width=${popupWidth}`, `height=${popupHeight}`, `left=${left}`, `top=${top}`].join(",");
    debug$b("openInPopup: features -> %s", features);
    window.open(newHref, "_blank", features);
  }
  function useLinkNewTab() {
    const {
      videoLinkOpenMode
    } = useSettingsSnapshot();
    return videoLinkOpenMode !== VideoLinkOpenMode.CurrentPage;
  }
  function useLinkTarget() {
    const newTab = useLinkNewTab();
    return newTab ? "_blank" : "_self";
  }
  function getLinkTarget() {
    const newTab = settings.videoLinkOpenMode !== VideoLinkOpenMode.CurrentPage;
    return newTab ? "_blank" : "_self";
  }
  function CustomTargetLink(props) {
    const target = useLinkTarget();
    return /* @__PURE__ */ jsx$1("a", { ...props, target, children: props.children });
  }
  function unwrapRef(ref) {
    return ref.value;
  }
  var Dispatcher = class _Dispatcher {
    constructor(executors) {
      __publicField(this, "executorRefs");
      __publicField(this, "idleState");
      __publicField(this, "aborted", false);
      __publicField(this, "pendingResolves", []);
      __publicField(this, "replenish", (executor) => {
        var _a2;
        if (this.aborted) return;
        if (!this.pendingResolves.length) return;
        (_a2 = this.pendingResolves.shift()) == null ? void 0 : _a2();
      });
      if (!executors.length) throw new Error("executors can not be empty");
      this.executorRefs = executors.map((x) => ({ value: x }));
      this.idleState = /* @__PURE__ */ new WeakMap();
      this.executorRefs.forEach((x) => this.idleState.set(x, true));
    }
    static fromConcurrency(concurrency, label = "") {
      if (!isFinite(concurrency)) throw new Error("concurrency must be finite");
      if (!(concurrency > 0)) throw new Error("concurrency must be greater than 0");
      const executors = new Array(concurrency).fill(0).map(
        (_, index) => [label, `executors(${concurrency})`, index].map((x) => x && x.toString().trim()).filter(Boolean).join(".")
      );
      return new _Dispatcher(executors);
    }
    abort() {
      this.aborted = true;
      this.pendingResolves = [];
    }
    async getExecutorRef() {
      const find = () => this.executorRefs.find((x) => this.idleState.get(x));
      let executorRef = find();
      while (!executorRef) {
        const { promise, resolve } = Promise.withResolvers();
        this.pendingResolves.push(resolve);
        await promise;
        executorRef = find();
      }
      this.idleState.set(executorRef, false);
      return executorRef;
    }
    async dispatch(action2) {
      const executorRef = await this.getExecutorRef();
      const executor = unwrapRef(executorRef);
      try {
        return await action2(executor);
      } finally {
        this.idleState.set(executorRef, true);
        setTimeout(() => this.replenish(executorRef));
      }
    }
  };
  async function pmap(arr, fn, concurrency) {
    if (!arr.length) return [];
    concurrency = Math.min(concurrency, arr.length);
    const dispatcher = Dispatcher.fromConcurrency(concurrency, "pmap");
    try {
      return await Promise.all(
        arr.map((item, index) => dispatcher.dispatch(() => fn(item, index, arr)))
      );
    } catch (e2) {
      dispatcher.abort();
      throw e2;
    }
  }
  let episodes = [];
  let cacheKey = "";
  function genCacheKey() {
    const now = dayjs();
    return [now.format("YYYYMMDD"), now.hour() < 18 ? "lt-18" : "gte-18"].join("_");
  }
  async function getEpisodeList() {
    const useCache = episodes.length && cacheKey && cacheKey === genCacheKey();
    if (useCache) return episodes;
    const res = await request.get("/x/web-interface/popular/series/list");
    const json = res.data;
    const list2 = json.data.list;
    episodes = list2;
    cacheKey = genCacheKey();
    return episodes;
  }
  const _PopularWeeklyRecService = class _PopularWeeklyRecService {
    constructor(useShuffle) {
      __publicField(this, "episodesLoaded", false);
      __publicField(this, "episodes", []);
      // full-list = returnedItems + bufferQueue + more
      __publicField(this, "qs", new QueueStrategy(_PopularWeeklyRecService.PAGE_SIZE));
      this.useShuffle = useShuffle;
    }
    get hasMore() {
      if (!this.episodesLoaded) return true;
      return !!this.qs.bufferQueue.length || !!this.episodes.length;
    }
    async loadMore() {
      if (!this.episodesLoaded) {
        this.episodes = await getEpisodeList();
        this.episodesLoaded = true;
        if (this.useShuffle) this.episodes = shuffle(this.episodes);
      }
      if (!this.hasMore) return;
      if (!this.useShuffle) {
        if (this.qs.bufferQueue.length) return this.qs.sliceFromQueue();
        const ep = this.episodes[0];
        const epNum = ep.number;
        const items = await fetchWeeklyItems(epNum);
        this.qs.bufferQueue.push({
          api: EApiType.Separator,
          uniqId: `popular-weekly-separator-${epNum}`,
          content: /* @__PURE__ */ jsx$1(CustomTargetLink, { href: `https://www.bilibili.com/v/popular/weekly?num=${epNum}`, children: ep.name })
        }, ...items);
        this.episodes = this.episodes.slice(1);
        return this.qs.sliceFromQueue();
      }
      const prefetchPage = 5;
      while (this.qs.bufferQueue.length < _PopularWeeklyRecService.PAGE_SIZE * prefetchPage && this.episodes.length) {
        this.episodes = shuffle(this.episodes);
        const episodes2 = this.episodes.slice(0, prefetchPage);
        this.episodes = this.episodes.slice(prefetchPage);
        const fetched = await pmap(episodes2.map((x) => x.number), (episodeNum) => fetchWeeklyItems(episodeNum), 2);
        this.qs.bufferQueue = shuffle([...this.qs.bufferQueue, ...fetched.flat()]);
      }
      return this.qs.sliceFromQueue();
    }
    get usageInfo() {
      return /* @__PURE__ */ jsx$1(PopularWeeklyUsageInfo, {});
    }
  };
  __publicField(_PopularWeeklyRecService, "PAGE_SIZE", 20);
  let PopularWeeklyRecService = _PopularWeeklyRecService;
  const cache$1 = {};
  async function fetchWeeklyItems(episodeNum) {
    var _a2;
    if (!((_a2 = cache$1[episodeNum]) == null ? void 0 : _a2.length)) {
      const res = await request.get("/x/web-interface/popular/series/one", {
        params: {
          number: episodeNum
        }
      });
      const json = res.data;
      const items2 = (json.data.list || []).map((item) => {
        return {
          ...item,
          api: EApiType.PopularWeekly,
          uniqId: `${EApiType.PopularWeekly}-${item.bvid}`
        };
      });
      cache$1[episodeNum] = items2;
    }
    const items = cache$1[episodeNum];
    return items;
  }
  function PopularWeeklyUsageInfo() {
    const onRefresh = useOnRefreshContext();
    return /* @__PURE__ */ jsx$1(Fragment, { children: /* @__PURE__ */ jsx$1(SwitchSettingItem, { configPath: "popularWeeklyUseShuffle", checkedChildren: "随机顺序: 开", unCheckedChildren: "随机顺序: 关", extraAction: async () => {
      await delay(100);
      onRefresh == null ? void 0 : onRefresh();
    } }) });
  }
  const storageKey = "rank-store-slug";
  const initialSlug = await( GM.getValue(storageKey)) || defaultRankTab.slug;
  const rankStore = proxy({
    slug: initialSlug,
    tabs: [],
    get currentTab() {
      return this.tabs.find((x) => x.slug === this.slug) || defaultRankTab;
    }
  });
  const updateRankTabs = reusePendingPromise(async () => {
    if (rankStore.tabs.length) return;
    const rankTabs = await getRankTabsConfig();
    rankStore.tabs = rankTabs;
  });
  subscribeKey(rankStore, "slug", () => {
    GM.setValue(storageKey, rankStore.slug);
  });
  class RankRecService {
    constructor(slug) {
      __publicField(this, "loaded", false);
      __publicField(this, "qs", new QueueStrategy(20));
      this.slug = slug;
    }
    get hasMore() {
      if (!this.loaded) return true;
      return !!this.qs.bufferQueue.length;
    }
    get rankTab() {
      return snapshot(rankStore).tabs.find((x) => x.slug === this.slug) || defaultRankTab;
    }
    async loadMore(abortSignal) {
      var _a2, _b2;
      if (!this.hasMore) return;
      if (!this.loaded) {
        await updateRankTabs();
        const {
          url,
          apiType
        } = getRankTabRequestConfig(this.rankTab);
        const res = await request.get(url, {
          signal: abortSignal
        });
        const json = res.data;
        this.loaded = true;
        if (!isWebApiSuccess(json)) {
          toast(json.message || REQUEST_FAIL_MSG);
          return;
        }
        const list2 = ((_a2 = json == null ? void 0 : json.data) == null ? void 0 : _a2.list) || ((_b2 = json == null ? void 0 : json.result) == null ? void 0 : _b2.list) || [];
        const items = list2.map((item, index) => {
          const rankingNo = index + 1;
          return {
            ...item,
            api: EApiType.Rank,
            uniqId: `${EApiType.Rank}-${this.rankTab.slug}-rankingNo:${rankingNo}`,
            rankingNo,
            slug: this.rankTab.slug,
            rankTab: this.rankTab,
            from: apiType
          };
        });
        this.qs.bufferQueue = items;
      }
      return this.qs.sliceFromQueue();
    }
    get usageInfo() {
      return /* @__PURE__ */ jsx$1(RankUsageInfo, {});
    }
  }
  function RankUsageInfo() {
    const {
      ref,
      getPopupContainer
    } = usePopupContainer();
    const onRefresh = useOnRefreshContext();
    const {
      slug,
      currentTab,
      tabs
    } = useSnapshot(rankStore);
    const grouped = H.useMemo(() => groupBy(tabs, (t2) => getRankTabRequestConfig(t2).apiType), [tabs]);
    const renderRankTabList = (label, list2) => {
      list2 || (list2 = []);
      return /* @__PURE__ */ jsxs("div", { className: "max-w-500px mt-15px pt-5px first:mt-0 first:pt-0", children: [
        /* @__PURE__ */ jsx$1("p", { className: "flex-v-center mb-8px text-white bg-gate-primary py-5px pl-6px rounded-5px", children: label }),
        /* @__PURE__ */ jsx$1("div", { className: "grid grid-cols-5 gap-y-8px  gap-x-12px px-2px", children: list2.map((c2) => {
          const active = c2.slug === slug;
          return /* @__PURE__ */ jsx$1(antd.Button, { className: clsx({
            "b-gate-primary": active,
            "color-gate-primary": active
          }), onClick: (e2) => {
            setPopoverOpen(false);
            rankStore.slug = c2.slug;
            onRefresh == null ? void 0 : onRefresh();
          }, children: /* @__PURE__ */ jsx$1("span", { children: c2.name }) }, c2.slug);
        }) })
      ] });
    };
    const normalList = (grouped[ERankApiType.Normal] || []).filter((x) => !x.isExtra);
    const normalExtraList = (grouped[ERankApiType.Normal] || []).filter((x) => x.isExtra);
    const pgcList = [...grouped[ERankApiType.PgcSeason] || [], ...grouped[ERankApiType.PgcWeb] || []];
    const popoverContent = /* @__PURE__ */ jsxs(Fragment, { children: [
      renderRankTabList("视频", normalList),
      renderRankTabList(/* @__PURE__ */ jsxs(Fragment, { children: [
        "PGC内容 ",
        /* @__PURE__ */ jsx$1(HelpInfo, { children: "不能提供预览" })
      ] }), pgcList),
      renderRankTabList(/* @__PURE__ */ jsxs(Fragment, { children: [
        "更多 ",
        /* @__PURE__ */ jsx$1(HelpInfo, { children: "默认排行榜页没有列出的分区" })
      ] }), normalExtraList)
    ] });
    const [popoverOpen, setPopoverOpen] = H.useState(false);
    const popover = /* @__PURE__ */ jsx$1(antd.Popover, { arrow: false, open: popoverOpen, onOpenChange: setPopoverOpen, placement: "bottomLeft", getPopupContainer, content: popoverContent, styles: {
      body: {
        border: `1px solid ${usePopoverBorderColor()}`
      }
    }, children: /* @__PURE__ */ jsx$1(antd.Button, { css: [popoverOpen && buttonOpenCss, "", ""], children: currentTab.name }) });
    return /* @__PURE__ */ jsx$1("div", { ref, children: popover });
  }
  const subtabServiceCreators = {
    [EHotSubTab.PopularGeneral]: () => new PopularGeneralRecService(settings.popularGeneralUseAnonymous),
    [EHotSubTab.PopularWeekly]: () => new PopularWeeklyRecService(settings.popularWeeklyUseShuffle),
    [EHotSubTab.Rank]: () => new RankRecService(rankStore.slug)
  };
  function isHotTabUsingShuffle(shuffleForPopularWeekly) {
    const {
      subtab
    } = hotStore;
    shuffleForPopularWeekly ?? (shuffleForPopularWeekly = settings.popularWeeklyUseShuffle);
    const change = subtab === EHotSubTab.PopularWeekly && shuffleForPopularWeekly;
    return change;
  }
  const imgOf = (src) => /* @__PURE__ */ jsx$1("img", { src, alt: "", className: "size-18px" });
  const groupedButtonCss = {
    name: "1bgyaa0",
    styles: ".ant-btn-icon{line-height:0;}"
  };
  const HotSubTabConfig = {
    [EHotSubTab.PopularGeneral]: {
      // icon: <IconPark name='Fire' size={15} />,
      icon: imgOf("https://s1.hdslb.com/bfs/static/jinkela/popular/assets/icon_popular.png"),
      label: "综合热门",
      desc: "各个领域中新奇好玩的优质内容都在这里~",
      swr: true,
      anonymousUsage: true
    },
    [EHotSubTab.PopularWeekly]: {
      // icon: <IconPark name='TrendTwo' size={15} />,
      icon: imgOf("https://s1.hdslb.com/bfs/static/jinkela/popular/assets/icon_weekly.png"),
      label: "每周必看",
      desc: "每周五晚 18:00 更新",
      anonymousUsage: true
    },
    [EHotSubTab.Rank]: {
      // icon: <IconPark name='Rank' size={15} />,
      icon: imgOf("https://s1.hdslb.com/bfs/static/jinkela/popular/assets/icon_rank.png"),
      label: "排行榜",
      desc: "排行榜根据稿件内容质量，近期的数据综合展示，动态更新",
      anonymousUsage: true,
      swr: true
    }
  };
  class HotRecService extends BaseTabService {
    constructor() {
      super(20);
      __publicField(this, "subtab");
      __publicField(this, "service");
      this.subtab = hotStore.subtab;
      this.service = subtabServiceCreators[hotStore.subtab]();
    }
    get usageInfo() {
      return /* @__PURE__ */ jsx$1(HotUsageInfo, { children: this.service.usageInfo });
    }
    get hasMoreExceptQueue() {
      return this.service.hasMore;
    }
    fetchMore(abortSignal) {
      return this.service.loadMore(abortSignal);
    }
  }
  const hotStore = await( proxyWithGmStorage({
    subtab: EHotSubTab.PopularGeneral
  }, "hot-store"));
  if (!Object.values(EHotSubTab).includes(hotStore.subtab)) {
    hotStore.subtab = EHotSubTab.PopularGeneral;
  }
  function HotUsageInfo({
    children
  }) {
    const {
      subtab: activeSubtab
    } = useSnapshot(hotStore);
    const {
      icon,
      label
    } = HotSubTabConfig[activeSubtab];
    const onRefresh = useOnRefreshContext();
    const {
      ref,
      getPopupContainer
    } = usePopupContainer();
    const {
      __internalHotSubUseDropdown
    } = useSettingsSnapshot();
    const menus = H.useMemo(() => [EHotSubTab.PopularGeneral, EHotSubTab.PopularWeekly, EHotSubTab.Rank].map((subtab, index) => {
      const config = HotSubTabConfig[subtab];
      const active = subtab === activeSubtab;
      return [index > 0 && {
        type: "divider"
      }, {
        key: subtab,
        label: /* @__PURE__ */ jsx$1("span", { className: clsx({
          "color-gate-primary": active
        }), children: config.label }),
        icon: config.icon,
        onClick() {
          if (subtab === hotStore.subtab) return;
          hotStore.subtab = subtab;
          onRefresh == null ? void 0 : onRefresh();
        }
      }].filter(Boolean);
    }).flat(), [activeSubtab]);
    const dropdownMenu = /* @__PURE__ */ jsx$1(antd.Dropdown, { menu: {
      items: menus
    }, getPopupContainer, rootClassName: styled.createClass`
        .ant-dropdown-menu-item-divider {
          margin: 2px 0 !important;
        }
      `, children: /* @__PURE__ */ jsxs(antd.Button, { ref, className: "w-114px gap-0 flex items-center justify-start pl-16px", children: [
      icon,
      /* @__PURE__ */ jsx$1("span", { className: "ml-8px", children: label })
    ] }) });
    const tab2 = H.useMemo(() => {
      return /* @__PURE__ */ jsx$1(antd.Space.Compact, { children: [EHotSubTab.PopularGeneral, EHotSubTab.PopularWeekly, EHotSubTab.Rank].map((subtab, index) => {
        const {
          icon: icon2,
          label: label2,
          desc
        } = HotSubTabConfig[subtab];
        const active = subtab === activeSubtab;
        return /* @__PURE__ */ jsx$1(AntdTooltip, { title: /* @__PURE__ */ jsxs(Fragment, { children: [
          label2,
          ": ",
          desc
        ] }), children: /* @__PURE__ */ jsx$1(antd.Button, { css: groupedButtonCss, icon: icon2, variant: active ? "solid" : "outlined", color: active ? "primary" : "default", onClick: () => {
          if (subtab === hotStore.subtab) return;
          hotStore.subtab = subtab;
          onRefresh == null ? void 0 : onRefresh();
        }, children: label2 }) }, subtab);
      }) });
    }, [activeSubtab]);
    return /* @__PURE__ */ jsxs(Fragment, { children: [
      __internalHotSubUseDropdown ? dropdownMenu : tab2,
      children
    ] });
  }
  const advancedSearchHelpInfo = /* @__PURE__ */ jsxs(Fragment, { children: [
    "1. 可以使用多个搜索词, 用空格分隔, 逻辑关系为且 (AND) ",
    /* @__PURE__ */ jsx$1("br", {}),
    '2. 可以使用引号包裹搜索词, 如 "word or sentence" ',
    /* @__PURE__ */ jsx$1("br", {}),
    '3. 可以使用 -"word or sentence" 排除关键词; 必须使用引号(单引号 或 双引号) ',
    /* @__PURE__ */ jsx$1("br", {})
  ] });
  function parseSearchInput(input) {
    const includes = [];
    const excludes = [];
    if (!input.trim()) {
      return {
        includes,
        excludes
      };
    }
    let currentPos = 0;
    const inputLength = input.length;
    while (currentPos < inputLength) {
      while (currentPos < inputLength && input[currentPos] === " ") {
        currentPos++;
      }
      if (currentPos >= inputLength) break;
      let isExclude = false;
      let word = "";
      if (input[currentPos] === "-") {
        const nextChar = input[currentPos + 1];
        if (nextChar === '"' || nextChar === "'") {
          isExclude = true;
          currentPos++;
        }
      }
      if (input[currentPos] === '"' || input[currentPos] === "'") {
        const startQuoteChar = input[currentPos];
        currentPos++;
        let escaped = false;
        while (currentPos < inputLength) {
          const char2 = input[currentPos];
          if (escaped) {
            word += char2;
            escaped = false;
            currentPos++;
            continue;
          }
          if (char2 === "\\") {
            const nextChar = input[currentPos + 1];
            if (nextChar === '"' || nextChar === "'") {
              escaped = true;
              currentPos++;
              continue;
            }
            word += char2;
            currentPos++;
            continue;
          }
          if (char2 === startQuoteChar) {
            currentPos++;
            break;
          }
          word += char2;
          currentPos++;
        }
      } else {
        while (currentPos < inputLength && input[currentPos] !== " ") {
          if (input[currentPos] === "\\") {
            currentPos++;
            if (currentPos < inputLength) {
              word += input[currentPos];
              currentPos++;
            }
            continue;
          }
          word += input[currentPos];
          currentPos++;
        }
      }
      if (word) {
        if (isExclude) {
          excludes.push(word);
        } else {
          includes.push(word);
        }
      }
    }
    return {
      includes,
      excludes
    };
  }
  function e(e2) {
    return Array.from(new Set(e2));
  }
  function t(e2, t2) {
    if (!e2) throw Error(t2);
  }
  const n$1 = [[u(`
      block,inline-block,inline,flex,inline-flex,flow-root,grid,inline-grid,contents,list-item,hidden
      table,inline-table,table-caption,table-cell,table-column,table-row,
      table-column-group,table-footer-group,table-header-group,table-row-group
    `), `display`], [[`isolate`, `isolation-auto`], `isolation`], [[`static`, `fixed`, `absolute`, `relative`, `sticky`], `position`], [[`visible`, `invisible`, `collapse`], `visibility`], [[`flex-row`, `flex-row-reverse`, `flex-col`, `flex-col-reverse`], `flex-direction`], [[`flex-wrap`, `flex-wrap-reverse`, `flex-nowrap`], `flex-wrap`], [d$1(`object-`, [`contain`, `cover`, `fill`, `none`, `scale-down`]), `object-fit`], [d$1(`object-`, [`bottom`, `center`, `left`, `left-bottom`, `left-top`, `right`, `right-bottom`, `right-top`, `top`]), `object-position`], [[`antialiased`, `subpixel-antialiased`], `font-smoothing`], [[`italic`, `not-italic`], `font-style`], [d$1(`font-`, [`thin`, `extralight`, `light`, `normal`, `medium`, `semibold`, `bold`, `extrabold`, `black`]), `font-weight`], [[`normal-nums`, `ordinal`, `slashed-zero`, `lining-nums`, `oldstyle-nums`, `proportional-nums`, `tabular-nums`, `diagonal-fractions`, `stacked-fractions`], `font-variant-numeric`], [[`text-xs`, `text-sm`, `text-base`, `text-lg`, `text-xl`, /^text-(size-)?\d+xl/, /^text-(size-)?\d+/, /^font-size-\d+/], `font-size`], [[`list-inside`, `list-outside`], `list-style-position`], [[`list-none`, `list-disc`, `list-decimal`], `list-style-type`], [d$1(`text-`, [`left`, `center`, `right`, `justify`, `start`, `end`]), `text-align`], [[`underline`, `overline`, `line-through`, `no-underline`], `text-decoration-line`], [d$1(`decoration-`, [`solid`, `double`, `dotted`, `dashed`, `wavy`]), `text-decoration-style`], [[`decoration-auto`, `decoration-from-font`, /^decoration-\d+/], `text-decoration-thickness`], [[`truncate`, `text-ellipsis`, `text-clip`], `text-overflow`], [[`text-wrap`, `text-nowrap`, `text-balance`, `text-pretty`], `text-wrap`], [d$1(`bg-`, [`bottom`, `center`, `left`, `left-bottom`, `left-top`, `right`, `right-bottom`, `right-top`, `top`]), `background-position`], [[`bg-repeat`, `bg-no-repeat`, /^bg-repeat-/], `background-repeat`], [[`bg-auto`, `bg-cover`, `bg-contain`], `background-size`], [[`bg-none`, /^bg-gradient-to-/], `background-image`], [[/^(?:border-|b-)?(?:rounded|rd)()(?:-(.+))?$/], `rounded`], [/^b(?:order)?-(solid|dashed|dotted|double|hidden|none)$/, `border-style`], [/^b(?:order)?($|-\d+)/, `border-width`], [/^b(?:order)?-(t|b|l|r|x|y|s|e)($|-\d+)/, (e2, t2) => `border-${t2 == null ? void 0 : t2[1]}-width`], [/^outline-\d+/, `outline-width`], [[`outline`, /^outline-(solid|dashed|dotted|double|none)$/], `outline-style`], [/^divide-(solid|dashed|dotted|double|none)$/, `divide-style`], [/^divide-(x|y)($|-\d+)/, (e2, t2) => `divide-${t2 == null ? void 0 : t2[1]}-width`], [[`ring`, /^ring-\d+/], `ring-width`], [[/^ring-offset-\d+/], `ring-offset-width`], [[`shadow`, ...d$1(`shadow-`, [`sm`, `md`, `lg`, `xl`, `2xl`, `inner`, `none`])], `box-shadow`], [[`border-collapse`, `border-separate`], `border-collapse`], [[`table-auto`, `table-fixed`], `table-layout`], [[`caption-top`, `caption-bottom`], `caption-side`], [[`scroll-auto`, `scroll-smooth`], `scroll-behavior`], [[`snap-start`, `snap-end`, `snap-center`, `snap-align-none`], `scroll-snap-align`], [[`snap-normal`, `snap-always`], `scroll-snap-stop`], [[`snap-none`, `snap-x`, `snap-y`, `snap-both`, `snap-mandatory`, `snap-proximity`], `scroll-snap-type`], [/^stroke-\d+/, `stroke-width`], [[`sr-only`, `not-sr-only`], `Screen-Readers`], [/^(flex-)?grow($|-\d+$)/, `flex-grow`], [/^(flex-)?shrink($|-\d+$)/, `flex-shrink`], ...[`ring-inset`, `divide-x-reverse`, `divide-y-reverse`].map((e2) => [e2, e2]), ...[`resize`, `blur`, `drop-shadow`, `grayscale`, `invert`, `sepia`, `backdrop-blur`, `backdrop-grayscale`, `backdrop-invert`, `backdrop-sepia`].map((e2) => [e2, e2])], r = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map();
  for (let [e2, t2] of n$1) {
    let n2 = [e2].flat(), a2 = n2.filter((e3) => typeof e3 == `string`), o2 = n2.filter((e3) => typeof e3 == `object` && e3 instanceof RegExp);
    a2.forEach((e3) => {
      let n3 = typeof t2 == `string` ? t2 : t2(e3);
      r.set(e3, n3);
    }), o2.forEach((e3) => {
      i.set(e3, t2);
    });
  }
  function a(e2) {
    if (r.has(e2)) return r.get(e2);
    for (let [t2, n2] of i.entries()) if (t2.test(e2)) {
      let r2 = t2.exec(e2), i2 = typeof n2 == `string` ? n2 : n2(e2, r2);
      return i2;
    }
  }
  function o(e2) {
    return s.map((e3) => typeof e3 == `string` ? [e3, e3] : e3).find(([t2, n2]) => e2.startsWith(t2 + `-`));
  }
  const s = [`break-after`, `break-before`, `break-inside`, `grid-flow`, `align`, `whitespace`, `mix-blend`, `bg-blend`, `ease`, `origin`, `cursor`, `touch`, [`text`, `color`], `color`, [`bg`, `background-color`], [`b`, `border-color`], [`border`, `border-color`], [`decoration`, `text-decoration-color`], [`from`, `gradient-color-stops`], [`divide`, `divide-color`], [`outline`, `outline-color`], [`ring`, `ring-color`], [`ring-offset`, `ring-offset-color`], [`shadow`, `box-shadow-color`], [`accent`, `accent-color`], [`caret`, `caret-color`], `fill`, `stroke`];
  function c$1(e2) {
    return l.has(e2) ? l.get(e2) : e2;
  }
  const l = new Map(Object.entries({ leading: `line-height`, col: `grid-column`, "col-span": `grid-column`, "col-start": `grid-column-start`, "col-end": `grid-column-end`, row: `grid-row`, "row-span": `grid-row`, "row-start": `grid-row-start`, "row-end": `grid-row-end` }));
  function u(e2) {
    return e2.split(`
`).map((e3) => e3.trim()).filter(Boolean).map((e3) => e3.split(`,`).map((e4) => e4.trim()).filter(Boolean)).flat();
  }
  function d$1(e2, n2) {
    return t(e2.endsWith(`-`), "prefix must end with `-`"), n2.map((t2) => e2 + t2);
  }
  function f(t2) {
    return e((t2 || ``).split(` `).map((e2) => e2.trim()).filter(Boolean));
  }
  function p(...e2) {
    let t2 = e2.map(f).flat().filter(Boolean), n2 = /* @__PURE__ */ new Map();
    for (let e3 of t2) {
      {
        let t4 = a(e3);
        if (t4) {
          n2.set(t4, e3);
          continue;
        }
      }
      let t3 = o(e3);
      if (t3) {
        let [r3, i3] = t3, a2 = c$1(i3);
        n2.set(a2, e3);
        continue;
      }
      let r2 = e3, i2 = /(\[[\w_,-]+\])$/;
      i2.test(e3) && (r2 = e3.replace(i2, function(e4, t4) {
        return `*`.repeat(t4.length);
      })), r2.includes(`--`) && (r2 = r2.replace(/--/g, `-*`));
      let s2 = r2.lastIndexOf(`-`);
      if (s2 === -1) {
        n2.set(c$1(e3), e3);
        continue;
      }
      let l2 = c$1(e3.slice(0, s2));
      n2.set(l2, e3);
    }
    return Array.from(n2.values()).join(` `);
  }
  function n(...n2) {
    return H.useMemo(() => p(...n2), [...n2]);
  }
  const TabConfig = {
    [ETab.AppRecommend]: {
      icon: /* @__PURE__ */ jsx$1(IconForPhone, { className: "size-18px" }),
      label: "推荐",
      desc: "使用 Bilibili App 端推荐 API",
      anonymousUsage: true
    },
    [ETab.PcRecommend]: {
      icon: /* @__PURE__ */ jsx$1(IconForPc, { className: "size-18px" }),
      label: "推荐",
      desc: "使用新版首页顶部推荐 API",
      anonymousUsage: true
    },
    [ETab.KeepFollowOnly]: {
      icon: /* @__PURE__ */ jsx$1(IconForFollowedOnly, { className: "size-18px" }),
      label: "已关注",
      desc: "从PC端推荐中筛选出「已关注」,可能比较慢; 关注的UP更新在动态~"
    },
    [ETab.DynamicFeed]: {
      icon: /* @__PURE__ */ jsx$1(IconForDynamicFeed, { className: "size-16px" }),
      label: "动态",
      desc: "视频投稿动态",
      swr: true
    },
    [ETab.Watchlater]: {
      icon: /* @__PURE__ */ jsx$1(IconForWatchlater, { className: "size-17px", css: {
        name: "1jijiug",
        styles: ".circle{stroke:currentColor;}"
      } }),
      label: "稍后再看",
      desc: "你添加的稍后再看; 默认随机乱序, 可在设置中关闭乱序",
      swr: true
    },
    [ETab.Fav]: {
      icon: /* @__PURE__ */ jsx$1(IconForFav, { className: "size-16px mt--1px" }),
      label: "收藏",
      desc: "你添加的收藏; 默认随机乱序, 可在设置中关闭乱序",
      get swr() {
        return !favStore.usingShuffle;
      }
    },
    [ETab.Hot]: {
      icon: /* @__PURE__ */ jsx$1(IconForHot, { className: "size-16px" }),
      label: "热门",
      desc: "各个领域中新奇好玩的优质内容都在这里~",
      anonymousUsage: true,
      get swr() {
        return !isHotTabUsingShuffle();
      }
    },
    [ETab.Live]: {
      icon: /* @__PURE__ */ jsx$1(IconForLive, { className: "size-16px" }),
      label: "直播",
      desc: "直播~",
      swr: true
    },
    [ETab.SpaceUpload]: {
      icon: /* @__PURE__ */ jsx$1(IconForSpaceUpload, { className: "size-16px" }),
      label: "投稿",
      desc: "UP 视频投稿",
      extraHelpInfo: /* @__PURE__ */ jsxs("div", { className: "ml-20px", children: [
        "搜索词: 搜索相关作品 ",
        /* @__PURE__ */ jsx$1("br", {}),
        "本地过滤词: 本地过滤搜索结果; 本地过滤词支持高级规则:",
        /* @__PURE__ */ jsx$1("div", { className: "ml-20px", children: advancedSearchHelpInfo })
      ] })
    }
  };
  function TabIcon({
    tabKey,
    active,
    className
  }) {
    const {
      icon
    } = TabConfig[tabKey];
    const newClassName = n(icon.props.className, className);
    const cloned = H.cloneElement(icon, {
      css: icon.props.css,
      active: tabKey === ETab.Live ? active : void 0,
      // 否则 warn: svg recived boolean props
      className: newClassName
    });
    return cloned;
  }
  function toastNeedLogin() {
    return toast("你需要登录B站后使用该功能! 如已完成登录, 请刷新网页重试~");
  }
  function useShortcut({
    enabled,
    refresh,
    minIndex = 0,
    maxIndex,
    containerRef,
    getScrollerRect,
    changeScrollY,
    videoCardEmitters,
    activeLargePreviewItemIndex
  }) {
    const [activeIndex, setActiveIndex] = H.useState(void 0);
    const isEnabled = useMemoizedFn(() => {
      if (!enabled) return false;
      if (shouldDisableShortcut()) return false;
      return true;
    });
    const activeIndexIsValid = useMemoizedFn(() => {
      var _a2;
      if (typeof activeIndex !== "number") return false;
      if (!containerRef.current) return false;
      const scrollerRect = getScrollerRect();
      const rect = (_a2 = containerRef.current.querySelector(`.${APP_CLS_CARD}.${APP_CLS_CARD_ACTIVE}`)) == null ? void 0 : _a2.getBoundingClientRect();
      if (!scrollerRect || !rect) return false;
      if (rect.top - scrollerRect.top < -(scrollerRect.height + rect.height)) {
        return false;
      }
      if (rect.top - scrollerRect.top > scrollerRect.height * 2 + rect.height) {
        return false;
      }
      return true;
    });
    function getStep(direction) {
      const card = getCardAt(activeIndex);
      const activeLeft = card.getBoundingClientRect().left;
      const isLeftSame = (left) => Math.abs(activeLeft - left) < 1;
      {
        const col = getColumnCount(containerRef.current);
        const step2 = direction === "down" ? col : -col;
        const newCard = getCardAt(activeIndex + step2);
        if (newCard) {
          const left = newCard.getBoundingClientRect().left;
          if (isLeftSame(left)) {
            return step2;
          }
        }
      }
      let step = 0;
      let cur = card;
      const next2 = () => direction === "down" ? cur.nextElementSibling : cur.previousElementSibling;
      while (next2()) {
        cur = next2();
        if (!cur.classList.contains(APP_CLS_CARD)) continue;
        direction === "down" ? step++ : step--;
        const left = cur.getBoundingClientRect().left;
        if (isLeftSame(left)) {
          return step;
        }
      }
      return 0;
    }
    const addActiveIndex = (step) => (e2) => {
      if (!isEnabled()) return;
      e2 == null ? void 0 : e2.preventDefault();
      let newActiveIndex;
      if (activeIndexIsValid()) {
        const _step = typeof step === "number" ? step : getStep(step);
        newActiveIndex = activeIndex + _step;
      } else {
        newActiveIndex = getInitialIndex();
      }
      if (newActiveIndex < minIndex) {
        makeVisible(minIndex);
        return;
      }
      if (newActiveIndex > maxIndex) {
        makeVisible(maxIndex);
        return;
      }
      setActiveIndex(newActiveIndex);
      makeVisible(newActiveIndex);
    };
    const useKey = (keyFilter, eventHandler) => {
      useKeyPress(keyFilter, (event, key) => {
        if (!isEnabled()) return;
        eventHandler(event, key);
      }, {
        exactMatch: true
      });
    };
    useKey("leftarrow", addActiveIndex(-1));
    useKey("rightarrow", addActiveIndex(1));
    useKey("tab", addActiveIndex(1));
    useKey("shift.tab", addActiveIndex(-1));
    useKey("uparrow", addActiveIndex("up"));
    useKey("downarrow", addActiveIndex("down"));
    const clearActiveIndex = () => {
      if (!isEnabled()) return;
      setActiveIndex(void 0);
    };
    const getActiveEmitter = () => {
      if (!isEnabled() || typeof activeIndex !== "number") return;
      return videoCardEmitters[activeIndex];
    };
    useKey("esc", clearActiveIndex);
    useKey("enter", (e2) => {
      var _a2, _b2;
      if (!isEnabled()) return;
      if (typeof activeIndex === "number") {
        e2.preventDefault();
        return (_a2 = videoCardEmitters[activeIndex]) == null ? void 0 : _a2.emit("open");
      }
      if (typeof activeLargePreviewItemIndex === "number") {
        e2.preventDefault();
        return (_b2 = videoCardEmitters[activeLargePreviewItemIndex]) == null ? void 0 : _b2.emit("open-with-large-preview-visible");
      }
    });
    useKey("x", () => {
      var _a2;
      return (_a2 = getActiveEmitter()) == null ? void 0 : _a2.emit("open-in-popup");
    });
    useKey("backspace", () => {
      var _a2;
      return (_a2 = getActiveEmitter()) == null ? void 0 : _a2.emit("trigger-dislike");
    });
    useKey(["s", "w"], () => {
      var _a2;
      return (_a2 = getActiveEmitter()) == null ? void 0 : _a2.emit("toggle-watch-later");
    });
    useKey(["period", "p"], () => {
      var _a2;
      return (_a2 = getActiveEmitter()) == null ? void 0 : _a2.emit("hotkey-preview-animation");
    });
    function getInitialIndex() {
      const scrollerRect = getScrollerRect();
      if (!scrollerRect) return 0;
      const cards = getCards();
      for (let i2 = 0; i2 < cards.length; i2++) {
        const card = cards[i2];
        const rect = card.getBoundingClientRect();
        if (rect.top >= scrollerRect.top) {
          return i2;
        }
      }
      return 0;
    }
    const CARDS_SELECTOR = `.${APP_CLS_CARD}`;
    function getCards() {
      var _a2;
      return [...((_a2 = containerRef.current) == null ? void 0 : _a2.querySelectorAll(CARDS_SELECTOR)) || []];
    }
    function getCardAt(index) {
      return getCards()[index];
    }
    function makeVisible(index) {
      var _a2;
      const card = getCardAt(index);
      (_a2 = card == null ? void 0 : card.scrollIntoViewIfNeeded) == null ? void 0 : _a2.call(card, false);
      const scrollerRect = getScrollerRect();
      const rect = card.getBoundingClientRect();
      if (!scrollerRect || !rect) return;
      if (rect.top <= scrollerRect.top) {
        const offset = -(scrollerRect.top - rect.top + 10);
        changeScrollY == null ? void 0 : changeScrollY({
          offset
        });
        return;
      }
      if (scrollerRect.bottom - rect.bottom < 20) {
        const offset = 20 - (scrollerRect.bottom - rect.bottom);
        changeScrollY == null ? void 0 : changeScrollY({
          offset
        });
        return;
      }
    }
    return {
      activeIndex,
      clearActiveIndex
    };
  }
  const countCache1 = /* @__PURE__ */ new Map();
  const countCache2 = /* @__PURE__ */ new Map();
  function getColumnCount(container, mayHaveNarrowMode = true) {
    if (mayHaveNarrowMode && settings.useNarrowMode) return 2;
    const countCache = settings.style.pureRecommend.useCustomGrid ? countCache1 : countCache2;
    {
      const count2 = countCache.get(Math.trunc(window.innerWidth));
      if (count2) return count2;
    }
    container || (container = document.querySelector(`.${videoGrid}`));
    if (!container) return 0;
    const style = window.getComputedStyle(container);
    if (style.display !== "grid") return 0;
    const count = style.gridTemplateColumns.split(" ").length;
    countCache.set(window.innerWidth, count);
    return count;
  }
  async function modifyRelations(upMid, act) {
    const uid2 = getUid();
    const csrf = getCsrfToken();
    const params = new URLSearchParams({
      fid: upMid,
      act: String(act),
      re_src: "11",
      gaia_source: "web_main",
      spmid: "333.999.0.0",
      extend_content: JSON.stringify({
        entity: "user",
        entity_id: uid2,
        fp: d()
      }),
      csrf
    });
    const res = await request.post("/x/relation/modify", params);
    const json = res.data;
    const success = isWebApiSuccess(json);
    if (!success) {
      toast(json.message || "未知错误");
    }
    return success;
  }
  function d() {
    let t2;
    let e2;
    const i2 = (
      // @ts-ignore
      (null === (t2 = window.reportObserver) || void 0 === t2 || null === (e2 = t2.cache) || void 0 === e2 ? void 0 : e2.fpriskMsg) || {}
    );
    let n2 = "empty";
    return i2 && (n2 = i2.webdriver + "" + i2.screenResolution + "" + i2.platform + "" + i2.hardwareConcurrency + "" + i2.deviceMemory + "" + i2.colorDepth + "" + i2.indexedDb + "" + i2.language + "" + i2.openDatabase + "" + i2.touchSupport + "" + i2.userAgent), decodeURIComponent(n2);
  }
  const debug$a = baseDebug.extend("service:user:relations:blacklist");
  const blacklistAdd = blacklistActionFactory("follow");
  const blacklistRemove = blacklistActionFactory("remove");
  const UserBlacklistService = {
    add: blacklistAdd,
    remove: blacklistRemove
  };
  const {
    set: blacklistMids,
    replaceAllWith: blacklistMidsReplaceAllWith
  } = await( proxySetWithGmStorage("blacklist-mids"));
  function useInBlacklist(upMid) {
    const set2 = useSnapshot(blacklistMids);
    return !!upMid && set2.has(upMid);
  }
  function blacklistActionFactory(action2) {
    const act = action2 === "follow" ? 5 : 6;
    return async function blacklistAction(upMid) {
      const success = await modifyRelations(upMid, act);
      if (success) {
        const set2 = blacklistMids;
        if (action2 === "follow") {
          set2.add(upMid);
        } else if (action2 === "remove") {
          set2.delete(upMid);
        }
      }
      return success;
    };
  }
  async function getUserBlacklist() {
    const ps = 20;
    const getPage = async (pn) => {
      const res = await request.get("/x/relation/blacks", {
        params: {
          re_version: 0,
          ps,
          pn
        }
      });
      const json = res.data;
      if (!isWebApiSuccess(json)) return;
      const total2 = json.data.total;
      const mids22 = json.data.list.map((x) => x.mid);
      return {
        total: total2,
        mids: mids22
      };
    };
    const ret = await getPage(1);
    if (!ret) return;
    const {
      total,
      mids: mids2 = []
    } = ret;
    let blackMids = mids2;
    if (total) {
      const maxPn = Math.ceil(total / ps);
      for (let pn = 2; pn <= maxPn; pn++) {
        const {
          mids: mids22 = []
        } = await getPage(pn) || {};
        blackMids = blackMids.concat(mids22);
      }
    }
    return blackMids;
  }
  (async () => {
    if (!IN_BILIBILI_HOMEPAGE) return;
    await whenIdle();
    const ids2 = await getUserBlacklist();
    debug$a("user blocklist fetched: %o", ids2);
    if (ids2) {
      blacklistMidsReplaceAllWith(ids2.map((x) => x.toString()));
    }
  })();
  function isAppRecommend(item) {
    return item.api === EApiType.AppRecommend;
  }
  function isPcRecommend(item) {
    return item.api === EApiType.PcRecommend;
  }
  function isDynamicFeed(item) {
    return item.api === EApiType.DynamicFeed;
  }
  function isWatchlater(item) {
    return item.api === EApiType.Watchlater;
  }
  function isFav(item) {
    return item.api === EApiType.Fav;
  }
  function isPopularGeneral(item) {
    return item.api === EApiType.PopularGeneral;
  }
  function isPopularWeekly(item) {
    return item.api === EApiType.PopularWeekly;
  }
  function isRank(item) {
    return item.api === EApiType.Rank;
  }
  function isLive(item) {
    return item.api === EApiType.Live;
  }
  function isSpaceUpload(item) {
    return item.api === EApiType.SpaceUpload;
  }
  var PcRecGoto = /* @__PURE__ */ ((PcRecGoto2) => {
    PcRecGoto2["AV"] = "av";
    PcRecGoto2["Ad"] = "ad";
    PcRecGoto2["Live"] = "live";
    return PcRecGoto2;
  })(PcRecGoto || {});
  function isFavFolderDefault(attr) {
    return attr.toString(2).at(-2) === "0";
  }
  function isFavFolderPrivate(attr) {
    return attr.toString(2).at(-1) === "1";
  }
  const multiSelectStore = proxy({
    multiSelecting: false,
    selectedIdSet: proxySet()
    // uniqId
  });
  function useMultiSelecting() {
    const {
      multiSelecting
    } = useSnapshot(multiSelectStore);
    return multiSelecting;
  }
  function useMultiSelectState(uniqId) {
    const {
      multiSelecting,
      selectedIdSet
    } = useSnapshot(multiSelectStore);
    return multiSelecting && !!uniqId && selectedIdSet.has(uniqId);
  }
  const isFunction$1 = (value) => {
    return !!(value && value.constructor && value.call && value.apply);
  };
  const isPromise = (value) => {
    if (!value)
      return false;
    if (!value.then)
      return false;
    if (!isFunction$1(value.then))
      return false;
    return true;
  };
  const isEqual = (x, y) => {
    if (Object.is(x, y))
      return true;
    if (x instanceof Date && y instanceof Date) {
      return x.getTime() === y.getTime();
    }
    if (x instanceof RegExp && y instanceof RegExp) {
      return x.toString() === y.toString();
    }
    if (typeof x !== "object" || x === null || typeof y !== "object" || y === null) {
      return false;
    }
    const keysX = Reflect.ownKeys(x);
    const keysY = Reflect.ownKeys(y);
    if (keysX.length !== keysY.length)
      return false;
    for (let i2 = 0; i2 < keysX.length; i2++) {
      if (!Reflect.has(y, keysX[i2]))
        return false;
      if (!isEqual(x[keysX[i2]], y[keysX[i2]]))
        return false;
    }
    return true;
  };
  const tryit = (func) => {
    return (...args) => {
      try {
        const result = func(...args);
        if (isPromise(result)) {
          return result.then((value) => [void 0, value]).catch((err) => [err, void 0]);
        }
        return [void 0, result];
      } catch (err) {
        return [err, void 0];
      }
    };
  };
  const pick = (obj, keys2) => {
    if (!obj)
      return {};
    return keys2.reduce((acc, key) => {
      if (Object.prototype.hasOwnProperty.call(obj, key))
        acc[key] = obj[key];
      return acc;
    }, {});
  };
  let currentGridItems = [];
  let currentGridSharedEmitter = defaultSharedEmitter;
  function setCurrentGridSharedEmitter(sharedEmitter) {
    currentGridSharedEmitter = sharedEmitter;
  }
  const win = typeof unsafeWindow !== "undefined" ? unsafeWindow : globalThis;
  const setGlobalValue = (key, val) => void tryit(() => win[key] = val)();
  const gridItemsKey = `${APP_KEY_PREFIX}_gridItems`;
  function setGlobalGridItems(itemsWithSep) {
    const items = itemsWithSep.filter((x) => x.api !== EApiType.Separator);
    currentGridItems = items;
    setGlobalValue(gridItemsKey, currentGridItems);
  }
  function getMultiSelectedItems() {
    const {
      multiSelecting,
      selectedIdSet
    } = multiSelectStore;
    return multiSelecting ? currentGridItems.filter((item) => selectedIdSet.has(item.uniqId)) : [];
  }
  function getMultiSelectedCardDatas() {
    return getMultiSelectedItems().map(normalizeCardData);
  }
  function getGenericCardDatas() {
    const {
      multiSelecting
    } = multiSelectStore;
    const items = multiSelecting ? getMultiSelectedItems() : currentGridItems;
    const cardDatas = items.map(normalizeCardData);
    return cardDatas;
  }
  function copyBvidsSingleLine() {
    const bvids = getGenericCardDatas().map((cardData) => cardData.bvid);
    const content = bvids.join(" ");
    GM.setClipboard(content);
    antNotification.success({
      message: "已复制",
      description: content
    });
  }
  function getBvidInfo(cardData) {
    let {
      bvid,
      authorName,
      pubts,
      title
    } = cardData;
    const date = dayjs.unix(pubts ?? 0).format("YYYY-MM-DD");
    title = title.replace(/\n+/g, " ");
    return `${bvid} ;; [${authorName}] ${date} ${title}`;
  }
  function copyBvidInfos() {
    const lines = getGenericCardDatas().map(getBvidInfo);
    const content = lines.join("\n");
    GM.setClipboard(content);
    antNotification.success({
      message: "已复制",
      description: content
    });
  }
  function copyVideoLinks() {
    const lines = getMultiSelectedCardDatas().map((cardData) => {
      let href = cardData.href;
      if (!href) return;
      if (href.startsWith("/")) href = new URL(href, location.href).href;
      return href;
    }).filter(Boolean);
    const content = lines.join("\n");
    GM.setClipboard(content);
    antNotification.success({
      message: "已复制",
      description: content
    });
  }
  const BIND_TO_UNSAFE_WINDOW_FNS = {
    getGenericCardDatas,
    copyBvidsSingleLine,
    copyBvidInfos
  };
  setTimeout(() => {
    Object.entries(BIND_TO_UNSAFE_WINDOW_FNS).forEach(([fnName, fn]) => {
      setGlobalValue(`${APP_KEY_PREFIX}_${fnName}`, fn);
    });
  });
  const biUiChecksGrid = (props, ref) => /* @__PURE__ */ jsx$1("svg", { viewBox: "0 0 16 16", width: "1.2em", height: "1.2em", ref, ...props, children: /* @__PURE__ */ jsx$1("path", { fill: "currentColor", d: "M2 10h3a1 1 0 0 1 1 1v3a1 1 0 0 1-1 1H2a1 1 0 0 1-1-1v-3a1 1 0 0 1 1-1m9-9h3a1 1 0 0 1 1 1v3a1 1 0 0 1-1 1h-3a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1m0 9a1 1 0 0 0-1 1v3a1 1 0 0 0 1 1h3a1 1 0 0 0 1-1v-3a1 1 0 0 0-1-1zm0-10a2 2 0 0 0-2 2v3a2 2 0 0 0 2 2h3a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2zM2 9a2 2 0 0 0-2 2v3a2 2 0 0 0 2 2h3a2 2 0 0 0 2-2v-3a2 2 0 0 0-2-2zm7 2a2 2 0 0 1 2-2h3a2 2 0 0 1 2 2v3a2 2 0 0 1-2 2h-3a2 2 0 0 1-2-2zM0 2a2 2 0 0 1 2-2h3a2 2 0 0 1 2 2v3a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2zm5.354.854a.5.5 0 1 0-.708-.708L3 3.793l-.646-.647a.5.5 0 1 0-.708.708l1 1a.5.5 0 0 0 .708 0z" }) });
  const ForwardRef$z = H.forwardRef(biUiChecksGrid);
  const fluentSelectAllOn16Regular = (props, ref) => /* @__PURE__ */ jsx$1("svg", { viewBox: "0 0 16 16", width: "1.2em", height: "1.2em", ref, ...props, children: /* @__PURE__ */ jsx$1("path", { fill: "currentColor", d: "M9.854 5.854a.5.5 0 0 0-.708-.708L6.5 7.793L5.354 6.646a.5.5 0 1 0-.708.708l1.5 1.5a.5.5 0 0 0 .708 0zM2 4.5A2.5 2.5 0 0 1 4.5 2h5A2.5 2.5 0 0 1 12 4.5v5A2.5 2.5 0 0 1 9.5 12h-5A2.5 2.5 0 0 1 2 9.5zM4.5 3A1.5 1.5 0 0 0 3 4.5v5A1.5 1.5 0 0 0 4.5 11h5A1.5 1.5 0 0 0 11 9.5v-5A1.5 1.5 0 0 0 9.5 3zM7 14a2.5 2.5 0 0 1-2-1h4.5A3.5 3.5 0 0 0 13 9.5V4c.607.456 1 1.182 1 2v3.5A4.5 4.5 0 0 1 9.5 14z" }) });
  const ForwardRef$y = H.forwardRef(fluentSelectAllOn16Regular);
  const icOutlineSwapHoriz = (props, ref) => /* @__PURE__ */ jsx$1("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref, ...props, children: /* @__PURE__ */ jsx$1("path", { fill: "currentColor", d: "M6.99 11L3 15l3.99 4v-3H14v-2H6.99zM21 9l-3.99-4v3H10v2h7.01v3z" }) });
  const ForwardRef$x = H.forwardRef(icOutlineSwapHoriz);
  const ionExitOutline = (props, ref) => /* @__PURE__ */ jsx$1("svg", { viewBox: "0 0 512 512", width: "1.2em", height: "1.2em", ref, ...props, children: /* @__PURE__ */ jsx$1("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 32, d: "M320 176v-40a40 40 0 0 0-40-40H88a40 40 0 0 0-40 40v240a40 40 0 0 0 40 40h192a40 40 0 0 0 40-40v-40m64-160l80 80l-80 80m-193-80h273" }) });
  const ForwardRef$w = H.forwardRef(ionExitOutline);
  function MultiSelectButton({
    iconOnly,
    addCopyActions = false
  }) {
    const {
      multiSelecting
    } = useSnapshot(multiSelectStore);
    const popoverBorderColor = usePopoverBorderColor();
    const exitCheck = useMemoizedFn(() => {
      if (!multiSelectStore.multiSelecting && settings.multiSelect.clearWhenExit) {
        multiSelectStore.selectedIdSet.clear();
      }
    });
    const btn = /* @__PURE__ */ jsxs(antd.Button, { type: multiSelecting ? "primary" : "default", className: clsx(iconOnly ? "icon-only-round-button" : "inline-flex-center"), onClick: () => {
      multiSelectStore.multiSelecting = !multiSelectStore.multiSelecting;
      exitCheck();
    }, children: [
      /* @__PURE__ */ jsx$1(ForwardRef$z, { className: "size-12px" }),
      !iconOnly && /* @__PURE__ */ jsxs(Fragment, { children: [
        "多选",
        multiSelectStore.multiSelecting ? "中" : ""
      ] })
    ] });
    const wrapPopoverActions = (btn2) => {
      return /* @__PURE__ */ jsx$1(antd.Popover, { styles: {
        body: {
          border: `1px solid ${popoverBorderColor}`
        }
      }, content: /* @__PURE__ */ jsxs("div", { className: "max-w-280px", children: [
        /* @__PURE__ */ jsxs("div", { className: "flex flex-wrap items-center gap-x-15px gap-y-2px", children: [
          /* @__PURE__ */ jsxs(antd.Button, { className: "inline-flex items-center", onClick: () => multiSelectStore.selectedIdSet.clear(), children: [
            /* @__PURE__ */ jsx$1(ForwardRef$O, { className: "size-16px" }),
            "清空"
          ] }),
          /* @__PURE__ */ jsxs(antd.Button, { className: "inline-flex items-center", onClick: () => {
            const newIdList = currentGridItems.map((x) => x.uniqId);
            multiSelectStore.selectedIdSet = proxySet(newIdList);
          }, children: [
            /* @__PURE__ */ jsx$1(ForwardRef$y, { className: "size-18px" }),
            "全选"
          ] }),
          /* @__PURE__ */ jsxs(antd.Button, { className: "inline-flex items-center", onClick: () => {
            const newIdList = currentGridItems.filter((x) => !multiSelectStore.selectedIdSet.has(x.uniqId)).map((x) => x.uniqId);
            multiSelectStore.selectedIdSet = proxySet(newIdList);
          }, children: [
            /* @__PURE__ */ jsx$1(ForwardRef$x, { className: "size-18px" }),
            "反选"
          ] }),
          /* @__PURE__ */ jsx$1("div", { className: "flex-basis-100%" }),
          /* @__PURE__ */ jsxs(antd.Button, { className: "inline-flex items-center", onClick: () => {
            multiSelectStore.multiSelecting = false;
            exitCheck();
          }, children: [
            /* @__PURE__ */ jsx$1(ForwardRef$w, { className: "size-18px" }),
            "退出"
          ] }),
          /* @__PURE__ */ jsx$1(CheckboxSettingItem, { configPath: "multiSelect.clearWhenExit", label: "退出时清空", tooltip: "退出多选时, 清空所有已选择项" })
        ] }),
        addCopyActions && /* @__PURE__ */ jsxs(Fragment, { children: [
          /* @__PURE__ */ jsx$1(antd.Divider, { variant: "solid", className: "my-7px" }),
          /* @__PURE__ */ jsx$1("div", { className: "flex flex-wrap gap-x-10px gap-y-5px", children: /* @__PURE__ */ jsx$1(CopyBvidButtons, {}) })
        ] })
      ] }), children: btn2 });
    };
    if (multiSelecting) {
      return wrapPopoverActions(btn);
    } else {
      return iconOnly ? /* @__PURE__ */ jsx$1(AntdTooltip, { title: "多选", arrow: false, children: btn }) : btn;
    }
  }
  function CopyBvidButtons() {
    const {
      __internalEnableCopyBvidInfo: bvidInfo
    } = useSettingsSnapshot();
    return /* @__PURE__ */ jsxs(Fragment, { children: [
      /* @__PURE__ */ jsxs(antd.Button, { onClick: copyBvidsSingleLine, className: "inline-flex-center", children: [
        /* @__PURE__ */ jsx$1(IconForCopy, {}),
        " 复制 BVID"
      ] }),
      bvidInfo && /* @__PURE__ */ jsxs(antd.Button, { onClick: copyBvidInfos, className: "inline-flex-center", children: [
        /* @__PURE__ */ jsx$1(IconForCopy, {}),
        " 复制 BVID 信息"
      ] })
    ] });
  }
  function CopyBvidButtonsUsageInfo() {
    const {
      __internalAddCopyBvidButton: enabled
    } = useSettingsSnapshot();
    if (!enabled) return null;
    return /* @__PURE__ */ jsxs(Fragment, { children: [
      /* @__PURE__ */ jsx$1(CopyBvidButtons, {}),
      /* @__PURE__ */ jsx$1(MultiSelectButton, { iconOnly: false })
    ] });
  }
  function mapNameForSort(name) {
    return name.replace(/([A-Z])/, "999999$1").replace(/([a-z])/, "999998$1");
  }
  function localeComparer(a2, b) {
    return a2.localeCompare(b, "zh-CN");
  }
  function sortListByName(entries, prop) {
    return fastSortWithOrders(entries, [{
      prop: (item) => {
        const val = typeof prop === "function" ? prop(item) : item[prop];
        return mapNameForSort(val);
      },
      order: localeComparer
    }]);
  }
  const dropdownMenuStyle = {
    overscrollBehavior: "contain",
    maxHeight: "60vh",
    overflowY: "scroll",
    scrollbarWidth: "thin",
    paddingRight: "12px"
  };
  const lucideList = (props, ref) => /* @__PURE__ */ jsx$1("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref, ...props, children: /* @__PURE__ */ jsx$1("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M3 12h.01M3 18h.01M3 6h.01M8 12h13M8 18h13M8 6h13" }) });
  const ForwardRef$v = H.forwardRef(lucideList);
  const lucideFolderLock = (props, ref) => /* @__PURE__ */ jsx$1("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref, ...props, children: /* @__PURE__ */ jsxs("g", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, children: [
    /* @__PURE__ */ jsx$1("rect", { width: 8, height: 5, x: 14, y: 17, rx: 1 }),
    /* @__PURE__ */ jsx$1("path", { d: "M10 20H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h3.9a2 2 0 0 1 1.69.9l.81 1.2a2 2 0 0 0 1.67.9H20a2 2 0 0 1 2 2v2.5" }),
    /* @__PURE__ */ jsx$1("path", { d: "M20 17v-2a2 2 0 1 0-4 0v2" })
  ] }) });
  const ForwardRef$u = H.forwardRef(lucideFolderLock);
  const lucideFolder = (props, ref) => /* @__PURE__ */ jsx$1("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref, ...props, children: /* @__PURE__ */ jsx$1("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M20 20a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-7.9a2 2 0 0 1-1.69-.9L9.6 3.9A2 2 0 0 0 7.93 3H4a2 2 0 0 0-2 2v13a2 2 0 0 0 2 2Z" }) });
  const ForwardRef$t = H.forwardRef(lucideFolder);
  const ionLayersOutline = (props, ref) => /* @__PURE__ */ jsxs("svg", { viewBox: "0 0 512 512", width: "1.2em", height: "1.2em", ref, ...props, children: [
    /* @__PURE__ */ jsx$1("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 32, d: "m434.8 137.65l-149.36-68.1c-16.19-7.4-42.69-7.4-58.88 0L77.3 137.65c-17.6 8-17.6 21.09 0 29.09l148 67.5c16.89 7.7 44.69 7.7 61.58 0l148-67.5c17.52-8 17.52-21.1-.08-29.09M160 308.52l-82.7 37.11c-17.6 8-17.6 21.1 0 29.1l148 67.5c16.89 7.69 44.69 7.69 61.58 0l148-67.5c17.6-8 17.6-21.1 0-29.1l-79.94-38.47" }),
    /* @__PURE__ */ jsx$1("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 32, d: "m160 204.48l-82.8 37.16c-17.6 8-17.6 21.1 0 29.1l148 67.49c16.89 7.7 44.69 7.7 61.58 0l148-67.49c17.7-8 17.7-21.1.1-29.1L352 204.48" })
  ] });
  const ForwardRef$s = H.forwardRef(ionLayersOutline);
  const IconForAll = ForwardRef$v;
  const IconForPrivateFolder = ForwardRef$u;
  const IconForPublicFolder = ForwardRef$t;
  const IconForCollection = ForwardRef$s;
  function FavUsageInfo({
    extraContent
  }) {
    const {
      fav
    } = useSettingsSnapshot();
    const {
      favFolders,
      selectedFavFolder,
      favCollections,
      selectedFavCollection,
      selectedLabel,
      selectedKey
    } = useSnapshot(favStore);
    const onRefresh = useOnRefreshContext();
    const {
      ref,
      getPopupContainer
    } = usePopupContainer();
    useMount(() => {
      favStore.updateList();
    });
    useUpdateEffect(() => {
      void (async () => {
        await delay(100);
        onRefresh == null ? void 0 : onRefresh();
      })();
    }, [fav.addSeparator]);
    const scopeSelectionDropdownMenus = H.useMemo(() => {
      var _a2;
      const collectionSubMenus = [];
      const collectionGrouped = groupBy(favCollections, (x) => x.upper.name);
      let entries = Object.entries(collectionGrouped).map(([upName, collections]) => ({
        upName,
        collections: sortListByName(collections, "title")
      }));
      entries = sortListByName(entries, "upName");
      for (const {
        upName,
        collections
      } of entries) {
        const upMid = (_a2 = collections[0]) == null ? void 0 : _a2.upper.mid;
        const upSpaceUrl = upMid ? formatSpaceUrl(upMid) : "#";
        collectionSubMenus.push(...defineAntMenus([{
          type: "group",
          label: /* @__PURE__ */ jsxs("span", { className: "flex items-center gap-x-2px", children: [
            /* @__PURE__ */ jsx$1(IconForOpenExternalLink, { className: "size-15px mt-2px" }),
            /* @__PURE__ */ jsxs("a", { target: "_blank", href: upSpaceUrl, children: [
              "@",
              upName
            ] })
          ] }),
          children: collections.map((f2) => {
            const key = `fav-collection:${f2.id}`;
            const label = /* @__PURE__ */ jsxs("span", { className: "flex items-center gap-x-2px ml-8px", children: [
              /* @__PURE__ */ jsx$1(IconForCollection, { className: "size-15px" }),
              f2.title,
              " (",
              f2.media_count,
              ")"
            ] });
            return {
              key,
              label,
              async onClick() {
                favStore.selectedFavFolderId = void 0;
                favStore.selectedFavCollectionId = f2.id;
                setScopeDropdownOpen(false);
                await delay(100);
                onRefresh == null ? void 0 : onRefresh();
              }
            };
          })
        }]));
      }
      return defineAntMenus([{
        key: "all",
        icon: /* @__PURE__ */ jsx$1(IconForAll, {}),
        label: "全部",
        async onClick() {
          favStore.selectedFavFolderId = void 0;
          favStore.selectedFavCollectionId = void 0;
          setScopeDropdownOpen(false);
          await delay(100);
          onRefresh == null ? void 0 : onRefresh();
        }
      }, !!favFolders.length && {
        type: "group",
        label: "收藏夹",
        children: favFolders.map((f2) => {
          isFavFolderDefault(f2.attr);
          const isPrivate = isFavFolderPrivate(f2.attr);
          const key = `fav-folder:${f2.id}`;
          const icon = isPrivate ? /* @__PURE__ */ jsx$1(IconForPrivateFolder, {}) : /* @__PURE__ */ jsx$1(IconForPublicFolder, {});
          const label = `${f2.title} (${f2.media_count})`;
          return {
            key,
            icon,
            label,
            async onClick() {
              favStore.selectedFavFolderId = f2.id;
              favStore.selectedFavCollectionId = void 0;
              setScopeDropdownOpen(false);
              await delay(100);
              onRefresh == null ? void 0 : onRefresh();
            }
          };
        })
      }, !!favCollections.length && {
        type: "group",
        label: "合集",
        children: collectionSubMenus
      }]);
    }, [favFolders, favCollections]);
    const [scopeDropdownOpen, setScopeDropdownOpen] = H.useState(false);
    const dropdownButtonClassName = "size-15px relative top-[-0.5px]";
    const dropdownButtonIcon = selectedFavFolder ? isFavFolderPrivate(selectedFavFolder.attr) ? /* @__PURE__ */ jsx$1(IconForPrivateFolder, { className: dropdownButtonClassName }) : /* @__PURE__ */ jsx$1(IconForPublicFolder, { className: dropdownButtonClassName }) : selectedFavCollection ? /* @__PURE__ */ jsx$1(IconForCollection, { className: dropdownButtonClassName }) : /* @__PURE__ */ jsx$1(IconForAll, { className: dropdownButtonClassName });
    const dropdownButtonLabel = selectedLabel;
    const scopeSelectionDropdown = /* @__PURE__ */ jsx$1(antd.Dropdown, { open: scopeDropdownOpen, onOpenChange: setScopeDropdownOpen, placement: "bottomLeft", getPopupContainer, menu: {
      items: scopeSelectionDropdownMenus,
      style: {
        ...dropdownMenuStyle,
        border: `1px solid ${usePopoverBorderColor()}`
      },
      selectedKeys: [selectedKey]
    }, children: /* @__PURE__ */ jsx$1(antd.Button, { css: [scopeDropdownOpen && buttonOpenCss, "", ""], children: /* @__PURE__ */ jsxs("span", { className: "h-full flex items-center gap-x-4px", children: [
      dropdownButtonIcon,
      dropdownButtonLabel
    ] }) }) });
    return /* @__PURE__ */ jsxs("div", { ref, className: "flex items-center gap-x-10px", children: [
      scopeSelectionDropdown,
      extraContent,
      /* @__PURE__ */ jsx$1(CopyBvidButtonsUsageInfo, {})
    ] });
  }
  function ViewingAllExcludeFolderConfig({
    allFavFolderServices,
    state: state2
  }) {
    const {
      fav
    } = useSettingsSnapshot();
    const onRefresh = useOnRefreshContext();
    const {
      ref,
      getPopupContainer
    } = usePopupContainer();
    const {
      totalCountInFavFolders
    } = useSnapshot(state2);
    const [excludeFavFolderIdsChanged, setExcludeFavFolderIdsChanged] = H.useState(false);
    const handleChange = useMemoizedFn((newTargetKeys, direction, moveKeys) => {
      setExcludeFavFolderIdsChanged(true);
      settings.fav.excludedFolderIds = newTargetKeys.map((k) => k.toString());
    });
    const foldersCount = H.useMemo(() => allFavFolderServices.filter((x) => !fav.excludedFolderIds.includes(x.entry.id.toString())).length, [allFavFolderServices, fav.excludedFolderIds]);
    const onPopupOpenChange = useMemoizedFn((open) => {
      if (open) {
        setExcludeFavFolderIdsChanged(false);
      } else {
        if (excludeFavFolderIdsChanged) {
          onRefresh == null ? void 0 : onRefresh();
        }
      }
    });
    return /* @__PURE__ */ jsx$1(antd.Popover, { getTooltipContainer: getPopupContainer, trigger: "click", placement: "bottom", onOpenChange: onPopupOpenChange, getPopupContainer: (el) => el.parentElement || document.body, content: /* @__PURE__ */ jsx$1(Fragment, { children: /* @__PURE__ */ jsx$1(antd.Transfer, { dataSource: allFavFolderServices, rowKey: (row) => row.entry.id.toString(), titles: ["收藏夹", "忽略"], targetKeys: fav.excludedFolderIds, onChange: handleChange, render: (item) => item.entry.title, oneWay: true, style: {
      marginBottom: 10
    } }) }), children: /* @__PURE__ */ jsxs(antd.Tag, { ref, color: "success", className: "cursor-pointer text-size-12px mx-0", children: [
      "收藏夹(",
      foldersCount,
      ") 收藏(",
      totalCountInFavFolders,
      ")"
    ] }) });
  }
  var ELiveStatus = /* @__PURE__ */ ((ELiveStatus2) => {
    ELiveStatus2[ELiveStatus2["Offline"] = 0] = "Offline";
    ELiveStatus2[ELiveStatus2["Streaming"] = 1] = "Streaming";
    ELiveStatus2[ELiveStatus2["Rolling"] = 2] = "Rolling";
    return ELiveStatus2;
  })(ELiveStatus || {});
  async function __fetchSpaceAccInfo(mid) {
    const res = await request.get("/x/space/wbi/acc/info", {
      params: {
        mid,
        w_webid: await get_w_webId() || ""
      }
    });
    const json = res.data;
    if (!isWebApiSuccess(json)) {
      appWarn("space acc info error for %s: %o", mid, json);
      return;
    }
    const info = json.data;
    return info;
  }
  const getSpaceAccInfo = wrapWithIdbCache({
    fn: __fetchSpaceAccInfo,
    generateKey: (mid) => mid.toString(),
    tableName: "space-acc-info",
    ttl: ms("10d"),
    concurrency: 2
    // 因在 react component 中使用, 可能会导致瞬时并发, 引发风控
  });
  async function __fetchUserNickname(mid) {
    const info = await getSpaceAccInfo(mid);
    const nickname = info == null ? void 0 : info.name;
    return nickname;
  }
  const getUserNickname = wrapWithIdbCache({
    fn: __fetchUserNickname,
    generateKey: (mid) => mid.toString(),
    tableName: "user-nickname",
    ttl: ms("10d")
  });
  async function setNicknameCache(mid, nickname) {
    await getUserNickname.cache.set(mid.toString(), {
      val: nickname,
      ts: Date.now()
    });
  }
  var retry$2 = {};
  var retry_operation;
  var hasRequiredRetry_operation;
  function requireRetry_operation() {
    if (hasRequiredRetry_operation) return retry_operation;
    hasRequiredRetry_operation = 1;
    function RetryOperation(timeouts, options) {
      if (typeof options === "boolean") {
        options = { forever: options };
      }
      this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));
      this._timeouts = timeouts;
      this._options = options || {};
      this._maxRetryTime = options && options.maxRetryTime || Infinity;
      this._fn = null;
      this._errors = [];
      this._attempts = 1;
      this._operationTimeout = null;
      this._operationTimeoutCb = null;
      this._timeout = null;
      this._operationStart = null;
      this._timer = null;
      if (this._options.forever) {
        this._cachedTimeouts = this._timeouts.slice(0);
      }
    }
    retry_operation = RetryOperation;
    RetryOperation.prototype.reset = function() {
      this._attempts = 1;
      this._timeouts = this._originalTimeouts.slice(0);
    };
    RetryOperation.prototype.stop = function() {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      if (this._timer) {
        clearTimeout(this._timer);
      }
      this._timeouts = [];
      this._cachedTimeouts = null;
    };
    RetryOperation.prototype.retry = function(err) {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      if (!err) {
        return false;
      }
      var currentTime = (/* @__PURE__ */ new Date()).getTime();
      if (err && currentTime - this._operationStart >= this._maxRetryTime) {
        this._errors.push(err);
        this._errors.unshift(new Error("RetryOperation timeout occurred"));
        return false;
      }
      this._errors.push(err);
      var timeout = this._timeouts.shift();
      if (timeout === void 0) {
        if (this._cachedTimeouts) {
          this._errors.splice(0, this._errors.length - 1);
          timeout = this._cachedTimeouts.slice(-1);
        } else {
          return false;
        }
      }
      var self2 = this;
      this._timer = setTimeout(function() {
        self2._attempts++;
        if (self2._operationTimeoutCb) {
          self2._timeout = setTimeout(function() {
            self2._operationTimeoutCb(self2._attempts);
          }, self2._operationTimeout);
          if (self2._options.unref) {
            self2._timeout.unref();
          }
        }
        self2._fn(self2._attempts);
      }, timeout);
      if (this._options.unref) {
        this._timer.unref();
      }
      return true;
    };
    RetryOperation.prototype.attempt = function(fn, timeoutOps) {
      this._fn = fn;
      if (timeoutOps) {
        if (timeoutOps.timeout) {
          this._operationTimeout = timeoutOps.timeout;
        }
        if (timeoutOps.cb) {
          this._operationTimeoutCb = timeoutOps.cb;
        }
      }
      var self2 = this;
      if (this._operationTimeoutCb) {
        this._timeout = setTimeout(function() {
          self2._operationTimeoutCb();
        }, self2._operationTimeout);
      }
      this._operationStart = (/* @__PURE__ */ new Date()).getTime();
      this._fn(this._attempts);
    };
    RetryOperation.prototype.try = function(fn) {
      console.log("Using RetryOperation.try() is deprecated");
      this.attempt(fn);
    };
    RetryOperation.prototype.start = function(fn) {
      console.log("Using RetryOperation.start() is deprecated");
      this.attempt(fn);
    };
    RetryOperation.prototype.start = RetryOperation.prototype.try;
    RetryOperation.prototype.errors = function() {
      return this._errors;
    };
    RetryOperation.prototype.attempts = function() {
      return this._attempts;
    };
    RetryOperation.prototype.mainError = function() {
      if (this._errors.length === 0) {
        return null;
      }
      var counts = {};
      var mainError = null;
      var mainErrorCount = 0;
      for (var i2 = 0; i2 < this._errors.length; i2++) {
        var error = this._errors[i2];
        var message2 = error.message;
        var count = (counts[message2] || 0) + 1;
        counts[message2] = count;
        if (count >= mainErrorCount) {
          mainError = error;
          mainErrorCount = count;
        }
      }
      return mainError;
    };
    return retry_operation;
  }
  var hasRequiredRetry$1;
  function requireRetry$1() {
    if (hasRequiredRetry$1) return retry$2;
    hasRequiredRetry$1 = 1;
    (function(exports) {
      var RetryOperation = requireRetry_operation();
      exports.operation = function(options) {
        var timeouts = exports.timeouts(options);
        return new RetryOperation(timeouts, {
          forever: options && (options.forever || options.retries === Infinity),
          unref: options && options.unref,
          maxRetryTime: options && options.maxRetryTime
        });
      };
      exports.timeouts = function(options) {
        if (options instanceof Array) {
          return [].concat(options);
        }
        var opts = {
          retries: 10,
          factor: 2,
          minTimeout: 1 * 1e3,
          maxTimeout: Infinity,
          randomize: false
        };
        for (var key in options) {
          opts[key] = options[key];
        }
        if (opts.minTimeout > opts.maxTimeout) {
          throw new Error("minTimeout is greater than maxTimeout");
        }
        var timeouts = [];
        for (var i2 = 0; i2 < opts.retries; i2++) {
          timeouts.push(this.createTimeout(i2, opts));
        }
        if (options && options.forever && !timeouts.length) {
          timeouts.push(this.createTimeout(i2, opts));
        }
        timeouts.sort(function(a2, b) {
          return a2 - b;
        });
        return timeouts;
      };
      exports.createTimeout = function(attempt, opts) {
        var random2 = opts.randomize ? Math.random() + 1 : 1;
        var timeout = Math.round(random2 * Math.max(opts.minTimeout, 1) * Math.pow(opts.factor, attempt));
        timeout = Math.min(timeout, opts.maxTimeout);
        return timeout;
      };
      exports.wrap = function(obj, options, methods) {
        if (options instanceof Array) {
          methods = options;
          options = null;
        }
        if (!methods) {
          methods = [];
          for (var key in obj) {
            if (typeof obj[key] === "function") {
              methods.push(key);
            }
          }
        }
        for (var i2 = 0; i2 < methods.length; i2++) {
          var method = methods[i2];
          var original = obj[method];
          obj[method] = (function retryWrapper(original2) {
            var op = exports.operation(options);
            var args = Array.prototype.slice.call(arguments, 1);
            var callback = args.pop();
            args.push(function(err) {
              if (op.retry(err)) {
                return;
              }
              if (err) {
                arguments[0] = op.mainError();
              }
              callback.apply(this, arguments);
            });
            op.attempt(function() {
              original2.apply(obj, args);
            });
          }).bind(obj, original);
          obj[method].options = options;
        }
      };
    })(retry$2);
    return retry$2;
  }
  var retry$1;
  var hasRequiredRetry;
  function requireRetry() {
    if (hasRequiredRetry) return retry$1;
    hasRequiredRetry = 1;
    retry$1 = requireRetry$1();
    return retry$1;
  }
  var retryExports = requireRetry();
  const retry = /* @__PURE__ */ getDefaultExportFromCjs(retryExports);
  const objectToString = Object.prototype.toString;
  const isError = (value) => objectToString.call(value) === "[object Error]";
  const errorMessages = /* @__PURE__ */ new Set([
    "network error",
    // Chrome
    "Failed to fetch",
    // Chrome
    "NetworkError when attempting to fetch resource.",
    // Firefox
    "The Internet connection appears to be offline.",
    // Safari 16
    "Load failed",
    // Safari 17+
    "Network request failed",
    // `cross-fetch`
    "fetch failed",
    // Undici (Node.js)
    "terminated"
    // Undici (Node.js)
  ]);
  function isNetworkError(error) {
    const isValid = error && isError(error) && error.name === "TypeError" && typeof error.message === "string";
    if (!isValid) {
      return false;
    }
    if (error.message === "Load failed") {
      return error.stack === void 0;
    }
    return errorMessages.has(error.message);
  }
  let AbortError$1 = class AbortError2 extends Error {
    constructor(message2) {
      super();
      if (message2 instanceof Error) {
        this.originalError = message2;
        ({ message: message2 } = message2);
      } else {
        this.originalError = new Error(message2);
        this.originalError.stack = this.stack;
      }
      this.name = "AbortError";
      this.message = message2;
    }
  };
  const decorateErrorWithCounts = (error, attemptNumber, options) => {
    const retriesLeft = options.retries - (attemptNumber - 1);
    error.attemptNumber = attemptNumber;
    error.retriesLeft = retriesLeft;
    return error;
  };
  async function pRetry(input, options) {
    return new Promise((resolve, reject) => {
      options = { ...options };
      options.onFailedAttempt ?? (options.onFailedAttempt = () => {
      });
      options.shouldRetry ?? (options.shouldRetry = () => true);
      options.retries ?? (options.retries = 10);
      const operation = retry.operation(options);
      const abortHandler = () => {
        var _a2;
        operation.stop();
        reject((_a2 = options.signal) == null ? void 0 : _a2.reason);
      };
      if (options.signal && !options.signal.aborted) {
        options.signal.addEventListener("abort", abortHandler, { once: true });
      }
      const cleanUp = () => {
        var _a2;
        (_a2 = options.signal) == null ? void 0 : _a2.removeEventListener("abort", abortHandler);
        operation.stop();
      };
      operation.attempt(async (attemptNumber) => {
        try {
          const result = await input(attemptNumber);
          cleanUp();
          resolve(result);
        } catch (error) {
          try {
            if (!(error instanceof Error)) {
              throw new TypeError(`Non-error was thrown: "${error}". You should only throw errors.`);
            }
            if (error instanceof AbortError$1) {
              throw error.originalError;
            }
            if (error instanceof TypeError && !isNetworkError(error)) {
              throw error;
            }
            decorateErrorWithCounts(error, attemptNumber, options);
            if (!await options.shouldRetry(error)) {
              operation.stop();
              reject(error);
            }
            await options.onFailedAttempt(error);
            if (!operation.retry(error)) {
              throw operation.mainError();
            }
          } catch (finalError) {
            decorateErrorWithCounts(finalError, attemptNumber, options);
            cleanUp();
            reject(finalError);
          }
        }
      });
    });
  }
  var SpaceUploadOrder = /* @__PURE__ */ ((SpaceUploadOrder2) => {
    SpaceUploadOrder2["Latest"] = "pubdate";
    SpaceUploadOrder2["View"] = "click";
    SpaceUploadOrder2["Fav"] = "stow";
    return SpaceUploadOrder2;
  })(SpaceUploadOrder || {});
  const SpaceUploadOrderConfig = {
    [
      "pubdate"
      /* Latest */
    ]: {
      icon: /* @__PURE__ */ jsx$1(IconForTimestamp, {}),
      label: "最新发布"
    },
    [
      "click"
      /* View */
    ]: {
      icon: /* @__PURE__ */ jsx$1(IconForPlayer, {}),
      label: "最多播放"
    },
    [
      "stow"
      /* Fav */
    ]: {
      icon: /* @__PURE__ */ jsx$1(IconForFav, {}),
      label: "最多收藏"
    }
  };
  async function getSpaceUpload({
    mid,
    order = "pubdate",
    keyword = "",
    pagenum = 1
  }) {
    const res = await request.get("/x/space/wbi/arc/search", {
      params: {
        mid,
        order,
        keyword,
        ps: 42,
        // web default
        pn: pagenum
      }
    });
    const json = res.data;
    if (!isWebApiSuccess(json)) {
      throw new Error("request json error: " + json.message || OPERATION_FAIL_MSG);
    }
    const items = json.data.list.vlist || [];
    const count = json.data.page.count;
    let hasMore;
    let endVol;
    {
      const {
        count: count2,
        pn,
        ps
      } = json.data.page;
      hasMore = pn * ps < count2;
      endVol = count2 - (pn - 1) * ps;
    }
    return {
      items,
      hasMore,
      count,
      endVol
    };
  }
  async function tryGetSpaceUpload(...args) {
    return await pRetry(() => getSpaceUpload(...args), {
      retries: 5,
      factor: 1.5,
      onFailedAttempt: (err) => console.error(err)
    });
  }
  var SpaceUploadQueryKey = /* @__PURE__ */ ((SpaceUploadQueryKey2) => {
    SpaceUploadQueryKey2["Mid"] = "space-mid";
    SpaceUploadQueryKey2["GroupId"] = "space-group-id";
    SpaceUploadQueryKey2["SearchText"] = "space-search-text";
    SpaceUploadQueryKey2["FilterText"] = "space-filter-text";
    return SpaceUploadQueryKey2;
  })(SpaceUploadQueryKey || {});
  const searchParams$1 = new URLSearchParams(location.search);
  const QUERY_SPACE_UPLOAD_MID = searchParams$1.get(
    "space-mid"
    /* Mid */
  ) || void 0;
  const QUERY_SPACE_UPLOAD_GROUP_ID = searchParams$1.get(
    "space-group-id"
    /* GroupId */
  ) || void 0;
  const QUERY_SPACE_UPLOAD_SEARCH_TEXT = searchParams$1.get(
    "space-search-text"
    /* SearchText */
  ) || void 0;
  const QUERY_SPACE_UPLOAD_FILTER_TEXT = searchParams$1.get(
    "space-filter-text"
    /* FilterText */
  ) || void 0;
  const mids = (QUERY_SPACE_UPLOAD_MID || "").split(/[,_-]/).map((x) => x.trim()).filter(Boolean).filter((x) => /^\d+$/.test(x));
  const groupId = QUERY_SPACE_UPLOAD_GROUP_ID ? Number(QUERY_SPACE_UPLOAD_GROUP_ID) : void 0;
  const SHOW_SPACE_UPLOAD_ONLY = !!(mids.length || groupId);
  const store$3 = proxy({
    mids,
    groupId,
    order: SpaceUploadOrder.Latest,
    searchText: QUERY_SPACE_UPLOAD_SEARCH_TEXT,
    filterText: QUERY_SPACE_UPLOAD_FILTER_TEXT,
    get isMultipleTraget() {
      return this.mids.length > 1 || !!this.groupId;
    },
    get allowedOrders() {
      return [SpaceUploadOrder.Latest, SpaceUploadOrder.View, !this.isMultipleTraget && SpaceUploadOrder.Fav].filter(Boolean);
    },
    get usingOrder() {
      return this.allowedOrders.includes(this.order) ? this.order : this.allowedOrders[0];
    }
  });
  const clsMenuRoot = styled.createClass`
  .ant-dropdown &.ant-dropdown-menu .ant-dropdown-menu-item {
    font-size: 13px; // same as Button
    justify-content: flex-start;
    .ant-dropdown-menu-title-content {
      flex-shrink: 0;
    }
  }
`;
  const GenericOrderSwitcher = function({
    value,
    onChange,
    disabled,
    list: list2,
    listDisplayConfig,
    dropdownProps,
    extraHelpInfo: extraHelpInfo2,
    $ref
  }) {
    const {
      icon,
      label
    } = listDisplayConfig[value];
    const onToggle = useMemoizedFn(async (e2) => {
      const allowed = list2.filter((x) => x !== "divider");
      const index = allowed.indexOf(value);
      if (index === -1) return;
      const nextIndex = (index + (e2.shiftKey ? -1 : 1) + allowed.length) % allowed.length;
      const next2 = allowed[nextIndex];
      onChange(next2);
    });
    const dropdownMenuItems = H.useMemo(() => {
      return defineAntMenus(list2.map((x) => {
        if (x === "divider") return {
          type: "divider"
        };
        const {
          icon: icon2,
          label: label2
        } = listDisplayConfig[x];
        return {
          key: x,
          icon: icon2,
          label: label2,
          onClick: () => onChange(x)
        };
      }));
    }, [list2, listDisplayConfig, onChange]);
    const dropdownStyle = {
      // width: 'max-content',
      overscrollBehavior: "contain",
      border: `1px solid ${usePopoverBorderColor()}`
    };
    const [open, setOpen] = H.useState(false);
    return /* @__PURE__ */ jsxs("span", { className: "inline-flex items-center", ref: $ref, children: [
      /* @__PURE__ */ jsx$1(
        antd.Dropdown,
        {
          open,
          onOpenChange: setOpen,
          disabled,
          menu: {
            items: dropdownMenuItems,
            style: dropdownStyle,
            className: clsMenuRoot,
            selectedKeys: [value.toString()]
          },
          placement: "bottomRight",
          ...dropdownProps,
          children: /* @__PURE__ */ jsx$1(antd.Button, { onClick: onToggle, css: [open && buttonOpenCss, "", ""], icon, className: "gap-8px px-16px", disabled, children: label })
        }
      ),
      /* @__PURE__ */ jsxs(HelpInfo, { children: [
        extraHelpInfo2,
        extraHelpInfo2 && /* @__PURE__ */ jsx$1(antd.Divider, { variant: "solid", className: "my-7px" }),
        "操作说明: ",
        /* @__PURE__ */ jsx$1("br", {}),
        "1. 点击/下拉切换 ",
        /* @__PURE__ */ jsx$1("br", {}),
        "2. 按住 ",
        /* @__PURE__ */ jsx$1("kbd", { children: "Shift" }),
        " 键点击逆序切换 ",
        /* @__PURE__ */ jsx$1("br", {})
      ] })
    ] });
  };
  const carbonUrl = (props, ref) => /* @__PURE__ */ jsx$1("svg", { viewBox: "0 0 32 32", width: "1.2em", height: "1.2em", ref, ...props, children: /* @__PURE__ */ jsx$1("path", { fill: "currentColor", d: "M24 21V9h-2v14h8v-2zm-4-6v-4c0-1.103-.897-2-2-2h-6v14h2v-6h1.48l2.335 6h2.145l-2.333-6H18c1.103 0 2-.897 2-2m-6-4h4v4h-4zM8 23H4c-1.103 0-2-.897-2-2V9h2v12h4V9h2v12c0 1.103-.897 2-2 2" }) });
  const ForwardRef$r = H.forwardRef(carbonUrl);
  const fixAntdInputSearchAddonCss = {
    name: "6u3tbj",
    styles: ".ant-input-group-addon{button{vertical-align:top;&:not(:first-child){border-top-left-radius:0;border-bottom-left-radius:0;}&:not(:last-child){border-top-right-radius:0;border-bottom-right-radius:0;}}}"
  };
  function SpaceUploadUsageInfo() {
    const {
      searchText,
      filterText,
      allowedOrders,
      usingOrder
    } = useSnapshot(store$3, {
      sync: true
    });
    const {
      order
    } = useSnapshot(store$3);
    const onRefresh = useOnRefreshContext();
    const onSyncStoreToUrl = useMemoizedFn(() => {
      const u2 = new URL(location.href);
      const {
        searchText: searchText2,
        filterText: filterText2
      } = store$3;
      searchText2 ? u2.searchParams.set(SpaceUploadQueryKey.SearchText, searchText2) : u2.searchParams.delete(SpaceUploadQueryKey.SearchText);
      filterText2 ? u2.searchParams.set(SpaceUploadQueryKey.FilterText, filterText2) : u2.searchParams.delete(SpaceUploadQueryKey.FilterText);
      location.href = u2.href;
    });
    return /* @__PURE__ */ jsxs("div", { className: "flex items-center gap-x-10px", children: [
      /* @__PURE__ */ jsx$1(GenericOrderSwitcher, { value: usingOrder, list: allowedOrders, listDisplayConfig: SpaceUploadOrderConfig, onChange: (value) => {
        store$3.order = value;
        onRefresh == null ? void 0 : onRefresh();
      } }),
      /* @__PURE__ */ jsx$1(antd.Input.Search, { style: {
        width: 200
      }, placeholder: "搜索词", allowClear: true, css: fixAntdInputSearchAddonCss, addonAfter: /* @__PURE__ */ jsx$1(AntdTooltip, { title: "同步搜索词到 URL", children: /* @__PURE__ */ jsx$1(antd.Button, { className: "size-32px inline-flex-center p-0", onClick: onSyncStoreToUrl, children: /* @__PURE__ */ jsx$1(ForwardRef$r, { className: "size-20px" }) }) }), value: searchText, onChange: (e2) => store$3.searchText = e2.target.value, onSearch: (value) => {
        store$3.searchText = value;
        onRefresh == null ? void 0 : onRefresh();
      } }),
      /* @__PURE__ */ jsx$1(antd.Input.Search, { style: {
        width: 200
      }, placeholder: "本地过滤词", allowClear: true, css: fixAntdInputSearchAddonCss, addonAfter: /* @__PURE__ */ jsx$1(AntdTooltip, { title: "同步过滤词到 URL", children: /* @__PURE__ */ jsx$1(antd.Button, { className: "size-32px inline-flex-center p-0", onClick: onSyncStoreToUrl, children: /* @__PURE__ */ jsx$1(ForwardRef$r, { className: "size-20px" }) }) }), value: filterText, onChange: (e2) => store$3.filterText = e2.target.value, onSearch: (value) => {
        store$3.filterText = value;
        onRefresh == null ? void 0 : onRefresh();
      } }),
      /* @__PURE__ */ jsx$1(CheckboxSettingItem, { configPath: "spaceUpload.showVol", label: "显示序号", className: "flex-none" }),
      /* @__PURE__ */ jsx$1(CopyBvidButtonsUsageInfo, {})
    ] });
  }
  function isSpaceUploadItemChargeOnly(item) {
    if (item.elec_arc_type === 1 || !item.elec_arc_type && item.is_charging_arc) return true;
    if (item.elec_arc_type === 2) return true;
    return false;
  }
  const spaceUploadAvatarCache = new QuickLRU({
    maxSize: 100
  });
  function getSpaceUploadServiceConfig() {
    const snap = snapshot(store$3);
    return {
      mids: snap.mids,
      groupId: snap.groupId,
      order: snap.usingOrder,
      searchText: snap.searchText,
      filterText: snap.filterText
    };
  }
  const _SpaceUploadService = class _SpaceUploadService extends BaseTabService {
    constructor(config) {
      var _a2;
      super(_SpaceUploadService.PAGE_SIZE);
      // service config
      __publicField(this, "mids");
      __publicField(this, "groupId");
      __publicField(this, "order");
      __publicField(this, "searchText");
      __publicField(this, "filterText");
      __publicField(this, "usageInfo", /* @__PURE__ */ jsx$1(SpaceUploadUsageInfo, {}));
      /**
       * side effects
       */
      __publicField(this, "pageTitleSet", false);
      __publicField(this, "mergeTimelineService");
      Object.assign(this, config);
      this.mids = config.mids;
      this.order = config.order;
      invariant(this.mids.length || this.groupId, "mid & groupId can not both be empty");
      this.searchText = (_a2 = this.searchText) == null ? void 0 : _a2.trim();
    }
    get hasMoreExceptQueue() {
      if (!this.mergeTimelineService) return true;
      return this.mergeTimelineService.hasMore;
    }
    async fetchAvatars(mids2) {
      await Promise.all(mids2.map(async (mid) => {
        const info = await getSpaceAccInfo(mid);
        if (!info) return;
        spaceUploadAvatarCache.set(mid, info.face);
      }));
    }
    async setPageTitle() {
      var _a2;
      if (this.pageTitleSet) return;
      const prefixes = [];
      if (this.searchText) prefixes.push(`🔍【${this.searchText}】`);
      if (this.filterText) prefixes.push(`⏳【${this.filterText}】`);
      let author;
      if (this.mids.length) {
        const nicknames = await pmap(this.mids, getUserNickname, 3);
        author = nicknames.map((x) => x == null ? void 0 : x.trim()).filter(Boolean).map((name) => `「${name}」`).join("、");
      } else {
        const tags = await getAllFollowGroups();
        const name = ((_a2 = tags.find((x) => x.tagid === this.groupId)) == null ? void 0 : _a2.name) || "";
        author = name ? `「${name}」` : "";
      }
      const title = [prefixes.join(""), `${author}的投稿`].map((x) => x.trim()).filter(Boolean).join(" - ");
      setPageTitle(title);
      this.pageTitleSet = true;
    }
    setupMergeTimelineService() {
    }
    async fetchMore(abortSignal) {
      if (!this.mergeTimelineService) {
        if (this.mids.length) {
          this.mergeTimelineService = new MergeTimeService(this.mids, this.order, this.searchText);
        } else if (this.groupId) {
          const mids2 = await getFollowGroupContent(this.groupId);
          this.mergeTimelineService = new MergeTimeService(mids2.map((x) => x.toString()), this.order, this.searchText);
        }
      }
      invariant(this.mergeTimelineService, "mergeTimelineService should not be undefined");
      if (!this.mergeTimelineService.hasMore) return;
      this.setPageTitle();
      const items = await this.mergeTimelineService.loadMore(abortSignal) || [];
      const fetchedCount = this.qs.fetchedCount;
      const endVol = this.mergeTimelineService.count - fetchedCount;
      let list2 = items.map((item, index) => {
        return {
          ...item,
          api: EApiType.SpaceUpload,
          uniqId: `${EApiType.SpaceUpload}-${item.bvid}`,
          vol: this.mergeTimelineService.count ? endVol - index : 0
        };
      });
      list2 = list2.filter((item) => !isSpaceUploadItemChargeOnly(item));
      if (this.filterText) {
        const {
          includes,
          excludes
        } = parseSearchInput(this.filterText);
        list2 = list2.filter((item) => {
          return includes.every((include) => item.title.includes(include)) && excludes.every((exclude) => !item.title.includes(exclude));
        });
      }
      await this.fetchAvatars(list2.map((item) => item.mid.toString()));
      return list2;
    }
  };
  __publicField(_SpaceUploadService, "PAGE_SIZE", 20);
  let SpaceUploadService = _SpaceUploadService;
  class MergeTimeService {
    constructor(mids2, order, searchText) {
      __publicField(this, "singleUpServices");
      this.mids = mids2;
      this.order = order;
      this.searchText = searchText;
      invariant(this.mids.length === 1 || this.mids.length > 1 && this.order !== SpaceUploadOrder.Fav, "SpaceUploadItem.Fav not supported when merging");
      this.singleUpServices = mids2.map((mid) => new SingleUpService(mid, this.order, this.searchText));
    }
    get hasMore() {
      return this.singleUpServices.some((service) => service.hasMore);
    }
    get count() {
      return this.singleUpServices.reduce((total, service) => total + service.count, 0);
    }
    async refillQueues(abortSignal) {
      await pmap(this.singleUpServices, (s2) => s2.refillQueue(1, abortSignal), 5);
    }
    async loadMore(abortSignal) {
      if (!this.hasMore) return;
      if (this.mids.length === 1) {
        return this.singleUpServices[0].loadMore(abortSignal);
      }
      const pickedItems = [];
      const expectSize = 10;
      while (this.hasMore && pickedItems.length < expectSize) {
        await this.refillQueues(abortSignal);
        const restServices = this.singleUpServices.filter((s2) => s2.bufferQueue.length > 0);
        const pickedService = orderBy(restServices.map((service) => {
          const item = service.bufferQueue[0];
          const valueForSort = {
            [SpaceUploadOrder.Latest]: item.created,
            [SpaceUploadOrder.View]: item.play,
            [SpaceUploadOrder.Fav]: item.play
            // no fav data
          }[this.order];
          return {
            service,
            item,
            valueForSort
          };
        }), ["valueForSort"], ["desc"]).map((x) => x.service)[0];
        if (!pickedService) break;
        const head = pickedService.bufferQueue[0];
        pickedService.bufferQueue = pickedService.bufferQueue.slice(1);
        pickedItems.push(head);
      }
      return pickedItems;
    }
  }
  class SingleUpService {
    constructor(mid, order, searchText) {
      __publicField(this, "bufferQueue", []);
      __publicField(this, "hasMoreForApi", true);
      __publicField(this, "count", 0);
      __publicField(this, "page", 1);
      this.mid = mid;
      this.order = order;
      this.searchText = searchText;
    }
    get hasMore() {
      return !!this.bufferQueue.length || this.hasMoreForApi;
    }
    async refillQueue(minimalQueueSize, abortSignal) {
      if (!this.hasMore) return;
      while (!(abortSignal == null ? void 0 : abortSignal.aborted) && this.hasMoreForApi && this.bufferQueue.length < minimalQueueSize) {
        const items = await this.loadMore(abortSignal) || [];
        this.bufferQueue.push(...items);
      }
    }
    async loadMore(abortSignal) {
      const {
        items,
        hasMore,
        count
      } = await tryGetSpaceUpload({
        mid: this.mid,
        order: this.order,
        pagenum: this.page,
        keyword: this.searchText || ""
      });
      this.hasMoreForApi = hasMore;
      this.page++;
      this.count = count;
      return items;
    }
  }
  const toHttps = (url) => (url || "").replace(/^http:\/\//, "https://");
  function parseDuration(d2) {
    if (!d2) return 0;
    const units = [1, 60, 360];
    const splited = d2.split(":").map((s2) => Number(s2)).reverse();
    const total = splited.reduce((total2, cur, index) => {
      return total2 + cur * units[index];
    }, 0);
    return total;
  }
  function formatDuration(d2) {
    d2 || (d2 = 0);
    return dayjs.duration(d2 || 0, "seconds").format(d2 >= 3600 ? "HH:mm:ss" : "mm:ss");
  }
  function formatCount(count) {
    if (!count) {
      if (typeof count === "number") return "0";
      else return count;
    }
    if (count <= 9999) {
      return count.toString();
    }
    const trimDotZero = (s2) => s2.replace(/\.0$/, "");
    count /= 1e4;
    if (count <= 9999) {
      const c2 = trimDotZero(count.toFixed(1));
      return `${c2}万`;
    }
    count /= 1e4;
    if (count <= 9999) {
      const c2 = trimDotZero(count.toFixed(1));
      return `${c2}亿`;
    }
    console.warn(`formatCount(count = ${count}); can not handle input`);
  }
  function parseCount(str) {
    if (!str) return void 0;
    if (str === "-") return 0;
    if (/^\d+$/.test(str)) return Number(str);
    if (/^\d+(\.\d+?)?万$/.test(str)) return Number(str.slice(0, -1)) * 1e4;
    if (/^\d+(\.\d+?)?亿$/.test(str)) return Number(str.slice(0, -1)) * 1e8;
  }
  const currentYear = dayjs().format("YYYY");
  function formatTimeStamp(unixTs, includeTime = false) {
    if (!unixTs) return "";
    const t2 = dayjs.unix(unixTs);
    const extraFormat = includeTime ? " HH:mm" : "";
    if (t2.format("YYYY") === currentYear) {
      return t2.format("M-D" + extraFormat);
    } else {
      return t2.format("YY-M-D" + extraFormat);
    }
  }
  function formatRecentTimeStamp(ts, zhDate) {
    if (!ts) return void 0;
    const t2 = dayjs.unix(ts);
    const FORMAT_YEAR = "YYYY";
    const FORMAT_DATE = "YYYY-MM-DD";
    const isToday = t2.format(FORMAT_DATE) === dayjs().format(FORMAT_DATE);
    const isTodayRecent = isToday && Date.now() - ts * 1e3 <= ms("12h");
    const isYesterday = t2.format(FORMAT_DATE) === dayjs().subtract(1, "day").format(FORMAT_DATE);
    const isCurrentYear = t2.format(FORMAT_YEAR) === dayjs().format(FORMAT_YEAR);
    if (isTodayRecent) {
      const minutes = dayjs().diff(t2, "minutes");
      const hours = dayjs().diff(t2, "hours");
      if (minutes < 1) {
        return "刚刚";
      } else if (minutes < 60) {
        return `${minutes}分钟前`;
      } else {
        return `${hours}小时前`;
      }
    }
    if (isToday) return t2.format("今天 HH:mm");
    if (isYesterday) return t2.format("昨天 HH:mm");
    if (isCurrentYear) {
      return t2.format(zhDate ? "M月D日" : "M-D");
    } else {
      return t2.format(zhDate ? "YYYY年M月D日" : "YY-M-D");
    }
  }
  const VideoStateMap = {
    "1": "橙色通过",
    "0": "开放浏览",
    "-1": "待审",
    "-2": "被打回",
    "-3": "网警锁定",
    "-4": "被锁定",
    "-5": "管理员锁定",
    "-6": "修复待审",
    "-7": "暂缓审核",
    "-8": "补档待审",
    "-9": "等待转码",
    "-10": "延迟审核",
    "-11": "视频源待修",
    "-12": "转储失败",
    "-13": "允许评论待审",
    "-14": "临时回收站",
    "-15": "分发中",
    "-16": "转码失败",
    "-20": "创建未提交",
    "-30": "创建已提交",
    "-40": "定时发布",
    "-100": "用户删除"
  };
  function getVideoInvalidReason(state2) {
    if (typeof state2 === "undefined") return;
    if (state2 >= 0) return;
    return VideoStateMap[state2];
  }
  var XOR_CODE = 23442827791579n;
  var MASK_CODE = 2251799813685247n;
  var MAX_AID = 1n << 51n;
  var BASE = 58n;
  var data = "FcwAPNKTMug3GV5Lj7EJnHpWsx4tb8haYeviqBz6rkCy12mUSDQX9RdoZf";
  function av2bv(aid) {
    const bytes = ["B", "V", "1", "0", "0", "0", "0", "0", "0", "0", "0", "0"];
    let bvIndex = bytes.length - 1;
    let tmp = (MAX_AID | BigInt(aid)) ^ XOR_CODE;
    while (tmp > 0) {
      bytes[bvIndex] = data[Number(tmp % BigInt(BASE))];
      tmp = tmp / BASE;
      bvIndex -= 1;
    }
    [bytes[3], bytes[9]] = [bytes[9], bytes[3]];
    [bytes[4], bytes[7]] = [bytes[7], bytes[4]];
    return bytes.join("");
  }
  function bv2av(bvid) {
    const bvidArr = Array.from(bvid);
    [bvidArr[3], bvidArr[9]] = [bvidArr[9], bvidArr[3]];
    [bvidArr[4], bvidArr[7]] = [bvidArr[7], bvidArr[4]];
    bvidArr.splice(0, 3);
    const tmp = bvidArr.reduce((pre, bvidChar) => pre * BASE + BigInt(data.indexOf(bvidChar)), 0n);
    return Number(tmp & MASK_CODE ^ XOR_CODE);
  }
  var BvCode = { av2bv, bv2av };
  const IconForStatPlay = createSvgComponent((props) => {
    return /* @__PURE__ */ jsxs("svg", { viewBox: "0 0 24 24", width: "24", height: "24", fill: "#fff", ...props, children: [
      /* @__PURE__ */ jsx$1("path", { d: "M12 4.99805C9.48178 4.99805 7.283 5.12616 5.73089 5.25202C4.65221 5.33949 3.81611 6.16352 3.72 7.23254C3.60607 8.4998 3.5 10.171 3.5 11.998C3.5 13.8251 3.60607 15.4963 3.72 16.76355C3.81611 17.83255 4.65221 18.6566 5.73089 18.7441C7.283 18.8699 9.48178 18.998 12 18.998C14.5185 18.998 16.7174 18.8699 18.2696 18.74405C19.3481 18.65655 20.184 17.8328 20.2801 16.76405C20.394 15.4973 20.5 13.82645 20.5 11.998C20.5 10.16965 20.394 8.49877 20.2801 7.23205C20.184 6.1633 19.3481 5.33952 18.2696 5.25205C16.7174 5.12618 14.5185 4.99805 12 4.99805zM5.60965 3.75693C7.19232 3.62859 9.43258 3.49805 12 3.49805C14.5677 3.49805 16.8081 3.62861 18.3908 3.75696C20.1881 3.90272 21.6118 5.29278 21.7741 7.09773C21.8909 8.3969 22 10.11405 22 11.998C22 13.88205 21.8909 15.5992 21.7741 16.8984C21.6118 18.7033 20.1881 20.09335 18.3908 20.23915C16.8081 20.3675 14.5677 20.498 12 20.498C9.43258 20.498 7.19232 20.3675 5.60965 20.2392C3.81206 20.0934 2.38831 18.70295 2.22603 16.8979C2.10918 15.5982 2 13.8808 2 11.998C2 10.1153 2.10918 8.39787 2.22603 7.09823C2.38831 5.29312 3.81206 3.90269 5.60965 3.75693z", fill: "currentColor" }),
      /* @__PURE__ */ jsx$1("path", { d: "M14.7138 10.96875C15.50765 11.4271 15.50765 12.573 14.71375 13.0313L11.5362 14.8659C10.74235 15.3242 9.75 14.7513 9.75001 13.8346L9.75001 10.1655C9.75001 9.24881 10.74235 8.67587 11.5362 9.13422L14.7138 10.96875z", fill: "currentColor" })
    ] });
  });
  const IconForStatDanmaku = createSvgComponent((props) => {
    return /* @__PURE__ */ jsxs("svg", { viewBox: "0 0 24 24", width: "24", height: "24", fill: "#ffffff", ...props, children: [
      /* @__PURE__ */ jsx$1("path", { d: "M12 4.99805C9.48178 4.99805 7.283 5.12616 5.73089 5.25202C4.65221 5.33949 3.81611 6.16352 3.72 7.23254C3.60607 8.4998 3.5 10.171 3.5 11.998C3.5 13.8251 3.60607 15.4963 3.72 16.76355C3.81611 17.83255 4.65221 18.6566 5.73089 18.7441C7.283 18.8699 9.48178 18.998 12 18.998C14.5185 18.998 16.7174 18.8699 18.2696 18.74405C19.3481 18.65655 20.184 17.8328 20.2801 16.76405C20.394 15.4973 20.5 13.82645 20.5 11.998C20.5 10.16965 20.394 8.49877 20.2801 7.23205C20.184 6.1633 19.3481 5.33952 18.2696 5.25205C16.7174 5.12618 14.5185 4.99805 12 4.99805zM5.60965 3.75693C7.19232 3.62859 9.43258 3.49805 12 3.49805C14.5677 3.49805 16.8081 3.62861 18.3908 3.75696C20.1881 3.90272 21.6118 5.29278 21.7741 7.09773C21.8909 8.3969 22 10.11405 22 11.998C22 13.88205 21.8909 15.5992 21.7741 16.8984C21.6118 18.7033 20.1881 20.09335 18.3908 20.23915C16.8081 20.3675 14.5677 20.498 12 20.498C9.43258 20.498 7.19232 20.3675 5.60965 20.2392C3.81206 20.0934 2.38831 18.70295 2.22603 16.8979C2.10918 15.5982 2 13.8808 2 11.998C2 10.1153 2.10918 8.39787 2.22603 7.09823C2.38831 5.29312 3.81206 3.90269 5.60965 3.75693z", fill: "currentColor" }),
      /* @__PURE__ */ jsx$1("path", { d: "M15.875 10.75L9.875 10.75C9.46079 10.75 9.125 10.4142 9.125 10C9.125 9.58579 9.46079 9.25 9.875 9.25L15.875 9.25C16.2892 9.25 16.625 9.58579 16.625 10C16.625 10.4142 16.2892 10.75 15.875 10.75z", fill: "currentColor" }),
      /* @__PURE__ */ jsx$1("path", { d: "M17.375 14.75L11.375 14.75C10.9608 14.75 10.625 14.4142 10.625 14C10.625 13.5858 10.9608 13.25 11.375 13.25L17.375 13.25C17.7892 13.25 18.125 13.5858 18.125 14C18.125 14.4142 17.7892 14.75 17.375 14.75z", fill: "currentColor" }),
      /* @__PURE__ */ jsx$1("path", { d: "M7.875 10C7.875 10.4142 7.53921 10.75 7.125 10.75L6.625 10.75C6.21079 10.75 5.875 10.4142 5.875 10C5.875 9.58579 6.21079 9.25 6.625 9.25L7.125 9.25C7.53921 9.25 7.875 9.58579 7.875 10z", fill: "currentColor" }),
      /* @__PURE__ */ jsx$1("path", { d: "M9.375 14C9.375 14.4142 9.03921 14.75 8.625 14.75L8.125 14.75C7.71079 14.75 7.375 14.4142 7.375 14C7.375 13.5858 7.71079 13.25 8.125 13.25L8.625 13.25C9.03921 13.25 9.375 13.5858 9.375 14z", fill: "currentColor" })
    ] });
  });
  const IconForRoll = createSvgComponent(function(props) {
    return /* @__PURE__ */ jsxs("svg", { viewBox: "0 0 16 16", width: "16", height: "16", fill: "currentColor", ...props, children: [
      /* @__PURE__ */ jsx$1("path", { d: "M8.624933333333333 13.666666666666666C8.624933333333333 14.011849999999999 8.345125 14.291666666666666 7.999933333333333 14.291666666666666C4.525166666666666 14.291666666666666 1.7082933333333332 11.474791666666665 1.7082933333333332 8C1.7082933333333332 6.013308333333333 2.629825 4.2414233333333335 4.066321666666667 3.089385C4.335603333333333 2.8734283333333335 4.728959999999999 2.9166533333333335 4.944915 3.1859349999999997C5.160871666666666 3.4552099999999997 5.1176466666666665 3.848573333333333 4.848366666666666 4.0645283333333335C3.694975 4.98953 2.9582933333333328 6.40852 2.9582933333333328 8C2.9582933333333328 10.784416666666667 5.215528333333333 13.041666666666666 7.999933333333333 13.041666666666666C8.345125 13.041666666666666 8.624933333333333 13.321483333333333 8.624933333333333 13.666666666666666zM11.060475 12.810558333333333C10.844225000000002 12.541558333333331 10.887033333333335 12.148125 11.156041666666667 11.931875C12.306858333333333 11.006775 13.041599999999999 9.589424999999999 13.041599999999999 8C13.041599999999999 5.215561666666666 10.784408333333332 2.958333333333333 7.999933333333333 2.958333333333333C7.6548083333333325 2.958333333333333 7.374933333333333 2.6785083333333333 7.374933333333333 2.333333333333333C7.374933333333333 1.9881533333333332 7.6548083333333325 1.7083333333333333 7.999933333333333 1.7083333333333333C11.474725000000001 1.7083333333333333 14.291599999999999 4.525206666666667 14.291599999999999 8C14.291599999999999 9.984108333333333 13.372483333333332 11.753958333333332 11.939225 12.906125C11.670166666666663 13.122375 11.276725 13.079625 11.060475 12.810558333333333z", fill: "currentColor" }),
      /* @__PURE__ */ jsx$1("path", { d: "M1.375 3.4130866666666666C1.375 3.0679066666666666 1.654825 2.7880866666666666 2 2.7880866666666666L4.333333333333333 2.7880866666666666C4.862608333333333 2.7880866666666666 5.291666666666666 3.2171449999999995 5.291666666666666 3.7464199999999996L5.291666666666666 6.079753333333334C5.291666666666666 6.424928333333334 5.011841666666666 6.704736666666666 4.666666666666666 6.704736666666666C4.321491666666667 6.704736666666666 4.041666666666666 6.424928333333334 4.041666666666666 6.079753333333334L4.041666666666666 4.038086666666667L2 4.038086666666667C1.654825 4.038086666666667 1.375 3.7582616666666664 1.375 3.4130866666666666z", fill: "currentColor" }),
      /* @__PURE__ */ jsx$1("path", { d: "M14.625 12.5864C14.625 12.931591666666666 14.345183333333333 13.2114 14 13.2114L11.666666666666666 13.2114C11.137408333333335 13.2114 10.708333333333332 12.782383333333332 10.708333333333332 12.253066666666665L10.708333333333332 9.919733333333333C10.708333333333332 9.574608333333334 10.98815 9.294733333333333 11.333333333333332 9.294733333333333C11.678516666666667 9.294733333333333 11.958333333333332 9.574608333333334 11.958333333333332 9.919733333333333L11.958333333333332 11.9614L14 11.9614C14.345183333333333 11.9614 14.625 12.241275000000002 14.625 12.5864z", fill: "currentColor" })
    ] });
  });
  const iconParkOutlineThumbsUp = (props, ref) => /* @__PURE__ */ jsx$1("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref, ...props, children: /* @__PURE__ */ jsx$1("path", { fill: "none", stroke: "currentColor", strokeLinejoin: "round", strokeWidth: 4, d: "M27.6 18.6v-7.2A5.4 5.4 0 0 0 22.2 6L15 22.2V42h20.916a3.6 3.6 0 0 0 3.6-3.06L42 22.74a3.6 3.6 0 0 0-3.6-4.14zM15 22h-4.806C8.085 21.963 6.283 23.71 6 25.8v12.6a4.16 4.16 0 0 0 4.194 3.6H15z" }) });
  const ForwardRef$q = H.forwardRef(iconParkOutlineThumbsUp);
  const tablerHeartFilled = (props, ref) => /* @__PURE__ */ jsx$1("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref, ...props, children: /* @__PURE__ */ jsx$1("path", { fill: "currentColor", d: "M6.979 3.074a6 6 0 0 1 4.988 1.425l.037.033l.034-.03a6 6 0 0 1 4.733-1.44l.246.036a6 6 0 0 1 3.364 10.008l-.18.185l-.048.041l-7.45 7.379a1 1 0 0 1-1.313.082l-.094-.082l-7.493-7.422A6 6 0 0 1 6.979 3.074" }) });
  const ForwardRef$p = H.forwardRef(tablerHeartFilled);
  const tablerCoinYen = (props, ref) => /* @__PURE__ */ jsx$1("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref, ...props, children: /* @__PURE__ */ jsxs("g", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, children: [
    /* @__PURE__ */ jsx$1("path", { d: "M3 12a9 9 0 1 0 18 0a9 9 0 1 0-18 0m6 0h6m-6 3h6M9 8l3 4.5" }),
    /* @__PURE__ */ jsx$1("path", { d: "m15 8l-3 4.5V17" })
  ] }) });
  const ForwardRef$o = H.forwardRef(tablerCoinYen);
  const iconParkOutlinePreviewOpen = (props, ref) => /* @__PURE__ */ jsx$1("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref, ...props, children: /* @__PURE__ */ jsxs("g", { fill: "none", stroke: "currentColor", strokeLinejoin: "round", strokeWidth: 4, children: [
    /* @__PURE__ */ jsx$1("path", { d: "M24 36c11.046 0 20-12 20-12s-8.954-12-20-12S4 24 4 24s8.954 12 20 12Z" }),
    /* @__PURE__ */ jsx$1("path", { d: "M24 29a5 5 0 1 0 0-10a5 5 0 0 0 0 10Z" })
  ] }) });
  const ForwardRef$n = H.forwardRef(iconParkOutlinePreviewOpen);
  function defineStatItems(items) {
    return items;
  }
  const clsForBiliIcon = "size-18px";
  const clsForThirdPartyIcon = "size-16px";
  const StatFieldIconConfig = {
    "play": /* @__PURE__ */ jsx$1(IconForStatPlay, { className: clsForBiliIcon }),
    // or #widget-play-count,
    "danmaku": /* @__PURE__ */ jsx$1(IconForStatDanmaku, { className: clsForBiliIcon }),
    "like": /* @__PURE__ */ jsx$1(ForwardRef$q, { className: clsForThirdPartyIcon }),
    "bangumi:follow": /* @__PURE__ */ jsx$1(ForwardRef$p, { className: clsForThirdPartyIcon }),
    "favorite": /* @__PURE__ */ jsx$1(IconForFav, { className: clsForThirdPartyIcon }),
    "coin": /* @__PURE__ */ jsx$1(ForwardRef$o, { className: clsForThirdPartyIcon }),
    "live:viewed-by": /* @__PURE__ */ jsx$1(ForwardRef$n, { className: clsForThirdPartyIcon })
  };
  const AppRecStatItemFieldMap = {
    1: "play",
    2: "like",
    // 没出现过, 猜的
    3: "danmaku",
    4: "bangumi:follow",
    // 追番
    20: "like"
    // 动态点赞
  };
  function getField(id) {
    return AppRecStatItemFieldMap[id] || AppRecStatItemFieldMap[1];
  }
  const StatItemDisplay = H.memo(function({
    field,
    value
  }) {
    const text = H.useMemo(() => {
      if (typeof value === "number" || value && /^\d+$/.test(value)) {
        return formatCount(Number(value)) ?? STAT_NUMBER_FALLBACK;
      } else {
        return value ?? STAT_NUMBER_FALLBACK;
      }
    }, [value]);
    const icon = StatFieldIconConfig[field];
    return /* @__PURE__ */ jsxs("span", { "data-field": field, className: "bili-video-card__stats--item mr-0! gap-x-2px", children: [
      icon,
      /* @__PURE__ */ jsx$1("span", { className: clsx("bili-video-card__stats--text line-height-18px"), children: text })
    ] });
  });
  const DESC_SEPARATOR = " · ";
  function lookinto(item, opts) {
    if (isAppRecommend(item)) return opts[EApiType.AppRecommend](item);
    if (isPcRecommend(item)) return opts[EApiType.PcRecommend](item);
    if (isDynamicFeed(item)) return opts[EApiType.DynamicFeed](item);
    if (isWatchlater(item)) return opts[EApiType.Watchlater](item);
    if (isFav(item)) return opts[EApiType.Fav](item);
    if (isPopularGeneral(item)) return opts[EApiType.PopularGeneral](item);
    if (isPopularWeekly(item)) return opts[EApiType.PopularWeekly](item);
    if (isRank(item)) return opts[EApiType.Rank](item);
    if (isLive(item)) return opts[EApiType.Live](item);
    if (isSpaceUpload(item)) return opts[EApiType.SpaceUpload](item);
    throw new Error(`unknown api type`);
  }
  function normalizeCardData(item) {
    const ret = lookinto(item, {
      [EApiType.AppRecommend]: apiAppAdapter,
      [EApiType.PcRecommend]: apiPcAdapter,
      [EApiType.DynamicFeed]: apiDynamicAdapter,
      [EApiType.Watchlater]: apiWatchlaterAdapter,
      [EApiType.Fav]: apiFavAdapter,
      [EApiType.PopularGeneral]: apiPopularGeneralAdapter,
      [EApiType.PopularWeekly]: apiPopularWeeklyAdapter,
      [EApiType.Rank]: apiRankAdapter,
      [EApiType.Live]: apiLiveAdapter,
      [EApiType.SpaceUpload]: apiSpaceUploadAdapter
    });
    if (ret.authorFace) ret.authorFace = toHttps(ret.authorFace);
    ret.cover = toHttps(ret.cover);
    return ret;
  }
  function apiAppAdapter(item) {
    return item.device === "android" ? apiAndroidAppAdapter(item) : apiIpadAppAdapter(item);
  }
  function apiAndroidAppAdapter(item) {
    var _a2, _b2, _c2, _d2;
    const extractCountFor = (target) => {
      const {
        cover_left_icon_1,
        cover_left_text_1,
        cover_left_icon_2,
        cover_left_text_2
      } = item;
      if (cover_left_icon_1 && AppRecStatItemFieldMap[cover_left_icon_1] === target) {
        return parseCount(cover_left_text_1);
      }
      if (cover_left_icon_2 && AppRecStatItemFieldMap[cover_left_icon_2] === target) {
        return parseCount(cover_left_text_2);
      }
    };
    const avid = item.param;
    const bvid = BvCode.av2bv(Number(item.param));
    const cid = (_a2 = item.player_args) == null ? void 0 : _a2.cid;
    const href = (() => {
      var _a3;
      if (item.uri.startsWith("http://") || item.uri.startsWith("https://")) {
        return item.uri;
      }
      if (item.goto === "av") {
        return `/video/${bvid}/`;
      }
      if (item.goto === "bangumi") {
        appWarn(`bangumi uri should not starts with 'bilibili://': %s`, item.uri);
        return item.uri;
      }
      if (item.goto === "picture") {
        const id = (_a3 = /^bilibili:\/\/article\/(\d+)$/.exec(item.uri)) == null ? void 0 : _a3[1];
        if (id) return `/read/cv${id}`;
        return item.uri;
      }
      return item.uri;
    })();
    return {
      // video
      avid,
      bvid,
      cid,
      goto: item.goto,
      href,
      title: item.title,
      cover: item.cover,
      pubts: void 0,
      pubdateDisplay: void 0,
      duration: ((_b2 = item.player_args) == null ? void 0 : _b2.duration) || 0,
      durationStr: formatDuration((_c2 = item.player_args) == null ? void 0 : _c2.duration),
      recommendReason: item.rcmd_reason,
      // stat
      play: extractCountFor("play"),
      danmaku: extractCountFor("danmaku"),
      bangumiFollow: extractCountFor("bangumi:follow"),
      like: void 0,
      coin: void 0,
      favorite: void 0,
      // e.g 2023-09-17
      // cover_left_1_content_description: "156点赞"
      // cover_left_icon_1: 20
      // cover_left_text_1: "156"
      statItems: [item.cover_left_text_1 && {
        field: getField(item.cover_left_icon_1),
        value: item.cover_left_text_1
      }, item.cover_left_text_2 && {
        field: getField(item.cover_left_icon_2),
        value: item.cover_left_text_2
      }].filter(Boolean),
      // author
      authorName: item.args.up_name,
      authorFace: void 0,
      authorMid: String(item.args.up_id),
      appBadge: item.badge,
      appBadgeDesc: ((_d2 = item.desc_button) == null ? void 0 : _d2.text) || item.desc || ""
    };
  }
  function apiIpadAppAdapter(item) {
    var _a2, _b2, _c2;
    const extractCountFor = (target) => {
      const {
        cover_left_text_1,
        cover_left_text_2,
        cover_left_text_3
      } = item;
      const arr = [cover_left_text_1, cover_left_text_2, cover_left_text_3].filter(Boolean);
      if (target === "play") {
        const text = arr.find((text2) => /观看|播放$/.test(text2));
        if (!text) return;
        const rest = text.replace(/观看|播放$/, "");
        return parseCount(rest);
      }
      if (target === "danmaku") {
        const text = arr.find((text2) => text2.endsWith("弹幕"));
        if (!text) return;
        const rest = text.replace(/弹幕$/, "");
        return parseCount(rest);
      }
      if (target === "bangumi:follow") {
        const text = arr.find((text2) => /追[剧番]$/.test(text2));
        if (!text) return;
        const rest = text.replace(/追[剧番]$/, "");
        return parseCount(rest);
      }
    };
    const avid = item.param;
    const bvid = item.bvid || BvCode.av2bv(Number(item.param));
    const cid = (_a2 = item.player_args) == null ? void 0 : _a2.cid;
    const href = (() => {
      var _a3;
      if (item.uri.startsWith("http://") || item.uri.startsWith("https://")) {
        return item.uri;
      }
      if (item.goto === "av") {
        return `/video/${bvid}/`;
      }
      if (item.goto === "bangumi") {
        appWarn(`bangumi uri should not starts with 'bilibili://': %s`, item.uri);
        return item.uri;
      }
      if (item.goto === "picture") {
        const id = (_a3 = /^bilibili:\/\/article\/(\d+)$/.exec(item.uri)) == null ? void 0 : _a3[1];
        if (id) return `/read/cv${id}`;
        return item.uri;
      }
      return item.uri;
    })();
    const play = extractCountFor("play");
    const like = void 0;
    const coin = void 0;
    const danmaku = extractCountFor("danmaku");
    const favorite = void 0;
    const bangumiFollow = extractCountFor("bangumi:follow");
    const statItems = [{
      field: "play",
      value: play
    }, typeof danmaku === "number" ? {
      field: "danmaku",
      value: danmaku
    } : {
      field: "bangumi:follow",
      value: bangumiFollow
    }];
    const desc = item.desc || "";
    const [descAuthorName = void 0, descDate = void 0] = desc.split(DESC_SEPARATOR);
    return {
      // video
      avid,
      bvid,
      cid,
      goto: item.goto,
      href,
      title: item.title,
      cover: item.cover,
      pubts: void 0,
      pubdateDisplay: descDate,
      duration: ((_b2 = item.player_args) == null ? void 0 : _b2.duration) || 0,
      durationStr: formatDuration((_c2 = item.player_args) == null ? void 0 : _c2.duration),
      recommendReason: item.bottom_rcmd_reason || item.top_rcmd_reason,
      // TODO: top_rcmd_reason
      // stat
      play,
      like,
      coin,
      danmaku,
      favorite,
      bangumiFollow,
      statItems,
      // author
      authorName: item.args.up_name || descAuthorName,
      authorFace: item.avatar.cover,
      authorMid: String(item.args.up_id || ""),
      appBadge: item.cover_badge,
      appBadgeDesc: item.desc
    };
  }
  function apiPcAdapter(item) {
    var _a2, _b2, _c2, _d2, _e2, _f, _g, _h, _i, _j, _k;
    item.goto === PcRecGoto.AV;
    const _isLive = item.goto === PcRecGoto.Live;
    return {
      // video
      avid: _isLive ? void 0 : String(item.id),
      bvid: _isLive ? void 0 : item.bvid,
      cid: _isLive ? void 0 : item.cid,
      goto: item.goto,
      href: item.goto === "av" ? `/video/${item.bvid}/` : item.uri,
      title: item.title,
      cover: item.pic,
      pubts: item.pubdate,
      pubdateDisplay: formatTimeStamp(item.pubdate),
      duration: item.duration,
      durationStr: formatDuration(item.duration),
      recommendReason: _isLive ? (_a2 = item.room_info) == null ? void 0 : _a2.area.area_name : (_b2 = item.rcmd_reason) == null ? void 0 : _b2.content,
      // stat
      play: (_c2 = item.stat) == null ? void 0 : _c2.view,
      like: (_d2 = item.stat) == null ? void 0 : _d2.like,
      coin: void 0,
      danmaku: (_e2 = item.stat) == null ? void 0 : _e2.danmaku,
      favorite: void 0,
      statItems: _isLive ? defineStatItems([{
        field: "live:viewed-by",
        value: (_f = item.room_info) == null ? void 0 : _f.watched_show.num
      }]) : defineStatItems([{
        field: "play",
        value: (_g = item.stat) == null ? void 0 : _g.view
      }, {
        field: "danmaku",
        value: (_h = item.stat) == null ? void 0 : _h.danmaku
      }]),
      // author
      authorName: (_i = item.owner) == null ? void 0 : _i.name,
      authorFace: (_j = item.owner) == null ? void 0 : _j.face,
      authorMid: String((_k = item.owner) == null ? void 0 : _k.mid)
    };
  }
  function apiDynamicAdapter(item) {
    const v = item.modules.module_dynamic.major.archive;
    const author = item.modules.module_author;
    const gateTs = dayjs().subtract(2, "days").unix();
    const pubdateDisplay = (() => {
      const ts = author.pub_ts;
      if (ts > gateTs) {
        return author.pub_time;
      } else {
        return formatTimeStamp(ts);
      }
    })();
    return {
      // video
      avid: v.aid,
      bvid: v.bvid,
      // cid: v.
      goto: "av",
      href: `/video/${v.bvid}/`,
      title: v.title,
      cover: v.cover,
      pubts: author.pub_ts,
      pubdateDisplay,
      duration: parseDuration(v.duration_text) || 0,
      durationStr: v.duration_text,
      recommendReason: v.badge.text,
      // stat
      statItems: defineStatItems([{
        field: "play",
        value: v.stat.play
      }, {
        field: "danmaku",
        value: v.stat.danmaku
      }]),
      play: parseCount(v.stat.play),
      danmaku: parseCount(v.stat.danmaku),
      // author
      authorName: author.name,
      authorFace: author.face,
      authorMid: author.mid.toString()
    };
  }
  function apiWatchlaterAdapter(item) {
    const invalidReason = getVideoInvalidReason(item.state);
    const viewed = item.progress > 0;
    const title = `${viewed ? "【已观看】· " : ""}${item.title}`;
    const titleRender = invalidReason ? /* @__PURE__ */ jsx$1(AntdTooltip, { title: /* @__PURE__ */ jsxs(Fragment, { children: [
      "视频已失效, 原因: ",
      invalidReason
    ] }), align: {
      offset: [0, -5]
    }, placement: "topLeft", children: /* @__PURE__ */ jsxs("del", { children: [
      viewed ? "【已观看】· " : "",
      item.title,
      "`"
    ] }) }) : void 0;
    return {
      // video
      avid: String(item.aid),
      bvid: item.bvid,
      cid: item.cid,
      goto: "av",
      href: `https://www.bilibili.com/list/watchlater?bvid=${item.bvid}&oid=${item.aid}`,
      title,
      titleRender,
      cover: item.pic,
      pubts: item.pubdate,
      pubdateDisplay: formatTimeStamp(item.pubdate),
      pubdateDisplayForTitleAttr: `${formatTimeStamp(item.pubdate, true)} 发布, ${formatTimeStamp(item.add_at, true)} 添加稍后再看`,
      duration: item.duration,
      durationStr: formatDuration(item.duration),
      recommendReason: `${formatTimeStamp(item.add_at)} · 稍后再看`,
      // stat
      statItems: defineStatItems([
        {
          field: "play",
          value: item.stat.view
        },
        {
          field: "like",
          value: item.stat.like
        },
        // { field: 'coin', value: item.stat.coin },
        {
          field: "favorite",
          value: item.stat.favorite
        }
      ]),
      play: item.stat.view,
      like: item.stat.like,
      danmaku: item.stat.danmaku,
      // author
      authorName: item.owner.name,
      authorFace: item.owner.face,
      authorMid: String(item.owner.mid)
    };
  }
  const fillWithColorPrimary = styled.createClass`
  & path {
    fill: ${colorPrimaryValue};
  }
`;
  function apiFavAdapter(item) {
    const belongsToTitle = item.from === "fav-folder" ? item.folder.title : item.collection.title;
    const iconInTitleStyle = {
      display: "inline-block",
      verticalAlign: "middle",
      marginRight: 4,
      marginTop: -2
    };
    const iconInTitle = item.from === "fav-folder" ? isFavFolderPrivate(item.folder.attr) ? /* @__PURE__ */ jsx$1(IconForPrivateFolder, { className: clsx("size-15px", fillWithColorPrimary), style: iconInTitleStyle }) : /* @__PURE__ */ jsx$1(IconForPublicFolder, { className: clsx("size-15px", fillWithColorPrimary), style: iconInTitleStyle }) : /* @__PURE__ */ jsx$1(IconForCollection, { className: clsx("size-15px", fillWithColorPrimary), style: iconInTitleStyle });
    return {
      // video
      avid: String(item.id),
      bvid: item.bvid,
      // cid: item.
      goto: "av",
      href: `/video/${item.bvid}/`,
      title: `【${belongsToTitle}】· ${item.title}`,
      titleRender: /* @__PURE__ */ jsxs(Fragment, { children: [
        "【",
        iconInTitle,
        belongsToTitle,
        "】· ",
        item.title
      ] }),
      cover: item.cover,
      pubts: item.pubtime,
      pubdateDisplay: formatTimeStamp(item.pubtime),
      duration: item.duration,
      durationStr: formatDuration(item.duration),
      recommendReason: item.from === "fav-folder" ? `${formatTimeStamp(item.fav_time)} · 收藏` : void 0,
      // stat
      play: item.cnt_info.play,
      danmaku: item.cnt_info.danmaku,
      favorite: item.cnt_info.collect,
      statItems: defineStatItems([{
        field: "play",
        value: item.cnt_info.play
      }, {
        field: "danmaku",
        value: item.cnt_info.danmaku
      }, {
        field: "favorite",
        value: item.cnt_info.collect
      }]),
      // author
      authorName: item.upper.name,
      authorFace: item.upper.face,
      authorMid: String(item.upper.mid)
    };
  }
  function apiPopularGeneralAdapter(item) {
    var _a2;
    return {
      // video
      avid: String(item.aid),
      bvid: item.bvid,
      cid: item.cid,
      goto: "av",
      href: `/video/${item.bvid}/`,
      title: item.title,
      cover: item.pic,
      pubts: item.pubdate,
      pubdateDisplay: formatTimeStamp(item.pubdate),
      duration: item.duration,
      durationStr: formatDuration(item.duration),
      recommendReason: (_a2 = item.rcmd_reason) == null ? void 0 : _a2.content,
      // stat
      play: item.stat.view,
      like: item.stat.like,
      coin: void 0,
      danmaku: item.stat.danmaku,
      favorite: void 0,
      statItems: defineStatItems([
        {
          field: "play",
          value: item.stat.view
        },
        {
          field: "like",
          value: item.stat.like
        }
        // { field: 'danmaku', value: item.stat.danmaku },
      ]),
      // author
      authorName: item.owner.name,
      authorFace: item.owner.face,
      authorMid: String(item.owner.mid)
    };
  }
  function apiPopularWeeklyAdapter(item) {
    return {
      // video
      avid: String(item.aid),
      bvid: item.bvid,
      cid: item.cid,
      goto: "av",
      href: `/video/${item.bvid}/`,
      title: item.title,
      cover: item.pic,
      pubts: item.pubdate,
      pubdateDisplay: formatTimeStamp(item.pubdate),
      duration: item.duration,
      durationStr: formatDuration(item.duration),
      recommendReason: item.rcmd_reason,
      // stat
      play: item.stat.view,
      like: item.stat.like,
      danmaku: item.stat.danmaku,
      statItems: defineStatItems([
        {
          field: "play",
          value: item.stat.view
        },
        {
          field: "like",
          value: item.stat.like
        }
        // { field: 'danmaku', value: item.stat.danmaku },
      ]),
      // author
      authorName: item.owner.name,
      authorFace: item.owner.face,
      authorMid: String(item.owner.mid)
    };
  }
  function apiRankAdapter(item) {
    if (isPgcWebRankItem(item) || isPgcSeasonRankItem(item)) {
      const cover = item.new_ep.cover;
      const rankingDesc = item.new_ep.index_show;
      return {
        // video
        avid: "",
        bvid: "",
        goto: "bangumi",
        href: item.url,
        title: item.title,
        cover,
        pubts: void 0,
        pubdateDisplay: void 0,
        duration: 0,
        durationStr: "",
        // stat
        play: item.stat.view,
        like: item.stat.follow,
        danmaku: item.stat.danmaku,
        statItems: defineStatItems([
          {
            field: "play",
            value: item.stat.view
          },
          {
            field: "bangumi:follow",
            value: item.stat.follow
          }
          // { field: 'danmaku', value: item.stat.danmaku },
        ]),
        rankingDesc
      };
    }
    return {
      // video
      avid: String(item.aid),
      bvid: item.bvid,
      cid: item.cid,
      goto: "av",
      href: `/video/${item.bvid}/`,
      title: item.title,
      cover: item.pic,
      pubts: item.pubdate,
      pubdateDisplay: formatTimeStamp(item.pubdate),
      duration: item.duration,
      durationStr: formatDuration(item.duration),
      recommendReason: void 0,
      // TODO: write something here
      // stat
      play: item.stat.view,
      like: item.stat.like,
      danmaku: item.stat.danmaku,
      statItems: defineStatItems([
        {
          field: "play",
          value: item.stat.view
        },
        {
          field: "like",
          value: item.stat.like
        }
        // { field: 'danmaku', value: item.stat.danmaku },
      ]),
      // author
      authorName: item.owner.name,
      authorFace: item.owner.face,
      authorMid: String(item.owner.mid)
    };
  }
  function apiLiveAdapter(item) {
    const area = `${item.area_name_v2}`;
    const liveExtraDesc = item.live_status === ELiveStatus.Streaming ? "" : `${DESC_SEPARATOR}${formatLiveTime(item.record_live_time)} 直播过`;
    function formatLiveTime(ts) {
      const today = dayjs().format("YYYYMMDD");
      const yesterday = dayjs().subtract(1, "day").format("YYYYMMDD");
      const d2 = dayjs.unix(ts);
      if (d2.format("YYYYMMDD") === today) {
        return d2.format("HH:mm");
      }
      if (d2.format("YYYYMMDD") === yesterday) {
        return `昨天 ${d2.format("HH:mm")}`;
      }
      return d2.format("MM-DD HH:mm");
    }
    return {
      // video
      goto: "live",
      href: `https://live.bilibili.com/${item.roomid}`,
      title: item.title,
      cover: item.room_cover,
      recommendReason: area,
      liveExtraDesc,
      // stat
      statItems: defineStatItems([{
        field: "live:viewed-by",
        value: item.text_small
      }]),
      // author
      authorName: item.uname,
      authorFace: item.face,
      authorMid: String(item.uid)
    };
  }
  function apiSpaceUploadAdapter(item) {
    const duration2 = parseDuration(item.length);
    const durationStr = formatDuration(duration2);
    return {
      // video
      avid: item.aid.toString(),
      bvid: item.bvid,
      cid: void 0,
      goto: "av",
      href: `/video/${item.bvid}/`,
      title: item.title,
      cover: item.pic,
      pubts: item.created,
      pubdateDisplay: formatRecentTimeStamp(item.created, false),
      duration: duration2,
      durationStr,
      recommendReason: item.description || void 0,
      // stat
      play: item.play,
      like: void 0,
      coin: void 0,
      danmaku: item.video_review,
      favorite: void 0,
      statItems: defineStatItems([{
        field: "play",
        value: item.play
      }, {
        field: "danmaku",
        value: item.video_review
      }]),
      // author
      authorName: item.author,
      authorFace: spaceUploadAvatarCache.get(item.mid.toString()),
      authorMid: item.mid.toString()
    };
  }
  const debug$9 = baseDebug.extend("VideoCard:filter");
  function getFollowedStatus$1(recommendReason) {
    return !!recommendReason && ["已关注", "新关注"].includes(recommendReason);
  }
  function anyFilterEnabled(tab2) {
    if (tab2 === ETab.KeepFollowOnly) {
      return true;
    }
    const mayNeedCheck_blacklist_filterByUp_filterByTitle = [ETab.AppRecommend, ETab.PcRecommend, ETab.Hot].includes(tab2);
    if (mayNeedCheck_blacklist_filterByUp_filterByTitle) {
      if (blacklistMids.size || settings.filter.enabled && (settings.filter.byAuthor.enabled && !!settings.filter.byAuthor.keywords.length || settings.filter.byTitle.enabled && !!settings.filter.byTitle.keywords.length)) {
        return true;
      }
    }
    if (tab2 === ETab.AppRecommend || tab2 === ETab.PcRecommend) {
      if (settings.filter.enabled) {
        return true;
      }
    }
    return false;
  }
  function isApiRecLike(api) {
    return [EApiType.AppRecommend, EApiType.PcRecommend, EApiType.Rank, EApiType.PopularGeneral, EApiType.PopularWeekly].includes(api);
  }
  function filterRecItems(items, tab2) {
    if (!anyFilterEnabled(tab2)) {
      return items;
    }
    const filter = getSettingsSnapshot().filter;
    const {
      minDuration,
      minPlayCount,
      minDanmakuCount,
      byAuthor,
      byTitle
    } = filter;
    const blockUpMids = /* @__PURE__ */ new Set();
    const blockUpNames = /* @__PURE__ */ new Set();
    const regMidWithRemark = /^(?<mid>\d+)\([\S ]+\)$/;
    const regMid = /^\d+$/;
    byAuthor.keywords.forEach((x) => {
      var _a2, _b2;
      if (regMidWithRemark.test(x)) {
        const mid = (_b2 = (_a2 = regMidWithRemark.exec(x)) == null ? void 0 : _a2.groups) == null ? void 0 : _b2.mid;
        if (mid) blockUpMids.add(mid);
      } else if (regMid.test(x)) {
        blockUpMids.add(x);
      } else {
        blockUpNames.add(x);
      }
    });
    const titleRegexList = [];
    const titleKeywordList = [];
    byTitle.keywords.forEach((keyword) => {
      if (keyword.startsWith("/") && keyword.endsWith("/")) {
        const regex = new RegExp(keyword.slice(1, -1), "i");
        titleRegexList.push(regex);
      } else {
        titleKeywordList.push(keyword);
      }
    });
    return items.filter((item) => {
      if (item.api === EApiType.Separator) return true;
      const {
        play,
        duration: duration2,
        danmaku,
        recommendReason,
        goto,
        authorName,
        authorMid,
        title,
        bvid,
        href
      } = normalizeCardData(item);
      const followed = getFollowedStatus$1(recommendReason);
      if (tab2 === "keep-follow-only") {
        if (!followed) return false;
      }
      function check_blacklist_filterByUp_filterByTitle() {
        if (authorMid && blacklistMids.size) {
          if (blacklistMids.has(authorMid)) {
            debug$9("filter out by blacklist-rule: %s %o", authorMid, {
              bvid,
              title
            });
            return false;
          }
        }
        if (filter.enabled && byAuthor.enabled && (blockUpMids.size || blockUpNames.size) && (authorName || authorMid)) {
          if (authorName && blockUpNames.has(authorName) || authorMid && blockUpMids.has(authorMid)) {
            debug$9("filter out by author-rule: %o", {
              authorName,
              authorMid,
              rules: byAuthor.keywords,
              blockUpMids,
              blockUpNames,
              bvid,
              title
            });
            return false;
          }
        }
        let possibleTitles = [title];
        if (item.api === EApiType.Rank && isNormalRankItem(item) && item.desc) {
          possibleTitles.push(item.desc);
        }
        possibleTitles = possibleTitles.filter(Boolean);
        if (filter.enabled && byTitle.enabled && byTitle.keywords.length && possibleTitles.length) {
          const titleHit = (title2) => titleKeywordList.some((keyword) => title2.includes(keyword)) || titleRegexList.some((regex) => regex.test(title2));
          if (possibleTitles.some(titleHit)) {
            debug$9("filter out by title-rule: %o", {
              possibleTitles,
              rules: byTitle.keywords,
              bvid
            });
            return false;
          }
        }
      }
      if (isApiRecLike(item.api)) {
        if (check_blacklist_filterByUp_filterByTitle() === false) {
          return false;
        }
      }
      if (item.api === EApiType.AppRecommend || item.api === EApiType.PcRecommend) {
        if (filter.enabled) {
          const isVideo = goto === "av";
          const isPicture = goto === "picture";
          const isBangumi = goto === "bangumi";
          if (isVideo) return filterVideo();
          if (isPicture) return filterPicture();
          if (isBangumi) return filterBangumi();
        }
      }
      function filterVideo() {
        if (followed && filter.exemptForFollowed.video) return true;
        if (recommendReason === "关注了你") {
          debug$9("filter out by recommendReason-rule: %s %o", recommendReason, {
            bvid,
            title
          });
          return false;
        }
        if (minDuration.enabled && minDuration.value && duration2 && duration2 < minDuration.value) {
          debug$9("filter out by min-duration-rule: %s < %s %o", duration2, minDuration.value, {
            bvid,
            title
          });
          return false;
        }
        if (minPlayCount.enabled && minPlayCount.value && typeof play === "number" && play < minPlayCount.value) {
          debug$9("filter out by min-play-count-rule: %s < %s, %o", play, minPlayCount.value, {
            bvid,
            title
          });
          return false;
        }
        if (minDanmakuCount.enabled && minDanmakuCount.value && typeof danmaku === "number" && danmaku < minDanmakuCount.value) {
          debug$9("filter out by min-danmaku-count-rule: %s < %s, %o", danmaku, minDanmakuCount.value, {
            bvid,
            title
          });
          return false;
        }
        return true;
      }
      function filterPicture() {
        if (filter.hideGotoTypePicture) {
          if (followed && filter.exemptForFollowed.picture) {
            return true;
          }
          debug$9("filter out by goto-type-picture-rule: %s %o", goto, {
            bvid,
            title
          });
          return false;
        } else {
          return true;
        }
      }
      function filterBangumi() {
        if (filter.hideGotoTypeBangumi) {
          debug$9("filter out by goto-type-bangumi-rule: %s %o", goto, {
            title,
            href
          });
          return false;
        }
        return true;
      }
      return true;
    });
  }
  const phCrownFill = (props, ref) => /* @__PURE__ */ jsx$1("svg", { viewBox: "0 0 256 256", width: "1.2em", height: "1.2em", ref, ...props, children: /* @__PURE__ */ jsx$1("path", { fill: "currentColor", d: "M248 80a28 28 0 1 0-51.12 15.77l-26.79 33L146 73.4a28 28 0 1 0-36.06 0l-24.03 55.34l-26.79-33a28 28 0 1 0-26.6 12L47 194.63A16 16 0 0 0 62.78 208h130.44A16 16 0 0 0 209 194.63l14.47-86.85A28 28 0 0 0 248 80M128 40a12 12 0 1 1-12 12a12 12 0 0 1 12-12M24 80a12 12 0 1 1 12 12a12 12 0 0 1-12-12m196 12a12 12 0 1 1 12-12a12 12 0 0 1-12 12" }) });
  const ForwardRef$m = H.forwardRef(phCrownFill);
  const iconParkOutlineMore = (props, ref) => /* @__PURE__ */ jsxs("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref, ...props, children: [
    /* @__PURE__ */ jsx$1("circle", { cx: 12, cy: 24, r: 3, fill: "currentColor" }),
    /* @__PURE__ */ jsx$1("circle", { cx: 24, cy: 24, r: 3, fill: "currentColor" }),
    /* @__PURE__ */ jsx$1("circle", { cx: 36, cy: 24, r: 3, fill: "currentColor" })
  ] });
  const ForwardRef$l = H.forwardRef(iconParkOutlineMore);
  const CHARGE_ONLY_TEXT = "充电专属";
  function isChargeOnlyVideo(item, recommendReason) {
    var _a2, _b2, _c2, _d2, _e2;
    if (item.api !== EApiType.DynamicFeed) return false;
    recommendReason || (recommendReason = (_e2 = (_d2 = (_c2 = (_b2 = (_a2 = item.modules) == null ? void 0 : _a2.module_dynamic) == null ? void 0 : _b2.major) == null ? void 0 : _c2.archive) == null ? void 0 : _d2.badge) == null ? void 0 : _e2.text);
    return recommendReason === CHARGE_ONLY_TEXT;
  }
  function ChargeOnlyTag() {
    return /* @__PURE__ */ jsxs("div", { className: clsx("rounded-2px ml-4px", "flex-center py-1px pl-4px pr-6px", "bg-gate-primary color-white text-center text-size-10px line-height-[17px] whitespace-nowrap"), children: [
      /* @__PURE__ */ jsx$1("svg", { width: "16", height: "17", viewBox: "0 0 16 17", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: /* @__PURE__ */ jsx$1("path", { d: "M5.00014 14.9839C4.94522 15.1219 5.12392 15.2322 5.22268 15.1212L11.5561 8.00214C11.7084 7.83093 11.5869 7.56014 11.3578 7.56014H9.13662L11.6019 3.57178C11.7112 3.39489 11.584 3.16666 11.376 3.16666H7.4475C7.22576 3.16666 7.02737 3.30444 6.94992 3.51221L4.68362 9.59189C4.61894 9.76539 4.74725 9.95014 4.93241 9.95014H7.00268L5.00014 14.9839Z", fill: "white" }) }),
      CHARGE_ONLY_TEXT
    ] });
  }
  function getColor(no) {
    const medalColors = ["#FFD700", "#C0C0C0", "#B36700"];
    return medalColors[no - 1] ?? colorPrimaryValue;
  }
  function RankNumMark({
    item
  }) {
    var _a2;
    const hasMedal = item.rankingNo <= 3;
    const medalIcon = /* @__PURE__ */ jsx$1(ForwardRef$m, {});
    let hasOthers = false;
    let others = [];
    if (isNormalRankItem(item) && ((_a2 = item.others) == null ? void 0 : _a2.length)) {
      hasOthers = true;
      others = item.others;
    }
    const tooltip = `「${item.rankTab.name}」排行第 ${item.rankingNo} 名`;
    const {
      triggerRef,
      tooltipEl
    } = useTooltip({
      inlinePosition: "left",
      tooltip,
      tooltipOffset: 2
    });
    const roundButtonClassName = "flex-center size-28px rounded-full color-white relative whitespace-nowrap";
    const roundButtonStyle = H.useMemo(() => ({
      backgroundColor: getColor(item.rankingNo)
    }), [item.rankingNo]);
    const newTab = useLinkNewTab();
    return /* @__PURE__ */ jsxs(Fragment, { children: [
      /* @__PURE__ */ jsxs("div", { ref: triggerRef, className: roundButtonClassName, style: roundButtonStyle, children: [
        hasMedal ? medalIcon : /* @__PURE__ */ jsx$1("span", { style: {
          marginLeft: -1
        }, children: item.rankingNo }),
        tooltipEl
      ] }),
      hasOthers && /* @__PURE__ */ jsx$1(antd.Dropdown, { placement: "bottomLeft", menu: {
        items: [{
          type: "group",
          label: "「其他上榜视频」",
          children: others.map((x) => {
            return {
              key: x.bvid,
              label: x.title,
              onClick() {
                const href = new URL(`/video/${x.bvid}`, location.href).href;
                if (newTab) {
                  openNewTab(href);
                } else {
                  location.href = href;
                }
              }
            };
          })
        }]
      }, children: /* @__PURE__ */ jsx$1("div", { className: roundButtonClassName, style: roundButtonStyle, children: /* @__PURE__ */ jsx$1(ForwardRef$l, {}) }) })
    ] });
  }
  function SomeBadge({
    icon,
    label,
    className
  }) {
    return /* @__PURE__ */ jsxs("span", { className: clsx("h-16px line-height-16px rounded-8px pl-4px pr-6px bg-gate-primary inline-flex items-center justify-center", className), children: [
      icon,
      label && typeof label === "string" ? /* @__PURE__ */ jsx$1(Fragment, { children: /* @__PURE__ */ jsx$1("span", { className: "font-normal font-size-11px line-height-[1] color-white relative top-1px", children: label }) }) : label
    ] });
  }
  function LiveBadge({
    className
  }) {
    return /* @__PURE__ */ jsx$1(SomeBadge, { className, icon: /* @__PURE__ */ jsx$1(IconForLive, { active: true, className: "size-14px" }), label: "直播中" });
  }
  function ApiTypeTag({
    item
  }) {
    const text = (() => {
      if (isDynamicFeed(item)) return "动态";
      if (isWatchlater(item)) return "稍后再看";
      if (isFav(item)) return item.from === "fav-folder" ? "收藏夹" : "合集";
      return item.api;
    })();
    return /* @__PURE__ */ jsx$1("div", { className: "rounded-2px ml-4px bg-gate-primary flex-center px-6px py-1px text-size-11px line-height-[17px] text-white text-center whitespace-nowrap", children: text });
  }
  function VolMark({
    vol
  }) {
    return /* @__PURE__ */ jsx$1("div", { className: "h-24px min-w-24px rounded-8px relative flex-center bg-gate-primary color-white whitespace-nowrap px-6px", children: vol });
  }
  async function getLiveList(page) {
    const res = await request.get("https://api.live.bilibili.com/xlive/web-ucenter/user/following", {
      params: {
        page,
        page_size: LiveRecService.PAGE_SIZE,
        ignoreRecord: 1,
        hit_ab: true
      }
    });
    const json = res.data;
    return json;
  }
  const _LiveRecService = class _LiveRecService extends BaseTabService {
    constructor(streamingOnly = false) {
      super(_LiveRecService.PAGE_SIZE);
      __publicField(this, "usageInfo");
      __publicField(this, "hasMoreExceptQueue", true);
      __publicField(this, "separatorAdded", false);
      __publicField(this, "liveCount", -1);
      __publicField(this, "page", 1);
      __publicField(this, "totalPage", Infinity);
      this.streamingOnly = streamingOnly;
    }
    async fetchMore(abortSignal) {
      if (this.page > this.totalPage) {
        this.hasMoreExceptQueue = false;
        return;
      }
      const json = await getLiveList(this.page);
      if (!isWebApiSuccess(json)) {
        toast(json.message || REQUEST_FAIL_MSG);
        this.hasMoreExceptQueue = false;
      }
      this.page++;
      const {
        count,
        live_count,
        totalPage
      } = json.data;
      this.totalPage = totalPage;
      this.liveCount = live_count;
      const items = json.data.list.map((item) => {
        const _item = {
          ...item,
          api: EApiType.Live,
          uniqId: `${EApiType.Live}-${item.roomid}`
        };
        return _item;
      });
      const last = items.at(-1);
      const gateTime = dayjs().subtract(2, "weeks").unix();
      if (last) {
        const lastStatus = last.live_status;
        const lastLiveTime = last.record_live_time;
        if (lastStatus !== ELiveStatus.Streaming && lastLiveTime && lastLiveTime < gateTime) {
          this.hasMoreExceptQueue = false;
        }
      }
      let ret = items;
      if (!this.streamingOnly && !this.separatorAdded && items.some((x) => x.live_status !== ELiveStatus.Streaming)) {
        this.separatorAdded = true;
        const index = items.findIndex((x) => x.live_status !== ELiveStatus.Streaming);
        ret.splice(index, 0, {
          api: EApiType.Separator,
          uniqId: "live-separator-recent",
          content: "最近直播过"
        });
      }
      if (this.streamingOnly && items.some((x) => x.live_status !== ELiveStatus.Streaming)) {
        this.hasMoreExceptQueue = false;
        ret = items.filter((x) => x.live_status === ELiveStatus.Streaming);
      }
      return ret;
    }
  };
  __publicField(_LiveRecService, "PAGE_SIZE", 20);
  let LiveRecService = _LiveRecService;
  async function fetchVideoDynamicFeeds({
    offset,
    page,
    upMid,
    abortSignal
  }) {
    var _a2;
    const params = {
      "timezone_offset": "-480",
      "type": "video",
      "platform": "web",
      "features": "itemOpusStyle",
      "web_location": "0.0",
      "x-bili-device-req-json": JSON.stringify({
        platform: "web",
        device: "pc"
      }),
      "x-bili-web-req-json": JSON.stringify({
        spm_id: "0.0"
      }),
      "page": page
    };
    if (offset) {
      params.offset = offset;
    }
    const apiPath = "/x/polymer/web-dynamic/v1/feed/all";
    if (upMid) {
      params.host_mid = upMid;
    }
    const res = await request.get(apiPath, {
      signal: abortSignal,
      params
    });
    const json = res.data;
    if (!isWebApiSuccess(json)) {
      const msg = json.message || REQUEST_FAIL_MSG;
      toast(msg);
      throw new Error(msg, {
        cause: json
      });
    }
    const data2 = json.data;
    if ((_a2 = data2 == null ? void 0 : data2.items) == null ? void 0 : _a2.length) {
      data2.items = data2.items.filter((x) => x.type === "DYNAMIC_TYPE_AV");
    }
    return data2;
  }
  const cache = getIdbCache("dynamic-feed-items");
  const infoCache = getIdbCache("dynamic-feed-items-info");
  async function hasLocalDynamicFeedCache(upMid) {
    const existing = await infoCache.get(upMid);
    return !!(existing == null ? void 0 : existing.count);
  }
  function createUpdateSearchCacheNotifyFns(upMid, upName) {
    const notiKey = (mid) => `update-search-cache-${mid}`;
    const _onProgress = (page, total) => {
      antNotification.info({
        icon: /* @__PURE__ */ jsx$1(ForwardRef$P, { className: "size-16px" }),
        key: notiKey(upMid),
        message: `搜索缓存更新中...`,
        description: `「${upName}」更新中: Page(${page}) Total(${total})`,
        duration: null
        // do not auto close
      });
    };
    const onProgress = throttle$1(_onProgress, 200);
    const onSuccess = () => {
      onProgress.flush();
      antNotification.success({
        key: notiKey(upMid),
        message: `缓存更新成功`,
        description: `「${upName}」的搜索缓存更新成功`,
        duration: null
        // do not auto close
      });
    };
    return {
      notifyOnProgress: onProgress,
      notifyOnSuccess: onSuccess
    };
  }
  async function updateLocalDynamicFeedCache(upMid, onProgress) {
    if (await hasLocalDynamicFeedCache(upMid)) {
      await performIncrementalUpdate(upMid);
    } else {
      await performFullUpdate(upMid, void 0, onProgress);
    }
  }
  async function performIncrementalUpdateIfNeed(upMid, force = false) {
    const info = await infoCache.get(upMid);
    if (!force && info && info.count && info.updatedAt && Date.now() - info.updatedAt < 60 * 1e3) {
      return;
    }
    return performIncrementalUpdate(upMid);
  }
  async function performIncrementalUpdate(upMid) {
    if (!await hasLocalDynamicFeedCache(upMid)) return;
    const existing = await cache.get(upMid) || [];
    const existingIds = new Set(existing.map((x) => x.id_str));
    let page = 1;
    let offset = "";
    let hasMore = true;
    let newItems = [];
    while (hasMore) {
      const data2 = await fetchVideoDynamicFeeds({
        upMid,
        page,
        offset
      });
      const items = data2.items;
      newItems = [...newItems, ...items];
      offset = data2.offset;
      hasMore = data2.has_more;
      page++;
      if (hasMore && existingIds.size) {
        const allIncluded = items.every((item) => existingIds.has(item.id_str));
        if (allIncluded) {
          hasMore = false;
        }
      }
    }
    const allItems = uniqBy([...newItems, ...existing], (x) => x.id_str);
    await cache.set(upMid, allItems);
    await infoCache.set(upMid, {
      count: allItems.length,
      updatedAt: Date.now()
    });
  }
  const fullUpdateInProgressCache = getIdbCache("dynamic-feed-items-in-progress");
  async function performFullUpdate(upMid, skipCache = false, onProgress) {
    const inProgressCached = skipCache ? void 0 : await fullUpdateInProgressCache.get(upMid);
    let page = (inProgressCached == null ? void 0 : inProgressCached.page) ?? 1;
    let offset = (inProgressCached == null ? void 0 : inProgressCached.offset) ?? "";
    let allItems = (inProgressCached == null ? void 0 : inProgressCached.items) ?? [];
    let hasMore = true;
    while (hasMore) {
      const data2 = await fetchVideoDynamicFeeds({
        upMid,
        page,
        offset
      });
      const items = data2.items;
      allItems = [...allItems, ...items];
      offset = data2.offset;
      hasMore = data2.has_more;
      page++;
      await fullUpdateInProgressCache.set(upMid, {
        page,
        offset,
        items: allItems
      });
      onProgress == null ? void 0 : onProgress(page, allItems.length);
    }
    const _allItems = uniqBy(allItems, (x) => x.id_str);
    await cache.set(upMid, _allItems);
    await infoCache.set(upMid, {
      count: _allItems.length,
      updatedAt: Date.now()
    });
    await fullUpdateInProgressCache.delete(upMid);
  }
  const fetchVideoDynamicFeedsWithCache = wrapWithIdbCache({
    fn: fetchVideoDynamicFeeds,
    generateKey: ({
      upMid
    }) => `${upMid}`,
    tableName: "dynamic-feed-newest-items",
    // only head
    ttl: 5 * 60 * 1e3
    // 5 minutes
  });
  class FollowGroupUpService {
    constructor(upMid, enableHeadCache = false) {
      __publicField(this, "bufferQueue", []);
      __publicField(this, "hasMoreForApi", true);
      __publicField(this, "offset", "");
      __publicField(this, "page", 1);
      this.upMid = upMid;
      this.enableHeadCache = enableHeadCache;
    }
    // current page
    get hasMore() {
      return !!this.bufferQueue.length || this.hasMoreForApi;
    }
    async loadMore() {
      const enableCache = this.page === 1 && !this.offset && this.enableHeadCache;
      const fn = enableCache ? fetchVideoDynamicFeedsWithCache : fetchVideoDynamicFeeds;
      const data2 = await fn({
        upMid: this.upMid,
        page: this.page,
        offset: this.offset
      });
      this.offset = data2.offset;
      this.hasMoreForApi = data2.has_more;
      this.page++;
      return data2.items;
    }
    async fillQueue(minimalQueueSize, abortSignal) {
      while (!(abortSignal == null ? void 0 : abortSignal.aborted) && this.hasMoreForApi && this.bufferQueue.length < minimalQueueSize) {
        const items = await this.loadMore();
        this.bufferQueue.push(...items);
      }
    }
  }
  const _FollowGroupMergeTimelineService = class _FollowGroupMergeTimelineService {
    constructor(upMids) {
      __publicField(this, "upServices", []);
      this.upMids = upMids;
      const enableHeadCache = upMids.length > _FollowGroupMergeTimelineService.ENABLE_HEAD_CACHE_UPMID_COUNT_THRESHOLD;
      this.upServices = upMids.map((upMid) => new FollowGroupUpService(upMid, enableHeadCache));
    }
    get hasMore() {
      return this.upServices.some((s2) => s2.hasMore);
    }
    async loadMore(abortSignal) {
      if (!this.hasMore) return [];
      const refillQueues = async () => {
        const minimalQueueSize = 1;
        await pmap(this.upServices, (s2) => s2.fillQueue(minimalQueueSize, abortSignal), 5);
      };
      const pickedItems = [];
      const expectSize = 10;
      while (this.hasMore && pickedItems.length < expectSize) {
        await refillQueues();
        const restServices = this.upServices.filter((s2) => s2.hasMore);
        const pickedService = orderBy(restServices.map((service) => {
          const item = service.bufferQueue[0];
          const id = BigInt(item.id_str);
          return {
            service,
            item,
            id
          };
        }), ["id"], ["desc"]).map((x) => x.service)[0];
        if (!pickedService) break;
        const head = pickedService.bufferQueue[0];
        pickedService.bufferQueue = pickedService.bufferQueue.slice(1);
        pickedItems.push(head);
      }
      return pickedItems;
    }
  };
  // fillQueues 会对每一个 upMid 请求, 多了不适合
  __publicField(_FollowGroupMergeTimelineService, "ENABLE_MERGE_TIMELINE_UPMID_COUNT_THRESHOLD", 20);
  // if upMids > 10, enable head cache
  __publicField(_FollowGroupMergeTimelineService, "ENABLE_HEAD_CACHE_UPMID_COUNT_THRESHOLD", 10);
  let FollowGroupMergeTimelineService = _FollowGroupMergeTimelineService;
  function usePopoverRelated({
    externalSearchInput,
    onRefresh,
    getPopupContainer
  }) {
    const {
      upMid,
      dynamicFeedVideoType,
      filterMinDuration,
      searchText,
      hideChargeOnlyVideos
    } = useSnapshot(dfStore);
    const searchInput = /* @__PURE__ */ jsx$1(
      antd.Input.Search,
      {
        style: {
          width: externalSearchInput ? "250px" : void 0
        },
        placeholder: "按标题关键字过滤",
        type: "search",
        autoCorrect: "off",
        autoCapitalize: "off",
        name: `searchText_${upMid}`,
        variant: "outlined",
        defaultValue: dfStore.searchText,
        autoComplete: "off",
        allowClear: true,
        onChange: (e2) => {
          tryInstantSearchWithCache({
            searchText: e2.target.value,
            upMid,
            onRefresh
          });
        },
        onSearch: async (val) => {
          dfStore.searchText = val || void 0;
          await delay(100);
          onRefresh == null ? void 0 : onRefresh();
        }
      }
    );
    const popoverContent = /* @__PURE__ */ jsx$1(PopoverContent, { externalSearchInput, searchInput, onRefresh });
    const [popoverOpen, setPopoverOpen] = H.useState(
      false
      // dev: change to true for debug if needed);
    );
    const onPopoverOpenChange = setPopoverOpen;
    const showPopoverBadge = H.useMemo(() => {
      return !!(dynamicFeedVideoType !== DynamicFeedVideoType.All || hideChargeOnlyVideos || searchText || filterMinDuration !== DynamicFeedVideoMinDuration.All);
    }, [dynamicFeedVideoType, hideChargeOnlyVideos, searchText, filterMinDuration]);
    const popoverTrigger = /* @__PURE__ */ jsx$1(antd.Popover, { open: popoverOpen, onOpenChange: onPopoverOpenChange, arrow: false, placement: "bottomLeft", getPopupContainer, content: popoverContent, styles: {
      body: {
        border: `1px solid ${usePopoverBorderColor()}`
      }
    }, children: /* @__PURE__ */ jsx$1(antd.Badge, { dot: showPopoverBadge, color: colorPrimaryValue, offset: [-5, 5], children: /* @__PURE__ */ jsx$1(antd.Button, { className: "icon-only-round-button", css: popoverOpen && buttonOpenCss, children: /* @__PURE__ */ jsx$1(IconForPopoverTrigger, { className: "ml-1px" }) }) }) });
    return {
      searchInput,
      popoverContent,
      popoverTrigger
    };
  }
  const classes = {
    wrapper: "max-w-350px",
    section: "mt-10px first:mt-0px min-w-300px",
    sectionTilte: "flex items-center text-20px pl-2px pb-2px",
    sectionContent: "flex flex-col items-start gap-x-10px gap-y-6px"
  };
  var _ref$c = {
    name: "1kbjhvc",
    styles: "overflow:hidden;.ant-radio-button-wrapper{padding-inline:10px;}"
  };
  function PopoverContent({
    externalSearchInput,
    searchInput,
    onRefresh
  }) {
    const {
      viewingSomeUp,
      selectedGroup,
      viewingSomeGroup,
      selectedKey,
      dynamicFeedVideoType,
      filterMinDuration,
      hideChargeOnlyVideos,
      addSeparators,
      searchText
    } = useSnapshot(dfStore);
    let linkToReflectSearchTextEl;
    {
      const show = SHOW_DYNAMIC_FEED_ONLY && !!searchText;
      const disabled = searchText === QUERY_DYNAMIC_SEARCH_TEXT;
      const {
        href,
        path: path2
      } = H.useMemo(() => {
        const u2 = new URL(location.href);
        if (u2.searchParams.has(DynamicFeedQueryKey.SearchTextFull)) {
          u2.searchParams.set(DynamicFeedQueryKey.SearchTextFull, searchText || "");
        } else if (u2.searchParams.has(DynamicFeedQueryKey.SearchTextShort)) {
          u2.searchParams.set(DynamicFeedQueryKey.SearchTextShort, searchText || "");
        } else {
          u2.searchParams.set(DynamicFeedQueryKey.SearchTextFull, searchText || "");
        }
        return {
          href: u2.href,
          path: `${u2.pathname}?${u2.search}`
        };
      }, [searchText]);
      linkToReflectSearchTextEl = show && /* @__PURE__ */ jsx$1(AntdTooltip, { title: href, children: /* @__PURE__ */ jsxs(antd.Button, { disabled, href, children: [
        "转到搜索词为「",
        searchText || "空",
        "」的链接"
      ] }) });
    }
    return /* @__PURE__ */ jsxs("div", { className: classes.wrapper, children: [
      /* @__PURE__ */ jsxs("div", { className: classes.section, children: [
        /* @__PURE__ */ jsxs("div", { className: classes.sectionTilte, children: [
          "视频类型",
          /* @__PURE__ */ jsxs(HelpInfo, { children: [
            "「",
            CHARGE_ONLY_TEXT,
            "」在此程序中归类为「投稿视频」",
            /* @__PURE__ */ jsx$1("br", {}),
            "「动态视频」时长通常较短"
          ] })
        ] }),
        /* @__PURE__ */ jsx$1("div", { children: /* @__PURE__ */ jsx$1(antd.Radio.Group, { buttonStyle: "solid", value: dynamicFeedVideoType, onChange: async (v) => {
          dfStore.dynamicFeedVideoType = v.target.value;
          await delay(100);
          onRefresh == null ? void 0 : onRefresh();
        }, children: Object.values(DynamicFeedVideoType).map((v) => {
          return /* @__PURE__ */ jsx$1(antd.Radio.Button, { value: v, children: DynamicFeedVideoTypeLabel[v] }, v);
        }) }) })
      ] }),
      dynamicFeedVideoType !== DynamicFeedVideoType.DynamicOnly && /* @__PURE__ */ jsxs("div", { className: classes.section, children: [
        /* @__PURE__ */ jsx$1("div", { className: classes.sectionTilte, children: "充电专属" }),
        /* @__PURE__ */ jsx$1("div", { className: classes.sectionContent, children: /* @__PURE__ */ jsx$1(antd.Checkbox, { className: "ml-5px", checked: hideChargeOnlyVideos, onChange: async (e2) => {
          const val = e2.target.checked;
          const set2 = dfStore.hideChargeOnlyVideosForKeysSet;
          if (val) {
            set2.add(selectedKey);
          } else {
            set2.delete(selectedKey);
          }
          await delay(100);
          onRefresh == null ? void 0 : onRefresh();
        }, children: /* @__PURE__ */ jsx$1(AntdTooltip, { title: /* @__PURE__ */ jsxs(Fragment, { children: [
          "隐藏「",
          CHARGE_ONLY_TEXT,
          "」视频 ",
          /* @__PURE__ */ jsx$1("br", {}),
          "仅对当前 UP 或 分组生效"
        ] }), children: /* @__PURE__ */ jsxs("span", { style: {
          userSelect: "none"
        }, children: [
          "隐藏「",
          CHARGE_ONLY_TEXT,
          "」"
        ] }) }) }) })
      ] }),
      /* @__PURE__ */ jsxs("div", { className: classes.section, children: [
        /* @__PURE__ */ jsx$1("div", { className: classes.sectionTilte, children: "最短时长" }),
        /* @__PURE__ */ jsx$1("div", { children: /* @__PURE__ */ jsx$1(antd.Radio.Group, { css: _ref$c, buttonStyle: "solid", value: filterMinDuration, onChange: async (v) => {
          dfStore.filterMinDuration = v.target.value;
          await delay(100);
          onRefresh == null ? void 0 : onRefresh();
        }, children: Object.values(DynamicFeedVideoMinDuration).map((k) => {
          const {
            label
          } = DynamicFeedVideoMinDurationConfig[k];
          return /* @__PURE__ */ jsx$1(antd.Radio.Button, { value: k, children: label }, k);
        }) }) })
      ] }),
      (!externalSearchInput || linkToReflectSearchTextEl) && /* @__PURE__ */ jsxs("div", { className: classes.section, children: [
        /* @__PURE__ */ jsx$1("div", { className: classes.sectionTilte, children: "搜索" }),
        /* @__PURE__ */ jsxs("div", { className: classes.sectionContent, children: [
          !externalSearchInput && searchInput,
          linkToReflectSearchTextEl
        ] })
      ] }),
      /* @__PURE__ */ jsx$1(SearchCacheRelated, {}),
      /* @__PURE__ */ jsxs("div", { className: classes.section, children: [
        /* @__PURE__ */ jsxs("div", { className: classes.sectionTilte, children: [
          viewingSomeGroup ? "分组" : viewingSomeUp ? "UP" : "全部",
          /* @__PURE__ */ jsxs(HelpInfo, { children: [
            "当前",
            viewingSomeGroup ? "分组" : viewingSomeUp ? "UP" : "范围",
            "的一些操作~"
          ] }),
          viewingSomeGroup && selectedGroup && /* @__PURE__ */ jsxs("span", { className: "inline-flex items-center ml-15px text-size-14px", children: [
            "(",
            /* @__PURE__ */ jsxs("a", { href: formatFollowGroupUrl((selectedGroup == null ? void 0 : selectedGroup.tagid) || ""), target: "_blank", className: `inline-flex items-center text-size-16px mx-4px ${APP_CLS_USE_ANT_LINK_COLOR}`, children: [
              /* @__PURE__ */ jsx$1(IconForOpenExternalLink, { className: "size-18px mr-2px" }),
              selectedGroup == null ? void 0 : selectedGroup.name
            ] }),
            ")"
          ] })
        ] }),
        /* @__PURE__ */ jsxs("div", { className: classes.sectionContent, children: [
          /* @__PURE__ */ jsx$1(antd.Checkbox, { checked: addSeparators, onChange: async (v) => {
            dfStore.addSeparatorsMap.set("global", v.target.checked);
            await delay(100);
            onRefresh == null ? void 0 : onRefresh();
          }, children: /* @__PURE__ */ jsx$1(AntdTooltip, { title: "添加今日/更早分割线", children: "添加分割线" }) }),
          viewingSomeGroup && !!selectedGroup && /* @__PURE__ */ jsx$1(FollowGroupActions, { followGroup: selectedGroup, onRefresh })
        ] })
      ] })
    ] });
  }
  function SearchCacheRelated() {
    const {
      cacheAllItemsEntry,
      cacheAllItemsUpMids
    } = useSettingsSnapshot().dynamicFeed.__internal;
    const {
      viewingSomeUp,
      upMid,
      upName
    } = useSnapshot(dfStore);
    const $req = useRequest(async (upMid2, upName2) => {
      const {
        notifyOnProgress,
        notifyOnSuccess
      } = createUpdateSearchCacheNotifyFns(upMid2, upName2);
      await updateLocalDynamicFeedCache(upMid2, notifyOnProgress);
      notifyOnSuccess();
    }, {
      manual: true
    });
    const checked = H.useMemo(() => !!upMid && cacheAllItemsUpMids.includes(upMid.toString()), [upMid, cacheAllItemsUpMids]);
    const onChange = H.useCallback(async (e2) => {
      if (!upMid) return;
      const val = e2.target.checked;
      const args = val ? {
        add: [upMid]
      } : {
        remove: [upMid]
      };
      await updateSettingsInnerArray("dynamicFeed.__internal.cacheAllItemsUpMids", args);
    }, []);
    return /* @__PURE__ */ jsx$1(Fragment, { children: cacheAllItemsEntry && viewingSomeUp && upMid && upName && /* @__PURE__ */ jsxs("div", { className: classes.section, children: [
      /* @__PURE__ */ jsxs("div", { className: classes.sectionTilte, children: [
        "搜索缓存",
        /* @__PURE__ */ jsxs(HelpInfo, { children: [
          "开启搜索缓存后, 会加载并缓存 UP 所有的动态 ",
          /* @__PURE__ */ jsx$1("br", {}),
          "当本地有缓存且总条数 <= 5000时, 搜索框成为及时搜索, 无需点击搜索按钮"
        ] })
      ] }),
      /* @__PURE__ */ jsxs("div", { className: classes.sectionContent, children: [
        /* @__PURE__ */ jsxs("div", { className: "flex flex-wrap items-center gap-x-10px gap-y-3px", children: [
          /* @__PURE__ */ jsx$1(antd.Checkbox, { className: "inline-flex items-center", checked, onChange, children: /* @__PURE__ */ jsx$1(AntdTooltip, { title: "只有开启此项, 搜索时才会使用缓存", children: /* @__PURE__ */ jsxs("span", { children: [
            "为「",
            upName,
            "」开启"
          ] }) }) }),
          /* @__PURE__ */ jsx$1(antd.Button, { loading: $req.loading, onClick: async () => {
            await $req.runAsync(upMid, upName);
          }, children: "更新缓存" })
        ] }),
        /* @__PURE__ */ jsx$1(CheckboxSettingItem, { configPath: "dynamicFeed.advancedSearch", label: "使用高级搜索", tooltip: advancedSearchHelpInfo })
      ] })
    ] }) });
  }
  const tryInstantSearchWithCache = throttle$1(async function({
    searchText,
    upMid,
    onRefresh
  }) {
    if (!upMid) return;
    if (!(searchText || !searchText && dfStore.searchText)) return;
    if (!settings.dynamicFeed.__internal.cacheAllItemsEntry) return;
    if (!settings.dynamicFeed.__internal.cacheAllItemsUpMids.includes(upMid.toString())) return;
    if (!await hasLocalDynamicFeedCache(upMid)) return;
    const info = await infoCache.get(upMid);
    if (!info || !info.count) return;
    if (info.count >= 5e3) return;
    dfStore.searchText = searchText;
    await delay(0);
    onRefresh == null ? void 0 : onRefresh();
  }, 100);
  function FollowGroupMechanismNote() {
    return /* @__PURE__ */ jsxs(Fragment, { children: [
      /* @__PURE__ */ jsx$1("p", { children: "机制介绍:" }),
      /* @__PURE__ */ jsxs("ul", { children: [
        /* @__PURE__ */ jsxs("li", { className: "flex items-start gap-x-10px", children: [
          /* @__PURE__ */ jsx$1("div", { children: "「从全部过滤」:" }),
          /* @__PURE__ */ jsx$1("div", { children: '基于全部动态 + 分组UP过滤, 速度可能巨慢, 且过滤后的数量取决于B站记录的"全部"动态范围' })
        ] }),
        /* @__PURE__ */ jsxs("li", { className: "flex items-start gap-x-10px", children: [
          /* @__PURE__ */ jsx$1("div", { children: "「拼接时间线」:" }),
          /* @__PURE__ */ jsxs("div", { children: [
            "可以理解为: 去看一遍分组所有 UP 的动态, 然后将它们拼接起来 ",
            /* @__PURE__ */ jsx$1("br", {}),
            "启动慢, 但可以加载所有动态; 且分组 UP 越多, 启动越慢 ",
            /* @__PURE__ */ jsx$1("br", {}),
            "默认分组 UP 数量不超过 ",
            FollowGroupMergeTimelineService.ENABLE_MERGE_TIMELINE_UPMID_COUNT_THRESHOLD,
            " ",
            "时会使用「拼接时间线」 ",
            /* @__PURE__ */ jsx$1("br", {}),
            "详见",
            /* @__PURE__ */ jsx$1("a", { className: "mx-5px", href: "https://magicdawn.fun/2024/12/01/bilibili-gate-dynamic-feed-merge-timeline/", target: "_blank", children: "介绍博客" })
          ] })
        ] })
      ] })
    ] });
  }
  function FollowGroupActions({
    followGroup,
    onRefresh
  }) {
    const {
      whenViewAll
    } = useSnapshot(settings.dynamicFeed);
    const midCount = followGroup.count;
    let forceMergeTimelineCheckbox;
    const forceMergeTimelineHandle = useValueInSettingsCollection(followGroup.tagid, "dynamicFeed.followGroup.forceUseMergeTimelineIds");
    {
      const {
        checked,
        onChange
      } = forceMergeTimelineHandle;
      const disabled = midCount <= FollowGroupMergeTimelineService.ENABLE_MERGE_TIMELINE_UPMID_COUNT_THRESHOLD;
      forceMergeTimelineCheckbox = /* @__PURE__ */ jsx$1(antd.Checkbox, { checked, onChange: (e2) => {
        onChange(e2);
        onRefresh == null ? void 0 : onRefresh();
      }, disabled, children: /* @__PURE__ */ jsx$1(AntdTooltip, { title: /* @__PURE__ */ jsxs(Fragment, { children: [
        /* @__PURE__ */ jsx$1(FollowGroupMechanismNote, {}),
        disabled && /* @__PURE__ */ jsxs("p", { css: /* @__PURE__ */ css("color:oklch(from ", colorPrimaryValue, " calc(1 - l) calc(c + 0.1) h);font-style:italic;", ""), children: [
          "当前分组 UP 数量: ",
          midCount,
          ", 无需设置"
        ] })
      ] }), children: "分组动态: 强制使用「拼接时间线」" }) });
    }
    let clearMergeTimelineHeadCacheButton;
    {
      const usingMergeTimeline = midCount <= FollowGroupMergeTimelineService.ENABLE_MERGE_TIMELINE_UPMID_COUNT_THRESHOLD || forceMergeTimelineHandle.checked;
      const usingMergeTimelineHeadCache = usingMergeTimeline && midCount > FollowGroupMergeTimelineService.ENABLE_HEAD_CACHE_UPMID_COUNT_THRESHOLD;
      clearMergeTimelineHeadCacheButton = usingMergeTimelineHeadCache && /* @__PURE__ */ jsx$1(AntdTooltip, { title: /* @__PURE__ */ jsxs(Fragment, { children: [
        "当分组 UP 数量",
        " >  ",
        FollowGroupMergeTimelineService.ENABLE_HEAD_CACHE_UPMID_COUNT_THRESHOLD,
        "时, 「拼接时间线」功能会缓存每个 UP 的最新动态5分钟. ",
        /* @__PURE__ */ jsx$1("br", {}),
        "这里可以手动清除缓存"
      ] }), children: /* @__PURE__ */ jsx$1(antd.Button, { onClick: () => {
        fetchVideoDynamicFeedsWithCache.cache.db.clear();
        antMessage.success("已清除缓存");
      }, children: "清除「拼接时间线」- 队头缓存" }) });
    }
    let addTo_dynamicFeedWhenViewAllHideIds_checkbox;
    {
      const {
        checked,
        onChange
      } = useValueInSettingsCollection(`${DF_SELECTED_KEY_PREFIX_GROUP}${followGroup.tagid}`, "dynamicFeed.whenViewAll.hideIds");
      addTo_dynamicFeedWhenViewAllHideIds_checkbox = whenViewAll.enableHideSomeContents && /* @__PURE__ */ jsx$1(antd.Checkbox, { checked, onChange, children: /* @__PURE__ */ jsx$1(AntdTooltip, { title: /* @__PURE__ */ jsxs(Fragment, { children: [
        "在「全部」动态中隐藏来自此 ",
        followGroup.name,
        " 的动态"
      ] }), children: "在「全部」动态中隐藏来自此分组的动态" }) });
    }
    return /* @__PURE__ */ jsxs(Fragment, { children: [
      addTo_dynamicFeedWhenViewAllHideIds_checkbox,
      forceMergeTimelineCheckbox,
      clearMergeTimelineHeadCacheButton
    ] });
  }
  function useValueInSettingsCollection(value, listSettingsPath) {
    const list2 = useSettingsInnerArray(listSettingsPath);
    const checked = H.useMemo(() => list2.includes(value), [list2]);
    const setChecked = useMemoizedFn(async (checked2) => {
      const arg = checked2 ? {
        add: [value]
      } : {
        remove: [value]
      };
      await updateSettingsInnerArray(listSettingsPath, arg);
    });
    const onChange = H.useCallback((e2) => {
      setChecked(e2.target.checked);
    }, []);
    return {
      checked,
      setChecked,
      onChange
    };
  }
  function dynamicFeedFilterSelectUp(payload) {
    Object.assign(dfStore, payload);
    if (payload.upMid) {
      const item = dfStore.upList.find((x) => x.mid.toString() === payload.upMid);
      if (item) item.has_update = false;
    }
  }
  const clearPayload = {
    upMid: void 0,
    upName: void 0,
    upFace: void 0,
    searchText: void 0,
    selectedGroupId: void 0,
    dynamicFeedVideoType: DynamicFeedVideoType.All,
    filterMinDuration: DynamicFeedVideoMinDuration.All
  };
  function DynamicFeedUsageInfo() {
    const {
      ref,
      getPopupContainer
    } = usePopupContainer();
    const onRefresh = useOnRefreshContext();
    const dfSettings = useSettingsSnapshot().dynamicFeed;
    const {
      externalSearchInput
    } = dfSettings.__internal;
    const {
      viewingSomeUp,
      upName,
      upFace,
      upList,
      groups,
      selectedGroup,
      selectedKey
    } = useSnapshot(dfStore);
    useMount(() => {
      updateFilterData();
    });
    const onSelect = useMemoizedFn(async (payload) => {
      dynamicFeedFilterSelectUp(payload);
      await delay(100);
      onRefresh == null ? void 0 : onRefresh();
    });
    const onClear = useMemoizedFn(() => {
      onSelect({
        ...clearPayload
      });
    });
    const menuItems = H.useMemo(() => {
      const itemAll = {
        key: "all",
        icon: /* @__PURE__ */ jsx$1(antd.Avatar, { size: "small", children: "全" }),
        label: "全部",
        onClick: onClear
      };
      let groupItems = [];
      if (dfSettings.followGroup.enabled) {
        groupItems = groups.map((group) => {
          return {
            key: `group:${group.tagid}`,
            label: group.name + ` (${group.count})`,
            icon: /* @__PURE__ */ jsx$1(antd.Avatar, { size: "small", children: "组" }),
            onClick() {
              onSelect({
                ...clearPayload,
                selectedGroupId: group.tagid
              });
            }
          };
        });
      }
      const upListSorted = fastSortWithOrders(upList, [{
        prop: (item) => item.has_update ? 1 : 0,
        order: "desc"
      }, {
        prop: (item) => mapNameForSort(item.uname),
        order: localeComparer
      }]);
      const items = upListSorted.map((up) => {
        let avatar = /* @__PURE__ */ jsx$1(antd.Avatar, { size: "small", src: getAvatarSrc(up.face) });
        if (up.has_update) {
          avatar = /* @__PURE__ */ jsx$1(antd.Badge, { dot: true, children: avatar });
        }
        return {
          key: `up:${up.mid}`,
          icon: avatar,
          // label: up.uname,
          label: /* @__PURE__ */ jsx$1("span", { title: up.uname, className: "block max-w-130px text-ellipsis whitespace-nowrap overflow-hidden", children: up.uname }),
          onClick() {
            onSelect({
              ...clearPayload,
              upMid: up.mid.toString(),
              upName: up.uname,
              upFace: up.face
            });
          }
        };
      });
      return [itemAll, ...groupItems, ...items];
    }, [upList, dfSettings.followGroup.enabled, groups]);
    const followGroupMidsCount = selectedGroup == null ? void 0 : selectedGroup.count;
    const upIcon = /* @__PURE__ */ jsx$1(IconForUp, { className: "size-14px mt--2px" });
    const upAvtar = upFace ? /* @__PURE__ */ jsx$1(antd.Avatar, { size: 20, src: getAvatarSrc(upFace) }) : void 0;
    const dropdownButtonIcon = viewingSomeUp ? upAvtar || upIcon : selectedGroup ? /* @__PURE__ */ jsx$1(IconForGroup, { className: "size-18px" }) : void 0;
    const dropdownButtonLabel = viewingSomeUp ? upName : selectedGroup ? selectedGroup.name + (followGroupMidsCount ? ` (${followGroupMidsCount})` : "") : "全部";
    const [scopeDropdownOpen, setScopeDropdownOpen] = H.useState(false);
    const scopeDropdownMenu = /* @__PURE__ */ jsx$1(antd.Dropdown, { open: scopeDropdownOpen, onOpenChange: setScopeDropdownOpen, placement: "bottomLeft", getPopupContainer, menu: {
      items: menuItems,
      style: {
        ...dropdownMenuStyle,
        border: `1px solid ${usePopoverBorderColor()}`
      },
      selectedKeys: [selectedKey]
    }, children: /* @__PURE__ */ jsx$1(antd.Button, { icon: dropdownButtonIcon, className: "gap-4px", css: [scopeDropdownOpen && buttonOpenCss, "", ""], children: dropdownButtonLabel }) });
    const {
      popoverTrigger,
      searchInput
    } = usePopoverRelated({
      externalSearchInput,
      onRefresh,
      getPopupContainer
    });
    return /* @__PURE__ */ jsx$1(Fragment, { children: /* @__PURE__ */ jsxs("div", { ref, className: "inline-flex items-center gap-x-8px", children: [
      scopeDropdownMenu,
      (viewingSomeUp || selectedGroup) && /* @__PURE__ */ jsxs(antd.Button, { onClick: onClear, className: "gap-0", children: [
        /* @__PURE__ */ jsx$1(IconForReset, { className: "size-14px mr-5px" }),
        /* @__PURE__ */ jsx$1("span", { children: "清除" })
      ] }),
      popoverTrigger,
      externalSearchInput && searchInput,
      /* @__PURE__ */ jsx$1(CopyBvidButtonsUsageInfo, {})
    ] }) });
  }
  function getDynamicFeedServiceConfig(usingDfStore = dfStore) {
    var _a2;
    const snap = snapshot(usingDfStore);
    return {
      /**
       * from dfStore
       */
      // UP | 分组
      upMid: snap.upMid,
      groupId: (_a2 = snap.selectedGroup) == null ? void 0 : _a2.tagid,
      // 搜索
      searchText: snap.searchText,
      // 类型
      dynamicFeedVideoType: snap.dynamicFeedVideoType,
      hideChargeOnlyVideos: snap.hideChargeOnlyVideos,
      // 时长
      filterMinDuration: snap.filterMinDuration,
      filterMinDurationValue: snap.filterMinDurationValue,
      // flags
      selectedKey: snap.selectedKey,
      viewingAll: snap.viewingAll,
      viewingSomeUp: snap.viewingSomeUp,
      viewingSomeGroup: snap.viewingSomeGroup,
      addSeparators: snap.addSeparators,
      /**
       * from settings
       */
      showLiveInDynamicFeed: settings.dynamicFeed.showLive,
      whenViewAllEnableHideSomeContents: settings.dynamicFeed.whenViewAll.enableHideSomeContents,
      whenViewAllHideIds: new Set(settings.dynamicFeed.whenViewAll.hideIds),
      advancedSearch: settings.dynamicFeed.advancedSearch,
      searchCacheEnabled: !!snap.upMid && settings.dynamicFeed.__internal.cacheAllItemsEntry && // the main switch
      settings.dynamicFeed.__internal.cacheAllItemsUpMids.includes(snap.upMid.toString()),
      // the switch for this up
      forceUseMergeTime: !!snap.selectedGroup && settings.dynamicFeed.followGroup.forceUseMergeTimelineIds.includes(snap.selectedGroup.tagid),
      /**
       * from query
       */
      startingOffset: QUERY_DYNAMIC_OFFSET,
      minId: isValidNumber(QUERY_DYNAMIC_MIN_ID) ? BigInt(QUERY_DYNAMIC_MIN_ID) : void 0,
      minTs: isValidNumber(QUERY_DYNAMIC_MIN_TS) ? Number(QUERY_DYNAMIC_MIN_TS) : void 0
    };
  }
  function isValidNumber(str) {
    return !!str && /^\d+$/.test(str);
  }
  const debug$8 = baseDebug.extend("modules:rec-services:dynamic-feed");
  const _DynamicFeedRecService = class _DynamicFeedRecService extends BaseTabService {
    constructor(config) {
      super(_DynamicFeedRecService.PAGE_SIZE);
      __publicField(this, "usageInfo", /* @__PURE__ */ jsx$1(DynamicFeedUsageInfo, {}));
      __publicField(this, "hasMoreExceptQueue", true);
      __publicField(this, "offset", "");
      __publicField(this, "page", 0);
      // pages loaded
      __publicField(this, "liveRecService");
      __publicField(this, "groupMergeTimelineService");
      __publicField(this, "groupMids", /* @__PURE__ */ new Set());
      __publicField(this, "groupMidsLoaded", false);
      __publicField(this, "whenViewAllHideMids", /* @__PURE__ */ new Set());
      __publicField(this, "whenViewAllHideMidsLoaded", false);
      __publicField(this, "_queueForSearchCache");
      __publicField(this, "separatorsConfig", (() => {
        return {
          today: {
            added: false,
            content: "今日",
            getInsertIndex: getTodaySeparatorInsertIndex
          },
          earlier: {
            added: false,
            content: "更早",
            getInsertIndex: insertIndexFinderViaPubTsRange(-Infinity, dayjs().startOf("day").unix())
          }
        };
      })());
      this.config = config;
      if (this.config.showLiveInDynamicFeed) {
        const filterEmpty = !this.upMid && typeof this.groupId === "undefined" && !this.searchText && this.dynamicFeedVideoType === DynamicFeedVideoType.All && this.filterMinDuration === DynamicFeedVideoMinDuration.All;
        if (filterEmpty) {
          this.liveRecService = new LiveRecService(true);
        }
      }
      if (this.config.startingOffset) {
        this.offset = this.config.startingOffset;
      }
    }
    get hasMore() {
      var _a2;
      if (this.qs.bufferQueue.length) return true;
      if ((_a2 = this.liveRecService) == null ? void 0 : _a2.hasMore) return true;
      if (this.viewingSomeGroup && this.groupMergeTimelineService) {
        return this.groupMergeTimelineService.hasMore;
      }
      if (this.hasMoreExceptQueue) return true;
      return false;
    }
    async shouldReduceMinCount() {
      if (this.viewingAll) ;
      if (this.viewingSomeGroup) {
        await this.loadGroupMids();
        return !this.groupMergeTimelineService;
      }
      if (this.searchText || this.dynamicFeedVideoType === DynamicFeedVideoType.DynamicOnly || this.filterMinDuration !== DynamicFeedVideoMinDuration.All) {
        return true;
      }
      return false;
    }
    /**
     * shortcuts for ServiceConfig(this.config)
     */
    get upMid() {
      return this.config.upMid;
    }
    // NOTE: number | undefined 默认分组是 0
    get groupId() {
      return this.config.groupId;
    }
    get searchText() {
      return this.config.searchText;
    }
    get dynamicFeedVideoType() {
      return this.config.dynamicFeedVideoType;
    }
    get hideChargeOnlyVideos() {
      return this.config.hideChargeOnlyVideos;
    }
    get filterMinDuration() {
      return this.config.filterMinDuration;
    }
    get filterMinDurationValue() {
      return this.config.filterMinDurationValue;
    }
    get viewingSomeUp() {
      return this.config.viewingSomeUp;
    }
    /**
     * 查看分组
     */
    get viewingSomeGroup() {
      return this.config.viewingSomeGroup;
    }
    shouldEnableMergeTimeline(midCount) {
      return this.config.forceUseMergeTime || midCount > 0 && midCount <= FollowGroupMergeTimelineService.ENABLE_MERGE_TIMELINE_UPMID_COUNT_THRESHOLD;
    }
    async loadGroupMids() {
      if (typeof this.groupId !== "number") return;
      if (this.groupMidsLoaded) return;
      try {
        const mids2 = await getFollowGroupContent(this.groupId);
        this.groupMids = new Set(mids2);
        if (this.shouldEnableMergeTimeline(mids2.length)) {
          this.groupMergeTimelineService = new FollowGroupMergeTimelineService(mids2.map((x) => x.toString()));
        }
      } finally {
        this.groupMidsLoaded = true;
      }
    }
    /**
     * 查看全部
     */
    get viewingAll() {
      return this.config.viewingAll;
    }
    async loadWhenViewAllHideMids() {
      if (!this.viewingAll) return;
      if (!this.config.whenViewAllEnableHideSomeContents) return;
      if (!this.config.whenViewAllHideIds.size) return;
      if (this.whenViewAllHideMidsLoaded) return;
      const mids2 = Array.from(this.config.whenViewAllHideIds).filter((x) => x.startsWith(DF_SELECTED_KEY_PREFIX_UP)).map((x) => x.slice(DF_SELECTED_KEY_PREFIX_UP.length));
      const groupIds = Array.from(this.config.whenViewAllHideIds).filter((x) => x.startsWith(DF_SELECTED_KEY_PREFIX_GROUP)).map((x) => x.slice(DF_SELECTED_KEY_PREFIX_GROUP.length));
      const set2 = this.whenViewAllHideMids;
      mids2.forEach((x) => set2.add(x));
      const midsInGroup = (await pmap(groupIds, async (id) => getFollowGroupContent(id), 3)).flat();
      midsInGroup.forEach((x) => set2.add(x.toString()));
      this.whenViewAllHideMidsLoaded = true;
    }
    async fetchMore(abortSignal) {
      const items = await this._fetchMore(abortSignal);
      return this.handleAddSeparators(items);
    }
    async _fetchMore(abortSignal) {
      var _a2;
      if ((_a2 = this.liveRecService) == null ? void 0 : _a2.hasMore) {
        const items2 = await this.liveRecService.loadMore(abortSignal) || [];
        return items2.filter((x) => x.api !== EApiType.Separator);
      }
      let rawItems;
      if (this.viewingSomeGroup) {
        await this.loadGroupMids();
      }
      if (this.viewingAll) {
        await this.loadWhenViewAllHideMids();
        debug$8("viewingAll: hide-mids = %o", this.whenViewAllHideMids);
      }
      const useSearchCache = !!(this.upMid && this.searchText && this.config.searchCacheEnabled && await hasLocalDynamicFeedCache(this.upMid));
      const useAdvancedSearch = useSearchCache && this.config.advancedSearch;
      const useAdvancedSearchParsed = useAdvancedSearch ? parseSearchInput((this.searchText || "").toLowerCase()) : void 0;
      if (useSearchCache) {
        if (!this._queueForSearchCache) {
          await performIncrementalUpdateIfNeed(this.upMid);
          this._queueForSearchCache = new QueueStrategy(20);
          this._queueForSearchCache.bufferQueue = (await cache.get(this.upMid) || []).filter((x) => {
            var _a3, _b2, _c2, _d2;
            const title = ((_d2 = (_c2 = (_b2 = (_a3 = x == null ? void 0 : x.modules) == null ? void 0 : _a3.module_dynamic) == null ? void 0 : _b2.major) == null ? void 0 : _c2.archive) == null ? void 0 : _d2.title) || "";
            return filterBySearchText({
              searchText: this.searchText,
              title,
              useAdvancedSearch,
              useAdvancedSearchParsed
            });
          });
        }
        rawItems = this._queueForSearchCache.sliceFromQueue(this.page + 1) || [];
        this.page++;
        this.hasMoreExceptQueue = !!this._queueForSearchCache.bufferQueue.length;
      } else if (this.viewingSomeGroup && this.groupMergeTimelineService) {
        rawItems = await this.groupMergeTimelineService.loadMore(abortSignal);
      } else {
        const data2 = await fetchVideoDynamicFeeds({
          abortSignal,
          page: this.page + 1,
          // ++this.page, starts from 1, 实测 page 没啥用, 分页基于 offset
          offset: this.offset,
          upMid: this.upMid
        });
        this.page++;
        this.hasMoreExceptQueue = data2.has_more;
        this.offset = data2.offset;
        rawItems = data2.items;
        if (this.config.minId) {
          const minId = this.config.minId;
          const idx = rawItems.findIndex((x) => BigInt(x.id_str) <= minId);
          if (idx !== -1) {
            this.hasMoreExceptQueue = false;
            rawItems = rawItems.slice(0, idx + 1);
          }
        }
        if (this.config.minTs) {
          const minTs = this.config.minTs;
          const idx = rawItems.findIndex((x) => x.modules.module_author.pub_ts <= minTs);
          if (idx !== -1) {
            this.hasMoreExceptQueue = false;
            rawItems = rawItems.slice(0, idx + 1);
          }
        }
      }
      const items = rawItems.filter((x) => {
        var _a3, _b2;
        if (!this.viewingSomeGroup) return true;
        if (!this.groupMids.size) return true;
        const mid = (_b2 = (_a3 = x == null ? void 0 : x.modules) == null ? void 0 : _a3.module_author) == null ? void 0 : _b2.mid;
        if (!mid) return true;
        return this.groupMids.has(mid);
      }).filter((x) => {
        if (this.dynamicFeedVideoType === DynamicFeedVideoType.All) return true;
        const currentLabel = x.modules.module_dynamic.major.archive.badge.text;
        if (this.dynamicFeedVideoType === DynamicFeedVideoType.DynamicOnly) {
          return currentLabel === "动态视频";
        }
        if (this.dynamicFeedVideoType === DynamicFeedVideoType.UploadOnly) {
          return currentLabel === "投稿视频" || currentLabel === CHARGE_ONLY_TEXT;
        }
        return false;
      }).filter((x) => {
        var _a3, _b2, _c2, _d2, _e2;
        if (!this.hideChargeOnlyVideos) return true;
        const chargeOnly = ((_e2 = (_d2 = (_c2 = (_b2 = (_a3 = x.modules) == null ? void 0 : _a3.module_dynamic) == null ? void 0 : _b2.major) == null ? void 0 : _c2.archive) == null ? void 0 : _d2.badge) == null ? void 0 : _e2.text) === CHARGE_ONLY_TEXT;
        return !chargeOnly;
      }).filter((x) => {
        if (this.filterMinDuration === DynamicFeedVideoMinDuration.All) return true;
        const v = x.modules.module_dynamic.major.archive;
        const duration2 = parseDuration(v.duration_text);
        return duration2 >= this.filterMinDurationValue;
      }).filter((x) => {
        var _a3, _b2, _c2, _d2;
        if (!this.searchText) return true;
        const title = ((_d2 = (_c2 = (_b2 = (_a3 = x == null ? void 0 : x.modules) == null ? void 0 : _a3.module_dynamic) == null ? void 0 : _b2.major) == null ? void 0 : _c2.archive) == null ? void 0 : _d2.title) || "";
        return filterBySearchText({
          searchText: this.searchText,
          title,
          useAdvancedSearch,
          useAdvancedSearchParsed
        });
      }).filter((x) => {
        var _a3, _b2;
        if (this.config.selectedKey !== DF_SELECTED_KEY_ALL) return true;
        const set2 = this.whenViewAllHideMids;
        if (!set2.size) return true;
        const mid = (_b2 = (_a3 = x == null ? void 0 : x.modules) == null ? void 0 : _a3.module_author) == null ? void 0 : _b2.mid;
        if (!mid) return true;
        return !set2.has(mid.toString());
      }).map((item) => {
        return {
          ...item,
          api: EApiType.DynamicFeed,
          uniqId: `${EApiType.DynamicFeed}-${item.id_str || crypto.randomUUID()}`
        };
      });
      function filterBySearchText({
        title,
        searchText,
        useAdvancedSearch: useAdvancedSearch2,
        useAdvancedSearchParsed: useAdvancedSearchParsed2
      }) {
        title = title.toLowerCase();
        searchText = searchText.toLowerCase();
        const simpleSearch = () => title.includes(searchText);
        const advancedSearch = () => {
          return ((useAdvancedSearchParsed2 == null ? void 0 : useAdvancedSearchParsed2.includes) ?? []).every((x) => title.includes(x)) && ((useAdvancedSearchParsed2 == null ? void 0 : useAdvancedSearchParsed2.excludes) ?? []).every((x) => !title.includes(x));
        };
        return useAdvancedSearch2 ? advancedSearch() : simpleSearch();
      }
      const {
        upMid,
        upName
      } = dfStore;
      if (
        //
        QUERY_DYNAMIC_UP_MID && upMid && upName && upName === upMid.toString() && items[0]
      ) {
        const authorName = items[0].modules.module_author.name;
        const authorFace = items[0].modules.module_author.face;
        dfStore.upName = authorName;
        dfStore.upFace = authorFace;
      }
      if (this.viewingSomeGroup && dfStore.groups.length) {
        const group = dfStore.groups.find((x) => x.tagid === this.groupId);
        if (group) group.count = this.groupMids.size;
      }
      return items;
    }
    handleAddSeparators(items) {
      if (!this.config.addSeparators) return items;
      const ret = items;
      {
        const config = this.separatorsConfig.today;
        const {
          getInsertIndex,
          content,
          added
        } = config;
        if (!added) {
          const idx = getInsertIndex(items);
          if (idx !== -1) {
            ret.splice(idx, 0, {
              api: EApiType.Separator,
              uniqId: `dynamic-feed-separator-today`,
              content
            });
            config.added = true;
          }
        }
      }
      {
        const config = this.separatorsConfig.earlier;
        const {
          getInsertIndex,
          content,
          added
        } = config;
        if (!added) {
          const idx = getInsertIndex(items);
          if (idx !== -1) {
            ret.splice(idx, 0, {
              api: EApiType.Separator,
              uniqId: "dynamic-feed-separator-earlier",
              content
            });
            config.added = true;
          }
        }
      }
      return ret;
    }
  };
  __publicField(_DynamicFeedRecService, "PAGE_SIZE", 15);
  let DynamicFeedRecService = _DynamicFeedRecService;
  function insertIndexFinderViaPubTsRange(lower, upper) {
    return (items) => {
      return items.findIndex((x) => {
        if (x.api !== EApiType.DynamicFeed) return false;
        const pubTs = x.modules.module_author.pub_ts;
        return pubTs >= lower && pubTs < upper;
      });
    };
  }
  function getTodaySeparatorInsertIndex(items) {
    const index = items.findIndex((x) => x.api === EApiType.Live && x.live_status === ELiveStatus.Streaming);
    if (index !== -1) return index;
    const todayInsertIndexFinder = insertIndexFinderViaPubTsRange(dayjs().startOf("day").unix(), dayjs().endOf("day").unix());
    return todayInsertIndexFinder(items);
  }
  const FAV_PAGE_SIZE = 20;
  const favSeparatorCss = {
    item: {
      name: "1hrg5ji",
      styles: "display:inline-flex;align-items:center;font-size:15px;&:not(:first-child){margin-left:30px;}svg{margin-right:5px;margin-top:-1px;}"
    }
  };
  function formatFavFolderUrl(id, ctype = 21) {
    return `https://space.bilibili.com/${getUid()}/favlist?fid=${id}&ftype=create`;
  }
  function formatFavCollectionUrl(id, ctype = 21) {
    return `https://space.bilibili.com/${getUid()}/favlist?fid=${id}&ftype=collect&ctype=${ctype}`;
  }
  function formatFavPlaylistUrl(id) {
    return `https://www.bilibili.com/list/ml${id}`;
  }
  function formatBvidUrl(bvid) {
    return `https://www.bilibili.com/video/${bvid}`;
  }
  class FavCollectionService {
    constructor(collectionId, addSeparator, itemsOrder) {
      /**
       * 这是个假分页... 一次返回所有
       */
      __publicField(this, "loaded", false);
      __publicField(this, "bufferQueue", []);
      __publicField(this, "separatorAdded", false);
      // reactive state
      __publicField(this, "state", proxy({
        firstBvid: void 0,
        info: void 0
      }));
      this.collectionId = collectionId;
      this.addSeparator = addSeparator;
      this.itemsOrder = itemsOrder;
    }
    get hasMore() {
      if (this.addSeparator && !this.separatorAdded) return true;
      if (!this.loaded) return true;
      return !!this.bufferQueue.length;
    }
    get separator() {
      return {
        api: EApiType.Separator,
        uniqId: `fav-collection-separator-${this.collectionId}`,
        content: /* @__PURE__ */ jsx$1(FavCollectionSeparator, { service: this })
      };
    }
    async loadMore(abortSignal) {
      var _a2;
      if (!this.hasMore) return;
      if (this.addSeparator && !this.separatorAdded) {
        this.separatorAdded = true;
        return [this.separator];
      }
      if (!this.loaded) {
        const data2 = await fetchCollectionDetail(this.collectionId, 1);
        const medias = (data2 == null ? void 0 : data2.medias) || [];
        const info = data2 == null ? void 0 : data2.info;
        await tryit(() => this.loadUserAvatarFromSpaceAccInfo(medias, abortSignal))();
        let items = medias.map((x) => {
          return {
            ...x,
            api: EApiType.Fav,
            uniqId: `${EApiType.Fav}-collection:${this.collectionId}-${x.bvid}`,
            collection: data2.info,
            from: "fav-collection"
          };
        });
        items = handleItemsOrder(items, this.itemsOrder);
        items.forEach((item, index, arr) => {
          item.vol = arr.length - index;
        });
        this.bufferQueue = items;
        this.loaded = true;
        this.state.firstBvid = (_a2 = items[0]) == null ? void 0 : _a2.bvid;
        this.state.info = cloneDeep(info);
        favStore.selectedFavCollectionDetailInfo = cloneDeep(info);
      }
      if (this.itemsOrder === FavItemsOrder.Shuffle) {
        this.bufferQueue = shuffle(this.bufferQueue);
      }
      let sliced;
      [sliced, this.bufferQueue] = [this.bufferQueue.slice(0, FAV_PAGE_SIZE), this.bufferQueue.slice(FAV_PAGE_SIZE)];
      return sliced;
    }
    // 合集返回的数据没有头像, 这里通过 space-acc-info 补全
    async loadUserAvatarFromSpaceAccInfo(items, abortSignal) {
      if (!items.length) return;
      const midsCount = countBy(items, (x) => x.upper.mid);
      const list2 = Object.entries(midsCount).map(([mid, count]) => ({
        mid,
        count
      }));
      const topMids = orderBy(list2, [(x) => x.count], ["desc"]).slice(0, 3).map((x) => x.mid);
      await Promise.all(topMids.map(async (mid) => {
        if (abortSignal == null ? void 0 : abortSignal.aborted) return;
        const info = await getSpaceAccInfo(mid);
        const face = info == null ? void 0 : info.face;
        if (face) {
          items.filter((x) => x.upper.mid.toString() === mid).forEach((x) => {
            var _a2;
            (_a2 = x.upper).face || (_a2.face = face);
          });
        }
      }));
    }
    get extraUsageInfo() {
      return /* @__PURE__ */ jsx$1(FavItemsOrderSwitcher, {});
    }
  }
  function FavCollectionSeparator({
    service
  }) {
    const {
      firstBvid,
      info
    } = useSnapshot(service.state);
    return /* @__PURE__ */ jsxs(Fragment, { children: [
      /* @__PURE__ */ jsx$1(AntdTooltip, { title: /* @__PURE__ */ jsxs(Fragment, { children: [
        "UP: ",
        info == null ? void 0 : info.upper.name,
        " ",
        /* @__PURE__ */ jsx$1("br", {}),
        (info == null ? void 0 : info.intro) || "简介: N/A"
      ] }), children: /* @__PURE__ */ jsxs(CustomTargetLink, { href: formatFavCollectionUrl(service.collectionId), css: favSeparatorCss.item, children: [
        /* @__PURE__ */ jsx$1(IconForOpenExternalLink, { className: "size-16px" }),
        info == null ? void 0 : info.title
      ] }) }),
      firstBvid && /* @__PURE__ */ jsxs(CustomTargetLink, { href: formatBvidUrl(firstBvid), css: favSeparatorCss.item, children: [
        /* @__PURE__ */ jsx$1(IconForPlayer, { className: "size-16px" }),
        "播放全部"
      ] })
    ] });
  }
  function FavFolderSeparator({
    service
  }) {
    return /* @__PURE__ */ jsxs(Fragment, { children: [
      /* @__PURE__ */ jsxs(CustomTargetLink, { href: formatFavFolderUrl(service.entry.id, service.entry.attr), css: favSeparatorCss.item, children: [
        /* @__PURE__ */ jsx$1(IconForOpenExternalLink, { className: "size-16px" }),
        service.entry.title
      ] }),
      /* @__PURE__ */ jsxs(CustomTargetLink, { href: formatFavPlaylistUrl(service.entry.id), css: favSeparatorCss.item, children: [
        /* @__PURE__ */ jsx$1(IconForPlayer, { className: "size-16px" }),
        "播放全部"
      ] })
    ] });
  }
  const FAV_FOLDER_API_SUPPOETED_ORDER = [FavItemsOrder.FavTimeDesc, FavItemsOrder.PlayCountDesc, FavItemsOrder.PubTimeDesc];
  function isFavFolderApiSuppoetedOrder(order) {
    return FAV_FOLDER_API_SUPPOETED_ORDER.includes(order);
  }
  class FavFolderService {
    constructor(folderId, addSeparator, itemsOrder) {
      __publicField(this, "needLoadAll");
      __publicField(this, "separatorAdded", false);
      __publicField(this, "entry");
      __publicField(this, "innerService");
      __publicField(this, "allItemsLoaded", false);
      __publicField(this, "bufferQueue", []);
      __publicField(this, "__fetchAllItems", async (abortSignal = new AbortController().signal) => {
        this.assertInnerService();
        const allItems = [];
        while (this.innerService.hasMore && !abortSignal.aborted) {
          const items = await this.innerService.loadMore(abortSignal) || [];
          allItems.push(...items);
        }
        return allItems;
      });
      // __fetchAllItems will result multiple requests, so cache it
      __publicField(this, "fetchAllItemsWithCache", wrapWithIdbCache({
        fn: this.__fetchAllItems,
        tableName: "fav-folder-all-items",
        generateKey: () => `${this.folderId}`,
        ttl: ms("5min")
      }));
      __publicField(this, "addToFetchAllItemsWithCache", async (items) => {
        const {
          cache: cache2,
          generateKey,
          shouldReuseCached
        } = this.fetchAllItemsWithCache;
        const cached = await cache2.get(generateKey());
        if (!cached || !shouldReuseCached(cached)) return;
        const newItems = uniqBy([...cached.val, ...items], (x) => x.bvid);
        await cache2.set(generateKey(), {
          ...cached,
          val: newItems
        });
      });
      this.folderId = folderId;
      this.addSeparator = addSeparator;
      this.itemsOrder = itemsOrder;
      if (this.itemsOrder === FavItemsOrder.Initial) {
        throw new Error("this should not happen!");
      }
      if (isFavFolderApiSuppoetedOrder(this.itemsOrder)) {
        this.needLoadAll = false;
      } else {
        this.needLoadAll = true;
      }
    }
    get hasMore() {
      if (this.addSeparator && !this.separatorAdded) return true;
      if (this.needLoadAll) {
        if (!this.allItemsLoaded) return true;
        return !!this.bufferQueue.length;
      } else {
        if (!this.innerService) return true;
        return this.innerService.hasMore;
      }
    }
    get separator() {
      this.assertInnerService();
      return {
        api: EApiType.Separator,
        uniqId: `fav-folder-separator-${this.folderId}`,
        content: /* @__PURE__ */ jsx$1(FavFolderSeparator, { service: this.innerService })
      };
    }
    // https://www.totaltypescript.com/tips/use-assertion-functions-inside-classes
    assertInnerService() {
      invariant(this.innerService, "this.innerService should not be undefined");
    }
    async createService() {
      if (this.innerService) return;
      await favStore.updateList();
      const entry = snapshot(favStore.favFolders).find((f2) => f2.id === this.folderId);
      invariant(entry, `favStore.favFolders should have this entry[fid=${this.folderId}]`);
      this.entry = entry;
      if (isFavFolderApiSuppoetedOrder(this.itemsOrder)) {
        this.innerService = new FavFolderBasicService(entry, this.itemsOrder);
      } else {
        this.innerService = new FavFolderBasicService(entry);
      }
    }
    async loadMore(abortSignal) {
      var _a2;
      if (!this.innerService) await this.createService();
      if (!this.hasMore) return;
      if (this.addSeparator && !this.separatorAdded) {
        this.separatorAdded = true;
        return [this.separator];
      }
      if (this.needLoadAll) {
        if (!this.allItemsLoaded) await this.loadAllItems(abortSignal);
        if (this.itemsOrder === FavItemsOrder.Shuffle) {
          this.bufferQueue = shuffle(this.bufferQueue);
        }
        const sliced = this.bufferQueue.slice(0, FAV_PAGE_SIZE);
        this.bufferQueue = this.bufferQueue.slice(FAV_PAGE_SIZE);
        return sliced;
      } else {
        const ret = await ((_a2 = this.innerService) == null ? void 0 : _a2.loadMore(abortSignal));
        if (ret == null ? void 0 : ret.length) await this.addToFetchAllItemsWithCache(ret);
        this.runSideEffects();
        return ret;
      }
    }
    async loadAllItems(abortSignal) {
      const allItems = await this.fetchAllItemsWithCache(abortSignal);
      this.bufferQueue = handleItemsOrder(allItems, this.itemsOrder);
      this.allItemsLoaded = true;
      this.runSideEffects();
    }
    runSideEffects() {
      var _a2;
      this.assertInnerService();
      if (typeof ((_a2 = this.innerService.info) == null ? void 0 : _a2.media_count) === "number") {
        updateFavFolderMediaCount(this.folderId, this.innerService.info.media_count);
      }
    }
    get extraUsageInfo() {
      return /* @__PURE__ */ jsx$1(FavItemsOrderSwitcher, {});
    }
  }
  class FavFolderBasicService {
    constructor(entry, itemsOrder = FavItemsOrder.FavTimeDesc) {
      __publicField(this, "hasMore");
      __publicField(this, "info");
      __publicField(this, "page", 0);
      this.entry = entry;
      this.itemsOrder = itemsOrder;
      this.hasMore = entry.media_count > 0;
    }
    // pages loaded
    async loadMore(abortSignal) {
      if (!this.hasMore) return;
      const order = {
        [FavItemsOrder.FavTimeDesc]: "mtime",
        [FavItemsOrder.PlayCountDesc]: "view",
        [FavItemsOrder.PubTimeDesc]: "pubtime"
      }[this.itemsOrder];
      const res = await request.get("/x/v3/fav/resource/list", {
        params: {
          media_id: this.entry.id,
          pn: this.page + 1,
          // start from 1
          ps: 20,
          keyword: "",
          order,
          // mtime(最近收藏)  view(最多播放) pubtime(最新投稿)
          type: "0",
          // unkown
          tid: "0",
          // 分区
          platform: "web"
        }
      });
      const json = res.data;
      if (!isWebApiSuccess(json)) {
        toast(json.message || REQUEST_FAIL_MSG);
        return;
      }
      this.page++;
      this.hasMore = json.data.has_more;
      this.info = json.data.info;
      let items = json.data.medias || [];
      items = items.filter((item) => {
        if (item.title === "已失效视频") return false;
        return true;
      });
      return items.map((item) => {
        var _a2;
        return {
          ...item,
          from: "fav-folder",
          folder: this.info,
          api: EApiType.Fav,
          uniqId: `${EApiType.Fav}-folder:${((_a2 = this.info) == null ? void 0 : _a2.id) || this.entry.id}-${item.bvid}`
        };
      });
    }
  }
  class FavAllService {
    constructor(addSeparator, itemsOrder, excludedFolderIds) {
      __publicField(this, "shuffleBufferQueue", []);
      // fav-folder
      __publicField(this, "allFolderServices", []);
      // before exclude
      __publicField(this, "state", proxy({
        totalCountInFavFolders: 0
      }));
      __publicField(this, "serviceCreated", false);
      __publicField(this, "allServices", []);
      this.addSeparator = addSeparator;
      this.itemsOrder = itemsOrder;
      this.excludedFolderIds = excludedFolderIds;
      if (![FavItemsOrder.Initial, FavItemsOrder.Shuffle].includes(this.itemsOrder)) {
        throw new Error("invalid items order");
      }
    }
    get useShuffle() {
      return this.itemsOrder === FavItemsOrder.Shuffle;
    }
    get hasMoreInService() {
      if (!this.serviceCreated) return true;
      return this.allServices.some((s2) => s2.hasMore);
    }
    get hasMore() {
      if (this.useShuffle) {
        return !!this.shuffleBufferQueue.length || this.hasMoreInService;
      } else {
        return this.hasMoreInService;
      }
    }
    get extraUsageInfo() {
      return /* @__PURE__ */ jsxs(Fragment, { children: [
        /* @__PURE__ */ jsx$1(FavItemsOrderSwitcher, {}),
        /* @__PURE__ */ jsx$1(ViewingAllExcludeFolderConfig, { allFavFolderServices: this.allFolderServices, state: this.state })
      ] });
    }
    async loadMore(abortSignal) {
      if (!this.serviceCreated) await this.createServices();
      if (!this.hasMore) return;
      if (!this.useShuffle) {
        const service = this.allServices.find((s2) => s2.hasMore);
        return service == null ? void 0 : service.loadMore(abortSignal);
      }
      if (this.shuffleBufferQueue.length < FAV_PAGE_SIZE) {
        const count = 6;
        const batch = 2;
        while (this.hasMoreInService && this.shuffleBufferQueue.length < FAV_PAGE_SIZE * 3) {
          const restServices = this.allServices.filter((s2) => s2.hasMore);
          const pickedServices = shuffle(restServices).slice(0, count);
          const fetched = (await pmap(pickedServices, async (s2) => await s2.loadMore(abortSignal) || [], batch)).flat().filter((x) => x.api !== EApiType.Separator);
          this.shuffleBufferQueue = shuffle([...this.shuffleBufferQueue, ...shuffle(fetched)]);
        }
      }
      const sliced = this.shuffleBufferQueue.slice(0, FAV_PAGE_SIZE);
      this.shuffleBufferQueue = this.shuffleBufferQueue.slice(FAV_PAGE_SIZE);
      return sliced;
    }
    async createServices() {
      await favStore.updateList();
      const {
        favFolders,
        favCollections
      } = cloneDeep(snapshot(favStore));
      this.allFolderServices = favFolders.map((f2) => new FavFolderBasicService(f2));
      this.state.totalCountInFavFolders = favFolders.filter((f2) => !this.excludedFolderIds.includes(f2.id.toString())).reduce((count, f2) => count + f2.media_count, 0);
      {
        const folders = favFolders.filter((f2) => !this.excludedFolderIds.includes(f2.id.toString()));
        let itemsOrder = this.itemsOrder;
        if (itemsOrder === FavItemsOrder.Initial) itemsOrder = FavItemsOrder.FavTimeDesc;
        this.allServices.push(...folders.map((f2) => new FavFolderService(f2.id, this.addSeparator, itemsOrder)));
      }
      {
        this.allServices.push(...favCollections.map((c2) => new FavCollectionService(c2.id, this.addSeparator, this.itemsOrder)));
      }
      this.serviceCreated = true;
    }
  }
  function getFavServiceConfig() {
    const snap = snapshot(favStore);
    return {
      selectedKey: snap.selectedKey,
      itemsOrder: getSavedOrder(snap.selectedKey, snap.savedOrderMap),
      selectedFavFolderId: snap.selectedFavFolderId,
      selectedFavCollectionId: snap.selectedFavCollectionId,
      // from settings
      addSeparator: settings.fav.addSeparator,
      excludedFolderIds: settings.fav.excludedFolderIds
    };
  }
  function getFavServiceConfigExtra(config) {
    const ret = {
      ...config,
      get viewingAll() {
        return config.selectedKey === "all";
      },
      get viewingSomeFolder() {
        return typeof config.selectedFavFolderId === "number";
      },
      get viewingSomeCollection() {
        return typeof config.selectedFavCollectionId === "number";
      }
    };
    return ret;
  }
  const _FavRecService = class _FavRecService extends BaseTabService {
    constructor(config) {
      super(_FavRecService.PAGE_SIZE);
      __publicField(this, "config");
      __publicField(this, "innerService");
      this.config = getFavServiceConfigExtra(config);
      const {
        viewingAll,
        viewingSomeFolder,
        viewingSomeCollection
      } = this.config;
      if (viewingAll) {
        this.innerService = new FavAllService(this.config.addSeparator, this.config.itemsOrder, this.config.excludedFolderIds);
      } else if (viewingSomeFolder) {
        this.innerService = new FavFolderService(this.config.selectedFavFolderId, this.config.addSeparator, this.config.itemsOrder);
      } else if (viewingSomeCollection) {
        this.innerService = new FavCollectionService(this.config.selectedFavCollectionId, this.config.addSeparator, this.config.itemsOrder);
      } else {
        throw new Error("unexpected case!");
      }
    }
    get usageInfo() {
      const {
        usageInfo,
        extraUsageInfo
      } = this.innerService;
      if (usageInfo) return usageInfo;
      return /* @__PURE__ */ jsx$1(FavUsageInfo, { extraContent: extraUsageInfo });
    }
    get hasMoreExceptQueue() {
      return this.innerService.hasMore;
    }
    fetchMore(abortSignal) {
      return this.innerService.loadMore(abortSignal);
    }
    // for remove card
    decreaseTotal() {
      if (this.config.viewingAll) {
        this.innerService.state.totalCountInFavFolders -= 1;
      } else if (this.config.viewingSomeFolder && this.config.selectedFavFolderId) {
        updateFavFolderMediaCount(this.config.selectedFavFolderId, (x) => x - 1);
      } else if (this.config.viewingSomeCollection && this.config.selectedFavCollectionId) ;
    }
  };
  __publicField(_FavRecService, "PAGE_SIZE", FAV_PAGE_SIZE);
  let FavRecService = _FavRecService;
  async function fetchWatchlaterItems({
    asc = false,
    searchText = "",
    abortSignal,
    extraParams
  } = {}) {
    const res = await request.get("/x/v2/history/toview/web", {
      signal: abortSignal,
      params: await encWbi({
        asc,
        key: searchText,
        viewed: 0,
        // 全部进度
        web_location: 333.881,
        ...extraParams
      })
    });
    const json = res.data;
    if (!isWebApiSuccess(json)) {
      appWarn("getAllWatchlaterItems error %s, fulljson %o", json.message, json);
      return {
        err: json.message
      };
    }
    return {
      total: json.data.count,
      items: filterOutApiReturnedRecent(json.data.list || [])
    };
  }
  function filterOutApiReturnedRecent(items) {
    return items.filter((item) => !(item.title === "以下为更早添加的视频" && item.aid === 0 && item.bvid === "" && item.add_at === 0));
  }
  async function batchRemoveWatchlater(avids) {
    const form = new FormData();
    form.append("resources", avids.join(","));
    form.append("csrf", getCsrfToken());
    const params = await encWbi({});
    const res = await request.post("/x/v2/history/toview/v2/dels", form, {
      params
    });
    const json = res.data;
    if (!isWebApiSuccess(json)) {
      toast((json == null ? void 0 : json.message) || "出错了");
      return false;
    }
    return true;
  }
  const store$2 = proxy({
    searchText: void 0
  });
  function WatchlaterUsageInfo({
    service
  }) {
    const {
      watchlaterAddSeparator,
      watchlaterItemsOrder
    } = useSettingsSnapshot();
    const onRefresh = useOnRefreshContext();
    const {
      searchText
    } = useSnapshot(store$2, {
      sync: true
    });
    const multiSelecting = useMultiSelecting();
    useUpdateEffect(() => {
      void (async () => {
        await delay(100);
        onRefresh == null ? void 0 : onRefresh();
      })();
    }, [watchlaterAddSeparator, watchlaterItemsOrder]);
    const {
      total
    } = useSnapshot(service.state);
    const title = searchText ? `共 ${total} 条搜索结果` : `共 ${total} 个视频`;
    const totalTag = typeof total === "number" && /* @__PURE__ */ jsx$1(antd.Tag, { color: "success", style: {
      marginRight: 0,
      marginTop: 1,
      cursor: "pointer"
    }, title, onClick: () => {
      toast(`稍后再看: ${title}`);
    }, children: total });
    return /* @__PURE__ */ jsxs("div", { className: "flex items-center gap-x-12px", children: [
      /* @__PURE__ */ jsx$1(WatchlaterOrderSwitcher, {}),
      /* @__PURE__ */ jsx$1(antd.Input.Search, { allowClear: true, placeholder: "搜索稍后再看", style: {
        width: 180
      }, value: searchText, onChange: (e2) => store$2.searchText = e2.target.value, onSearch: (val) => {
        store$2.searchText = val;
        onRefresh == null ? void 0 : onRefresh();
      } }),
      totalTag,
      multiSelecting && /* @__PURE__ */ jsx$1(AntdTooltip, { arrow: false, title: "移除稍后再看 (多选)", children: /* @__PURE__ */ jsx$1(antd.Button, { className: "icon-only-round-button", onClick: removeMultiSelectedWatchlaterItems, children: /* @__PURE__ */ jsx$1(IconForRemove, {}) }) }),
      /* @__PURE__ */ jsx$1(CopyBvidButtonsUsageInfo, {})
    ] });
  }
  const WatchlaterItemsOrderConfig = {
    [WatchlaterItemsOrder.AddTimeDesc]: {
      icon: /* @__PURE__ */ jsx$1(IconForTimestamp, {}),
      label: withDescIcon("最近添加"),
      helpInfo: "按添加时间倒序"
    },
    [WatchlaterItemsOrder.AddTimeAsc]: {
      icon: /* @__PURE__ */ jsx$1(IconForTimestamp, {}),
      label: withAscIcon("最早添加"),
      helpInfo: "按添加时间增序"
    },
    [WatchlaterItemsOrder.Shuffle]: {
      icon: /* @__PURE__ */ jsx$1(IconForShuffle, {}),
      label: "随机顺序",
      helpInfo: "不包括近期添加的稍后再看, 近期: 最近48小时内"
    }
  };
  const list = Object.values(WatchlaterItemsOrder);
  const extraHelpInfo = /* @__PURE__ */ jsx$1("div", { className: "flex flex-col gap-y-4px", children: list.map((x) => {
    const {
      icon,
      label,
      helpInfo
    } = WatchlaterItemsOrderConfig[x];
    return /* @__PURE__ */ jsxs("div", { className: "flex items-center justify-left line-height-[0] gap-x-4px", children: [
      icon,
      " ",
      /* @__PURE__ */ jsx$1("span", { className: "min-w-80px", children: label }),
      " :   ",
      helpInfo
    ] }, x);
  }) });
  function WatchlaterOrderSwitcher() {
    const onRefresh = useOnRefreshContext();
    const {
      ref,
      getPopupContainer
    } = usePopupContainer();
    const {
      watchlaterItemsOrder
    } = useSettingsSnapshot();
    const {
      searchText
    } = useSnapshot(store$2);
    const disabled = !!searchText;
    return /* @__PURE__ */ jsx$1(GenericOrderSwitcher, { disabled, value: disabled ? WatchlaterItemsOrder.AddTimeDesc : watchlaterItemsOrder, onChange: async (next2) => {
      settings.watchlaterItemsOrder = next2;
      await delay(100);
      onRefresh == null ? void 0 : onRefresh();
    }, list, listDisplayConfig: WatchlaterItemsOrderConfig, $ref: ref, dropdownProps: {
      getPopupContainer
    }, extraHelpInfo });
  }
  const watchlaterState = proxy({
    updatedAt: 0,
    bvidSet: proxySet()
  });
  function useWatchlaterState(bvid) {
    const set2 = useSnapshot(watchlaterState).bvidSet;
    return !!bvid && set2.has(bvid);
  }
  async function updateWatchlaterState() {
    if (!getHasLogined() || !getUid()) return;
    const {
      items: allWatchlaterItems = []
    } = await fetchWatchlaterItems();
    if (!allWatchlaterItems.length) return;
    watchlaterState.updatedAt = Date.now();
    watchlaterState.bvidSet = proxySet(allWatchlaterItems.map((x) => x.bvid));
  }
  if (IN_BILIBILI_HOMEPAGE) {
    void (async () => {
      await whenIdle();
      await pRetry(updateWatchlaterState, {
        retries: 3,
        onFailedAttempt(error) {
          appWarn(`Try updateWatchlaterState ${error.attemptNumber} failed. There are ${error.retriesLeft} retries left`);
        }
      });
    })();
  }
  async function removeMultiSelectedWatchlaterItems() {
    const selected = getMultiSelectedItems().map((item) => ({
      item,
      cardData: normalizeCardData(item)
    })).filter((x) => x.cardData.avid).map((x) => [x.cardData.avid, x.item.uniqId, x.cardData.title]).filter(Boolean);
    const avids = selected.map((x) => x[0]);
    const uniqIds = selected.map((x) => x[1]);
    const titles = selected.map((x) => x[2]);
    if (!avids.length) {
      return toast("没有选中的视频");
    }
    const success = await batchRemoveWatchlater(avids);
    if (!success) return;
    currentGridSharedEmitter.emit("remove-cards", [uniqIds, titles]);
  }
  const _WatchlaterRecService = class _WatchlaterRecService extends BaseTabService {
    constructor(order, addSeparator, prevShuffleBvidIndexMap, searchText) {
      super(_WatchlaterRecService.PAGE_SIZE);
      __publicField(this, "innerService");
      this.searchText = searchText;
      this.innerService = order === WatchlaterItemsOrder.Shuffle && !this.searchText ? new ShuffleOrderService(addSeparator, prevShuffleBvidIndexMap) : new NormalOrderService(order, addSeparator, this.searchText);
    }
    get hasMoreExceptQueue() {
      return this.innerService.hasMore;
    }
    fetchMore(abortSignal) {
      return this.innerService.loadMore(abortSignal);
    }
    get usageInfo() {
      return /* @__PURE__ */ jsx$1(WatchlaterUsageInfo, { service: this });
    }
    get state() {
      return this.innerService.state;
    }
    // for remove watchlater card
    decreaseTotal() {
      if (typeof this.innerService.state.total === "undefined") return;
      this.innerService.state.total--;
    }
    getServiceSnapshot() {
      const bvidIndexMap = this.innerService instanceof ShuffleOrderService ? this.innerService.currentBvidIndexMap : void 0;
      return {
        bvidIndexMap
      };
    }
  };
  __publicField(_WatchlaterRecService, "PAGE_SIZE", 10);
  let WatchlaterRecService = _WatchlaterRecService;
  function extendItem(item) {
    return {
      ...item,
      api: EApiType.Watchlater,
      uniqId: `${EApiType.Watchlater}-${item.bvid}`
    };
  }
  const getRecentGate = () => dayjs().subtract(2, "days").unix();
  const recentSeparator = {
    api: EApiType.Separator,
    uniqId: "watchlater-separator-recent",
    content: "近期"
  };
  const earlierSeparator = {
    api: EApiType.Separator,
    uniqId: "watchlater-separator-earlier",
    content: "更早"
  };
  function showApiRequestError(err) {
    toast(`获取稍后再看失败: ${err}`);
    throw new Error(`获取稍后再看失败: ${err}`, {
      cause: err
    });
  }
  class ShuffleOrderService {
    constructor(addSeparator, prevBvidIndexMap) {
      __publicField(this, "hasMore", true);
      __publicField(this, "state", proxy({
        total: void 0
      }));
      // shuffle related
      __publicField(this, "keepOrder");
      __publicField(this, "prevBvidIndexMap");
      __publicField(this, "currentBvidIndexMap");
      this.addSeparator = addSeparator;
      if (prevBvidIndexMap == null ? void 0 : prevBvidIndexMap.size) {
        this.keepOrder = true;
        this.prevBvidIndexMap = prevBvidIndexMap;
      } else {
        this.keepOrder = false;
      }
    }
    async loadMore(abortSignal) {
      if (!this.hasMore) return;
      const items = await this.fetch(abortSignal);
      this.hasMore = false;
      return items;
    }
    async fetch(abortSignal) {
      var _a2;
      const {
        items: rawItems = [],
        err
      } = await fetchWatchlaterItems({
        asc: false,
        searchText: void 0,
        abortSignal
      });
      if (typeof err !== "undefined") {
        showApiRequestError(err);
      }
      const items = rawItems.map(extendItem);
      const recentGate = getRecentGate();
      const firstNotRecentIndex = items.findIndex((item) => item.add_at < recentGate);
      let itemsWithSeparator = items;
      if (firstNotRecentIndex !== -1) {
        const recent = items.slice(0, firstNotRecentIndex);
        let earlier = items.slice(firstNotRecentIndex);
        if (this.keepOrder && ((_a2 = this.prevBvidIndexMap) == null ? void 0 : _a2.size)) {
          earlier = orderBy(earlier, [(item) => {
            var _a3;
            return ((_a3 = this.prevBvidIndexMap) == null ? void 0 : _a3.get(item.bvid)) ?? -1;
          }], ["asc"]);
        } else {
          earlier = shuffle(earlier);
        }
        itemsWithSeparator = [!!recent.length && this.addSeparator && recentSeparator, ...recent, !!earlier.length && this.addSeparator && earlierSeparator, ...earlier].filter(Boolean);
      }
      this.state.total = rawItems.length;
      this.currentBvidIndexMap = new Map(itemsWithSeparator.filter((x) => x.api !== EApiType.Separator).map((x, index) => [x.bvid, index]));
      return itemsWithSeparator;
    }
  }
  class NormalOrderService {
    // configs
    constructor(order, addSeparator, searchText) {
      __publicField(this, "firstPageLoaded", false);
      __publicField(this, "state", proxy({
        total: void 0
      }));
      __publicField(this, "hasMore", true);
      __publicField(this, "page", 1);
      __publicField(this, "recentSeparatorInserted", false);
      __publicField(this, "earlierSeparatorInserted", false);
      this.order = order;
      this.addSeparator = addSeparator;
      this.searchText = searchText;
      if (!this.searchText) {
        invariant(order !== WatchlaterItemsOrder.Shuffle, "shuffle not supported in NormalOrderService");
      }
    }
    async loadMore() {
      if (!this.hasMore) return;
      const result = await fetchWatchlaterItems({
        asc: this.order === WatchlaterItemsOrder.AddTimeAsc,
        searchText: this.searchText,
        extraParams: {
          need_split: "true",
          ps: 20,
          pn: this.page
        }
      });
      if (typeof result.err !== "undefined") {
        this.hasMore = false;
        showApiRequestError(result.err);
        return;
      }
      const {
        items,
        total
      } = result;
      const maxPage = Math.ceil(total / 20);
      this.firstPageLoaded = true;
      this.state.total = result.total;
      this.hasMore = this.page < maxPage;
      this.page++;
      const extendedItems = items.map(extendItem);
      return this.insertSeparator(extendedItems);
    }
    insertSeparator(items) {
      if (!this.addSeparator) return items;
      let newItems = [...items];
      const recentGate = getRecentGate();
      const needEarlierSeparator = items.some((item) => item.add_at < recentGate);
      const needRecentSeparator = items.some((item) => item.add_at >= recentGate);
      if (this.order === WatchlaterItemsOrder.AddTimeAsc) {
        if (!this.earlierSeparatorInserted && needEarlierSeparator) {
          newItems = [earlierSeparator, ...newItems];
          this.earlierSeparatorInserted = true;
        }
        if (!this.recentSeparatorInserted && needRecentSeparator) {
          const idx = newItems.findIndex((item) => item.api === EApiType.Watchlater && item.add_at >= recentGate);
          newItems = [...newItems.slice(0, idx), recentSeparator, ...newItems.slice(idx)];
          this.recentSeparatorInserted = true;
        }
      } else {
        if (!this.recentSeparatorInserted && needRecentSeparator) {
          newItems = [recentSeparator, ...items];
          this.recentSeparatorInserted = true;
        }
        if (!this.earlierSeparatorInserted && needEarlierSeparator) {
          const idx = newItems.findIndex((item) => item.api === EApiType.Watchlater && item.add_at < recentGate);
          newItems = [...newItems.slice(0, idx), earlierSeparator, ...newItems.slice(idx)];
          this.earlierSeparatorInserted = true;
        }
      }
      return newItems;
    }
  }
  function getAppRecServiceConfig() {
    const snap = getSettingsSnapshot().appRecommend;
    let deviceParamForApi = snap.deviceParamForApi;
    if (!Object.values(EAppApiDevice).includes(deviceParamForApi)) {
      deviceParamForApi = EAppApiDevice.ipad;
    }
    return {
      deviceParamForApi,
      addOtherTabContents: snap.addOtherTabContents
    };
  }
  const appRecShowContentFromOtherTabEl = (onRefresh) => /* @__PURE__ */ jsx$1(CheckboxSettingItem, { configPath: "appRecommend.addOtherTabContents", label: "显示来自其他 Tab 的内容", tooltip: /* @__PURE__ */ jsxs(Fragment, { children: [
    "显示来自其他 Tab 的内容 ",
    /* @__PURE__ */ jsx$1("br", {}),
    "如动态 / 收藏 / 稍后再看 ",
    /* @__PURE__ */ jsx$1("br", {}),
    "但是: 刷新时间会更长"
  ] }), extraAction: async () => {
    await delay(100);
    onRefresh == null ? void 0 : onRefresh();
  } });
  function AppRecUsageInfo() {
    const onRefresh = useOnRefreshContext();
    return /* @__PURE__ */ jsx$1(Fragment, { children: appRecShowContentFromOtherTabEl(onRefresh) });
  }
  const _AppRecService = class _AppRecService extends BaseTabService {
    constructor(config) {
      super(_AppRecService.PAGE_SIZE);
      __publicField(this, "usageInfo", /* @__PURE__ */ jsx$1(AppRecUsageInfo, {}));
      __publicField(this, "innerService");
      __publicField(this, "allServices", []);
      __publicField(this, "otherTabServices", []);
      __publicField(this, "hasMoreExceptQueue", true);
      this.config = config;
      this.innerService = new AppRecInnerService(this.config.deviceParamForApi);
      this.allServices = [this.innerService];
      this.initOtherTabServices();
    }
    initOtherTabServices() {
      if (!getHasLogined()) return;
      if (!this.config.addOtherTabContents) return;
      let dynamicFeedService;
      let favService;
      let watchlaterService;
      {
        const store2 = createDfStore();
        store2.upMid = void 0;
        store2.selectedGroupId = void 0;
        const config = getDynamicFeedServiceConfig(store2);
        Object.assign(config, {
          showLiveInDynamicFeed: true,
          whenViewAllEnableHideSomeContents: false,
          searchCacheEnabled: false
        });
        dynamicFeedService = new DynamicFeedRecService(config);
      }
      {
        const config = Object.assign(getFavServiceConfig(), {
          selectedKey: "all",
          itemsOrder: FavItemsOrder.Shuffle,
          selectedFavFolderId: void 0,
          selectedFavCollectionId: void 0,
          addSeparator: false
        });
        favService = new FavRecService(config);
      }
      {
        watchlaterService = new WatchlaterRecService(WatchlaterItemsOrder.AddTimeDesc, false);
      }
      this.otherTabServices = [dynamicFeedService, favService, watchlaterService];
      const allServices = [];
      const rate = 7 / 3;
      allServices.push(...this.otherTabServices);
      times(Math.round(rate * this.otherTabServices.length), () => allServices.push(this.innerService));
      this.allServices = shuffle(allServices);
    }
    get hasMore() {
      return !!this.qs.bufferQueue.length || this.innerService.hasMore || this.otherTabServices.some((s2) => s2.hasMore);
    }
    // this is not used, since below `override loadMore`
    fetchMore(abortSignal) {
      throw new Error("Method not implemented.");
    }
    async loadMore(abortSignal) {
      if (!this.hasMore) return;
      while (this.hasMore && this.qs.bufferQueue.length < _AppRecService.PAGE_SIZE * 3) {
        const restServices = this.allServices.filter((s2) => s2.hasMore);
        if (!restServices.length) break;
        const pickedServices = shuffle(restServices).slice(0, 3);
        const more = (await Promise.all(pickedServices.map(async (s2) => await s2.loadMore(abortSignal) || []))).flat().filter((x) => x.api !== EApiType.Separator);
        this.qs.bufferQueue.push(...more);
        this.qs.bufferQueue = shuffle(this.qs.bufferQueue);
      }
      return this.qs.sliceFromQueue();
    }
    // for filter
    async loadMoreBatch(abortSignal, times2) {
      if (!this.hasMore) return;
      if (this.qs.bufferQueue.length) return this.qs.sliceFromQueue(times2);
      return this.qs.doReturnItems(await this.innerService.getRecommendTimes(abortSignal, times2));
    }
  };
  __publicField(_AppRecService, "PAGE_SIZE", 20);
  let AppRecService = _AppRecService;
  class AppRecInnerService {
    constructor(deviceParamForApi) {
      __publicField(this, "hasMore", true);
      this.deviceParamForApi = deviceParamForApi;
    }
    async getRecommend(device) {
      var _a2;
      let platformParams = {};
      if (device === EAppApiDevice.android) {
        platformParams = {
          mobi_app: "android"
        };
      }
      if (device === EAppApiDevice.ipad) {
        platformParams = {
          mobi_app: "iphone",
          device: "pad"
        };
      }
      const res = await gmrequest.get(HOST_APP + "/x/v2/feed/index", {
        timeout: 2e4,
        responseType: "json",
        params: {
          build: "1",
          ...platformParams,
          // idx: 返回的 items.idx 为传入 idx+1, idx+2, ...
          idx: Math.floor(Date.now() / 1e3) + randomInt(1e3)
        }
      });
      const json = res.data;
      if (!json.data) {
        throw new Error("Request fail with none invalid json", {
          cause: {
            type: "invalid-json",
            statusCode: res.status,
            json
          }
        });
      }
      const items = ((_a2 = json == null ? void 0 : json.data) == null ? void 0 : _a2.items) || [];
      return items;
    }
    loadMore(abortSignal, times2 = 2) {
      return this.getRecommendTimes(abortSignal, times2);
    }
    // 一次不够, 多来几次
    async getRecommendTimes(abortSignal, times2) {
      let list2 = (await Promise.all(range(times2).map(() => this.getRecommend(this.deviceParamForApi)))).flat();
      list2 = list2.filter((item) => {
        var _a2, _b2;
        if ((_a2 = item.card_goto) == null ? void 0 : _a2.includes("ad")) return false;
        if ((_b2 = item.goto) == null ? void 0 : _b2.includes("ad")) return false;
        if (item.ad_info) return false;
        if (item.card_goto === "banner") return false;
        if (item.goto === "av" && typeof item.player_args === "undefined") return false;
        return true;
      });
      list2 = uniqBy(list2, (item) => item.param);
      const extendedList = list2.map((item) => {
        return {
          ...item,
          api: EApiType.AppRecommend,
          uniqId: `${EApiType.AppRecommend}-${item.param}`,
          device: this.deviceParamForApi
          // android | ipad
        };
      });
      return extendedList;
    }
  }
  // 无法指定, 16 根据返回得到
  __publicField(AppRecInnerService, "PAGE_SIZE", 16);
  async function fetchAppRecommendFollowedPubDate(item, cardData) {
    const {
      bvid,
      goto,
      recommendReason
    } = cardData;
    const isNormalVideo = goto === "av";
    const shouldFetch = isAppRecommend(item) && item.device === EAppApiDevice.ipad && isNormalVideo && !!bvid && getFollowedStatus$1(recommendReason);
    if (!shouldFetch) return;
    const detail = await getVideoDetail(bvid);
    const ts = detail == null ? void 0 : detail.pubdate;
    if (!ts) return;
    return formatRecentTimeStamp(ts, true);
  }
  const debug$7 = baseDebug.extend("modules:rec-services:pc");
  let _id = 0;
  const genUniqId = () => Date.now() + _id++;
  const _PcRecService = class _PcRecService extends BaseTabService {
    constructor(isKeepFollowOnly) {
      super(_PcRecService.PAGE_SIZE);
      __publicField(this, "usageInfo");
      __publicField(this, "page", 0);
      __publicField(this, "hasMoreExceptQueue", true);
      this.isKeepFollowOnly = isKeepFollowOnly;
    }
    fetchMore(abortSignal) {
      const times2 = this.isKeepFollowOnly ? 5 : 2;
      return this.getRecommendTimes(times2, abortSignal);
    }
    // for filter
    async loadMoreBatch(times2, abortSignal) {
      if (!this.hasMore) return;
      if (this.qs.bufferQueue.length) return this.qs.sliceFromQueue(times2);
      return this.qs.doReturnItems(await this.getRecommendTimes(times2, abortSignal));
    }
    async getRecommendTimes(times2, abortSignal) {
      let list2 = (await Promise.all(range(times2).map(() => this.getRecommend(abortSignal)))).flat();
      list2 = list2.filter((item) => {
        const allowedGotoList = [PcRecGoto.AV, PcRecGoto.Live];
        if (!allowedGotoList.includes(item.goto)) {
          const knownDisabledGotoList = [PcRecGoto.Ad];
          if (!knownDisabledGotoList.includes(item.goto)) {
            debug$7("uknown goto: %s %o", item.goto, item);
          }
          return false;
        }
        return true;
      });
      list2 = uniqBy(list2, (item) => item.id);
      list2.forEach((item) => {
        var _a2, _b2;
        if (((_a2 = item.rcmd_reason) == null ? void 0 : _a2.reason_type) === 1) {
          (_b2 = item.rcmd_reason).content || (_b2.content = "已关注");
        }
      });
      const _list = list2.map((item) => {
        var _a2;
        return {
          ...item,
          uniqId: `${EApiType.PcRecommend}-${item.bvid || ((_a2 = item.room_info) == null ? void 0 : _a2.room_id) || crypto.randomUUID()}`,
          api: EApiType.PcRecommend
        };
      });
      return _list;
    }
    async getRecommend(abortSignal) {
      var _a2, _b2;
      const curpage = ++this.page;
      const url = "/x/web-interface/wbi/index/top/feed/rcmd";
      const params = {
        web_location: 1430650,
        feed_version: "V8",
        homepage_ver: 1,
        fresh_type: 4,
        y_num: 5,
        last_y_num: 5,
        fresh_idx_1h: curpage,
        fresh_idx: curpage,
        uniq_id: genUniqId(),
        ps: 12
      };
      const res = await request.get(url, {
        signal: abortSignal,
        params
      });
      const json = res.data;
      if (!isWebApiSuccess(json)) {
        if (json.code === -62011 && json.message === "暂时没有更多内容了") {
          this.hasMoreExceptQueue = false;
          return [];
        }
      }
      if (!((_a2 = json.data) == null ? void 0 : _a2.item)) {
        toast(json.message || "API 请求没有返回结果");
      }
      const items = ((_b2 = json.data) == null ? void 0 : _b2.item) || [];
      return items;
    }
  };
  __publicField(_PcRecService, "PAGE_SIZE", 14);
  let PcRecService = _PcRecService;
  const REC_TABS = [ETab.KeepFollowOnly, ETab.PcRecommend, ETab.AppRecommend];
  const createServiceMap = {
    [ETab.AppRecommend]: () => new AppRecService(getAppRecServiceConfig()),
    [ETab.PcRecommend]: () => new PcRecService(false),
    [ETab.KeepFollowOnly]: () => new PcRecService(true),
    [ETab.DynamicFeed]: () => new DynamicFeedRecService(getDynamicFeedServiceConfig()),
    [ETab.Watchlater]: ({
      existingService
    }) => {
      const {
        watchlaterAddSeparator,
        watchlaterItemsOrder
      } = settings;
      const prevShuffleBvidIndexMap = existingService && existingService instanceof WatchlaterRecService ? existingService.getServiceSnapshot().bvidIndexMap : void 0;
      return new WatchlaterRecService(watchlaterItemsOrder, watchlaterAddSeparator, prevShuffleBvidIndexMap, snapshot(store$2).searchText);
    },
    [ETab.Fav]: () => new FavRecService(getFavServiceConfig()),
    [ETab.Hot]: () => new HotRecService(),
    [ETab.Live]: () => new LiveRecService(),
    [ETab.SpaceUpload]: () => new SpaceUploadService(getSpaceUploadServiceConfig())
  };
  function getServiceFromRegistry(servicesRegistry, tab2) {
    const service = servicesRegistry.val[tab2];
    invariant(service, `servicesRegistry.val[tab=${tab2}] should not be nil`);
    return service;
  }
  const debug$6 = baseDebug.extend("service");
  const recItemUniqer = (item) => item.api === EApiType.Separator ? item.uniqId : lookinto(item, {
    [EApiType.AppRecommend]: (item2) => item2.param,
    [EApiType.PcRecommend]: (item2) => item2.bvid,
    [EApiType.DynamicFeed]: (item2) => item2.modules.module_dynamic.major.archive.bvid,
    [EApiType.Watchlater]: (item2) => item2.bvid,
    [EApiType.Fav]: (item2) => item2.bvid,
    [EApiType.PopularGeneral]: (item2) => item2.bvid,
    [EApiType.PopularWeekly]: (item2) => item2.bvid,
    [EApiType.Rank]: (item2) => item2.uniqId,
    [EApiType.Live]: (item2) => item2.roomid,
    [EApiType.SpaceUpload]: (item2) => item2.bvid
  });
  function concatThenUniq(existing, newItems) {
    return uniqBy([...existing, ...newItems], recItemUniqer);
  }
  const usePcApi = (tab2) => tab2 === ETab.PcRecommend || tab2 === ETab.KeepFollowOnly;
  async function fetchMinCount(count, fetcherOptions, filterMultiplier = 5) {
    const {
      tab: tab2,
      abortSignal,
      servicesRegistry
    } = fetcherOptions;
    let items = [];
    let hasMore = true;
    const addMore = async (restCount) => {
      let cur = [];
      if (!REC_TABS.includes(tab2)) {
        const service = getServiceFromRegistry(servicesRegistry, tab2);
        cur = await service.loadMore(abortSignal) || [];
        hasMore = service.hasMore;
        cur = filterRecItems(cur, tab2);
        items = concatThenUniq(items, cur);
        return;
      }
      let times2;
      if (tab2 === ETab.KeepFollowOnly) {
        times2 = 8;
        debug$6("getMinCount: addMore(restCount = %s) times=%s", restCount, times2);
      } else {
        const pagesize = usePcApi(tab2) ? PcRecService.PAGE_SIZE : AppRecService.PAGE_SIZE;
        const multipler = anyFilterEnabled(tab2) ? filterMultiplier : 1.2;
        times2 = Math.ceil(restCount * multipler / pagesize);
        debug$6("getMinCount: addMore(restCount = %s) multipler=%s pagesize=%s times=%s", restCount, multipler, pagesize, times2);
      }
      if (usePcApi(tab2)) {
        const service = getServiceFromRegistry(servicesRegistry, tab2);
        cur = await service.loadMoreBatch(times2, abortSignal) || [];
        hasMore = service.hasMore;
      } else {
        const service = getServiceFromRegistry(servicesRegistry, ETab.AppRecommend);
        cur = await (service.config.addOtherTabContents ? service.loadMore(abortSignal) : service.loadMoreBatch(abortSignal, times2)) || [];
        hasMore = service.hasMore;
      }
      cur = filterRecItems(cur, tab2);
      items = concatThenUniq(items, cur);
    };
    await addMore(count);
    while (true) {
      if (abortSignal == null ? void 0 : abortSignal.aborted) {
        debug$6("getMinCount: break for abortSignal");
        break;
      }
      if (!hasMore) {
        debug$6("getMinCount: break for tab=%s hasMore=false", tab2);
        break;
      }
      const len = items.filter((x) => x.api !== EApiType.Separator).length;
      if (len >= count) break;
      await addMore(count - items.length);
    }
    return items;
  }
  async function refreshForHome(fetcherOptions) {
    let items = await fetchMinCount(getColumnCount(void 0, false) * 2, fetcherOptions, 5);
    if (fetcherOptions.tab === ETab.Watchlater) {
      items = items.slice(0, 20);
    }
    return items;
  }
  const getGridRefreshCount = () => getColumnCount() * 4;
  async function refreshForGrid(fetcherOptions) {
    let minCount = getGridRefreshCount();
    if (fetcherOptions.tab === ETab.DynamicFeed) {
      const service = getServiceFromRegistry(fetcherOptions.servicesRegistry, ETab.DynamicFeed);
      if (await service.shouldReduceMinCount()) {
        minCount = 1;
      }
    }
    return fetchMinCount(minCount, fetcherOptions, 5);
  }
  const OnRefreshContext = H.createContext(void 0);
  function useOnRefreshContext() {
    return H.useContext(OnRefreshContext);
  }
  function useRefresh({
    tab: tab2,
    servicesRegistry,
    debug: debug2,
    fetcher,
    preAction,
    postAction,
    updateExtraInfo
  }) {
    const hasMoreBox = useRefStateBox(true);
    const itemsBox = useRefStateBox([]);
    H.useEffect(() => setGlobalGridItems(itemsBox.state), [itemsBox.state]);
    const refreshingBox = useRefStateBox(false);
    const refreshTsBox = useRefStateBox(() => Date.now());
    const [refreshAbortController, setRefreshAbortController] = H.useState(() => new AbortController());
    const [showSkeleton, setShowSkeleton] = H.useState(false);
    const [error, setError] = H.useState(void 0);
    const [beforeMount, setBeforeMount] = H.useState(true);
    useMount(() => {
      setBeforeMount(false);
      refresh(true);
    });
    useUnmount(() => {
      refreshAbortController.abort();
    });
    const refresh = useMemoizedFn(async (reuse = false) => {
      const start = performance.now();
      const stack = new DisposableStackPolyfill();
      if (refreshingBox.val) {
        let s2;
        const debugSameTabConditionsChange = () => debug2("refresh(): tab=%s [start], current refreshing, sametab but conditions change, abort existing", tab2);
        if (tab2 === ETab.DynamicFeed && (s2 = servicesRegistry.val[ETab.DynamicFeed]) && !isEqual(s2.config, getDynamicFeedServiceConfig())) {
          debugSameTabConditionsChange();
          refreshAbortController.abort();
        } else if (tab2 === ETab.Fav && (s2 = servicesRegistry.val[ETab.Fav]) && !isEqual(s2.config, getFavServiceConfig())) {
          debugSameTabConditionsChange();
          refreshAbortController.abort();
        } else if (tab2 === ETab.Hot && (s2 = servicesRegistry.val[ETab.Hot]) && s2.subtab !== hotStore.subtab) {
          debug2("refresh(): tab=%s [start], current refreshing, sametab but subtab changed, abort existing", tab2);
          refreshAbortController.abort();
        } else {
          debug2("refresh() tab=%s [start], current refreshing, prevent same tab refresh()", tab2);
          return;
        }
      } else {
        debug2("refresh(): tab=%s [start]", tab2);
      }
      refreshTsBox.set(Date.now());
      refreshingBox.set(true);
      setError(void 0);
      itemsBox.set([]);
      hasMoreBox.set(true);
      stack.defer(() => {
        refreshingBox.set(false);
        hasMoreBox.set(getServiceFromRegistry(servicesRegistry, tab2).hasMore);
      });
      await (preAction == null ? void 0 : preAction());
      const _abortController = new AbortController();
      const _signal = _abortController.signal;
      setRefreshAbortController(_abortController);
      const onError = (err) => {
        refreshingBox.set(false);
        hasMoreBox.set(false);
        console.error(err);
        setError(err);
      };
      const doFetch = async () => {
        let currentItems = [];
        let err;
        const fetcherOptions = {
          tab: tab2,
          abortSignal: _signal,
          servicesRegistry
        };
        try {
          currentItems = await fetcher(fetcherOptions);
        } catch (e2) {
          err = e2;
        }
        if (_signal.aborted) {
          debug2("refresh(): tab=%s [aborted], ignoring rest code", tab2);
          return;
        }
        if (err) return onError(err);
        itemsBox.set(currentItems);
        return true;
      };
      let willRefresh;
      const existingService = reuse ? servicesRegistry.val[tab2] : void 0;
      if (existingService) {
        existingService.restore();
        itemsBox.set(existingService.qs.bufferQueue.slice(0, getGridRefreshCount()));
        const success = !!await doFetch();
        willRefresh = success && !!TabConfig[tab2].swr;
      } else {
        setShowSkeleton(true);
        stack.defer(() => {
          setShowSkeleton(false);
        });
        willRefresh = true;
      }
      if (willRefresh) {
        const [err, service] = tryit(() => createServiceMap[tab2]({
          existingService
        }))();
        if (err) return onError(err);
        servicesRegistry.set({
          ...servicesRegistry.val,
          [tab2]: service
        });
        updateExtraInfo == null ? void 0 : updateExtraInfo();
        const success = await doFetch();
        if (!success) return;
      }
      stack.dispose();
      await (postAction == null ? void 0 : postAction());
      const cost = performance.now() - start;
      debug2("refresh(): tab=%s [success] cost %s ms", tab2, cost.toFixed(0));
    });
    return {
      itemsBox,
      error,
      refresh,
      hasMoreBox,
      refreshingBox,
      refreshTsBox,
      refreshAbortController,
      showSkeleton,
      beforeMount
    };
  }
  const clsIconSize = "size-16px";
  const FavItemsOrderConfig = {
    [FavItemsOrder.Initial]: {
      icon: /* @__PURE__ */ jsx$1(IconForDefaultOrder, { className: clsIconSize }),
      label: "初始顺序"
    },
    [FavItemsOrder.Shuffle]: {
      icon: /* @__PURE__ */ jsx$1(IconForShuffle, { className: clsIconSize }),
      label: "随机顺序"
    },
    [FavItemsOrder.PubTimeDesc]: {
      icon: /* @__PURE__ */ jsx$1(IconForTimestamp, { className: clsIconSize }),
      label: withDescIcon("最新投稿")
    },
    [FavItemsOrder.PubTimeAsc]: {
      icon: /* @__PURE__ */ jsx$1(IconForTimestamp, { className: clsIconSize }),
      label: withAscIcon("最早投稿")
    },
    [FavItemsOrder.PlayCountDesc]: {
      icon: /* @__PURE__ */ jsx$1(IconForPlayer, { className: clsIconSize }),
      label: withDescIcon("最多播放")
    },
    [FavItemsOrder.CollectCountDesc]: {
      icon: /* @__PURE__ */ jsx$1(IconForFav, { className: clsx(clsIconSize, "mt--1px") }),
      label: withDescIcon("最多收藏")
    },
    [FavItemsOrder.FavTimeDesc]: {
      icon: /* @__PURE__ */ jsx$1(IconForFav, { className: clsx(clsIconSize, "mt--1px") }),
      label: withDescIcon("最近收藏")
    },
    [FavItemsOrder.FavTimeAsc]: {
      icon: /* @__PURE__ */ jsx$1(IconForFav, { className: clsx(clsIconSize, "mt--1px") }),
      label: withAscIcon("最早收藏")
    }
  };
  const MenuItemsConfig = {
    "all": [FavItemsOrder.Initial, FavItemsOrder.Shuffle],
    "fav-folder": [FavItemsOrder.FavTimeDesc, FavItemsOrder.PubTimeDesc, FavItemsOrder.PlayCountDesc, FavItemsOrder.CollectCountDesc, "divider", FavItemsOrder.FavTimeAsc, FavItemsOrder.PubTimeAsc, "divider", FavItemsOrder.Shuffle],
    "fav-collection": [FavItemsOrder.Initial, FavItemsOrder.PubTimeDesc, FavItemsOrder.PlayCountDesc, FavItemsOrder.CollectCountDesc, "divider", FavItemsOrder.PubTimeAsc, "divider", FavItemsOrder.Shuffle]
  };
  function _getSelectedKeyPrefix(selectedKey) {
    const prefix2 = selectedKey.split(":")[0];
    return prefix2;
  }
  function getMenuItemsFor(selectedKey) {
    const prefix2 = _getSelectedKeyPrefix(selectedKey);
    return MenuItemsConfig[prefix2] || Object.values(FavItemsOrder);
  }
  function _getFallbackOrder(selectedKey) {
    const prefix2 = _getSelectedKeyPrefix(selectedKey);
    if (prefix2 === "fav-folder") return FavItemsOrder.FavTimeDesc;
    if (prefix2 === "fav-collection") return FavItemsOrder.PubTimeDesc;
    return FavItemsOrder.Initial;
  }
  function getSavedOrder(selectedKey, savedOrderMap) {
    const allowed = getMenuItemsFor(selectedKey).filter((x) => x !== "divider");
    const current = savedOrderMap.get(selectedKey) || _getFallbackOrder(selectedKey);
    if (allowed.includes(current)) return current;
    return _getFallbackOrder(selectedKey);
  }
  function useSavedOrder(selectedKey, savedOrderMap) {
    return H.useMemo(() => getSavedOrder(selectedKey, savedOrderMap), [savedOrderMap, selectedKey]);
  }
  function FavItemsOrderSwitcher() {
    const onRefresh = useOnRefreshContext();
    const {
      ref,
      getPopupContainer
    } = usePopupContainer();
    const {
      selectedKey,
      savedOrderMap
    } = useSnapshot(favStore);
    const value = useSavedOrder(selectedKey, savedOrderMap);
    const menuItems = H.useMemo(() => getMenuItemsFor(selectedKey), [selectedKey]);
    return /* @__PURE__ */ jsx$1(GenericOrderSwitcher, { value, onChange: async (next2) => {
      favStore.savedOrderMap.set(selectedKey, next2);
      await delay(100);
      onRefresh == null ? void 0 : onRefresh();
    }, list: menuItems, listDisplayConfig: FavItemsOrderConfig, $ref: ref, dropdownProps: {
      getPopupContainer
    } });
  }
  const UserFavService = {
    removeFav,
    addFav,
    getVideoFavState
  };
  async function removeFav(folderId, resource) {
    const form = new URLSearchParams({
      resources: resource,
      media_id: folderId.toString(),
      platform: "web",
      csrf: getCsrfToken()
    });
    const res = await request.post("/x/v3/fav/resource/batch-del", form);
    const json = res.data;
    const success = isWebApiSuccess(json);
    if (!success) {
      toast(json.message || OPERATION_FAIL_MSG);
    }
    return success;
  }
  async function getVideoFavState(avid) {
    if (!getHasLogined()) return;
    const res = await request.get("/x/v3/fav/folder/created/list-all", {
      params: {
        up_mid: getUid(),
        type: 2,
        rid: avid
      }
    });
    const json = res.data;
    const favFolders = json.data.list.filter((folder) => folder.fav_state > 0);
    const favFolderNames = favFolders.map((f2) => f2.title);
    const favFolderUrls = favFolders.map((f2) => formatFavFolderUrl(f2.id));
    return {
      favFolders,
      favFolderNames,
      favFolderUrls
    };
  }
  async function favDeal({
    avid,
    add_media_ids = "",
    del_media_ids = ""
  }) {
    const form = new URLSearchParams({
      rid: avid.toString(),
      type: "2",
      add_media_ids,
      del_media_ids,
      platform: "web",
      eab_x: "2",
      ramval: "0",
      ga: "1",
      gaia_source: "web_normal",
      csrf: getCsrfToken()
    });
    const res = await request.post("/x/v3/fav/resource/deal", form);
    const json = res.data;
    const success = isWebApiSuccess(json);
    if (!success) {
      toast((json == null ? void 0 : json.message) || "fav deal api fail");
    }
    return success;
  }
  let defaultFavFolderId = 0;
  let defaultFavFolderName = "";
  async function addFav(avid) {
    if (!defaultFavFolderId || !defaultFavFolderName) {
      const folders = await fetchFavFolder();
      defaultFavFolderId = folders[0].id;
      defaultFavFolderName = folders[0].title;
    }
    return await favDeal({
      avid,
      add_media_ids: defaultFavFolderId.toString()
    });
  }
  async function fetchFavFolder() {
    const res = await request.get("/x/v3/fav/folder/created/list-all", {
      params: {
        up_mid: getUid()
      }
    });
    const json = res.data;
    const folders = json.data.list;
    return folders;
  }
  const debug$5 = baseDebug.extend("modules:rec-services:fav:store");
  var FavQueryKey = /* @__PURE__ */ ((FavQueryKey2) => {
    FavQueryKey2["CollectionIdFull"] = "fav-collection-id";
    FavQueryKey2["CollectionId"] = "fav-cid";
    FavQueryKey2["FolderIdFull"] = "fav-folder-id";
    FavQueryKey2["FolderId"] = "fav-fid";
    return FavQueryKey2;
  })(FavQueryKey || {});
  const parseId = (text) => {
    if (!text) return;
    const num = Number(text);
    if (isNaN(num)) return;
    return num;
  };
  const searchParams = new URLSearchParams(location.search);
  const QUERY_FAV_COLLECTION_ID = parseId(searchParams.get(
    "fav-collection-id"
    /* CollectionIdFull */
  ) ?? searchParams.get(
    "fav-cid"
    /* CollectionId */
  ));
  const QUERY_FAV_FOLDER_ID = parseId(searchParams.get(
    "fav-folder-id"
    /* FolderIdFull */
  ) ?? searchParams.get(
    "fav-fid"
    /* FolderId */
  ));
  const SHOW_FAV_TAB_ONLY = IN_BILIBILI_HOMEPAGE && (typeof QUERY_FAV_FOLDER_ID === "number" || typeof QUERY_FAV_COLLECTION_ID === "number");
  const favStore = proxy({
    // methods
    updateList,
    favFolders: [],
    favFoldersUpdateAt: 0,
    selectedFavFolderId: QUERY_FAV_FOLDER_ID,
    get selectedFavFolder() {
      if (typeof this.selectedFavFolderId !== "number") return;
      return this.favFolders.find((x) => x.id === this.selectedFavFolderId);
    },
    favCollections: [],
    favCollectionsUpdateAt: 0,
    selectedFavCollectionId: QUERY_FAV_COLLECTION_ID,
    selectedFavCollectionDetailInfo: void 0,
    get selectedFavCollection() {
      if (typeof this.selectedFavCollectionId !== "number") return;
      return this.favCollections.find((x) => x.id === this.selectedFavCollectionId);
    },
    get selectedKey() {
      let prefix2;
      let id;
      if (typeof this.selectedFavFolderId !== "undefined") {
        prefix2 = "fav-folder";
        id = this.selectedFavFolderId;
      } else if (typeof this.selectedFavCollectionId !== "undefined") {
        prefix2 = "fav-collection";
        id = this.selectedFavCollectionId;
      } else {
        return "all";
      }
      return `${prefix2}:${id}`;
    },
    get selectedLabel() {
      if (this.selectedFavFolder) {
        return `${this.selectedFavFolder.title} (${this.selectedFavFolder.media_count})`;
      }
      if (typeof this.selectedFavCollectionId === "number") {
        if (this.selectedFavCollection) {
          return `${this.selectedFavCollection.title} (${this.selectedFavCollection.media_count})`;
        }
        const info = this.selectedFavCollectionDetailInfo;
        if ((info == null ? void 0 : info.id) === this.selectedFavCollectionId) {
          return `${info.title} (${info.media_count})`;
        }
        return;
      }
      return "全部";
    },
    // 保存的顺序
    savedOrderMap: (await( proxyMapWithGmStorage("fav-saved-order"))).map,
    get usingShuffle() {
      const curret = getSavedOrder(this.selectedKey, this.savedOrderMap);
      return curret === FavItemsOrder.Shuffle;
    }
  });
  async function setupFavStore() {
    if (!IN_BILIBILI_HOMEPAGE) return;
    if (SHOW_FAV_TAB_ONLY) return;
    const storageKey2 = "fav-store";
    const persistStoreKeys = ["selectedFavFolderId", "selectedFavCollectionId"];
    const val = await GM.getValue(storageKey2);
    if (val) {
      const picked = pick$1(val, persistStoreKeys);
      for (const key of persistStoreKeys) {
        favStore[key] = picked[key];
      }
    }
    const runInSequence = pLimit(1);
    subscribeOnKeys(favStore, persistStoreKeys, (snap) => {
      if (SHOW_FAV_TAB_ONLY) return;
      const val2 = pick$1(snap, persistStoreKeys);
      runInSequence(async () => {
        await GM.setValue(storageKey2, val2);
      });
    });
  }
  function updateFavFolderMediaCount(targetFavFolderId, count) {
    const folder = favStore.favFolders.find((x) => x.id === targetFavFolderId);
    if (!folder) return;
    const newCount = typeof count === "function" ? count(folder.media_count) : count;
    if (newCount !== folder.media_count) {
      folder.media_count = newCount;
      debug$5("update folder(id=%s title=%s) media_count to %s", folder.id, folder.title, newCount);
    }
  }
  async function updateList(force = false) {
    return Promise.all([updateFolderList(force), updateCollectionList(force)]);
  }
  const _updateFolderList = reusePendingPromise(async () => {
    const folders = await fetchFavFolder();
    favStore.favFolders = folders;
    favStore.favFoldersUpdateAt = Date.now();
  });
  async function updateFolderList(force = false) {
    if (force) return;
    const {
      favFolders,
      favFoldersUpdateAt
    } = favStore;
    if (favFolders.length && favFoldersUpdateAt && Date.now() - favFoldersUpdateAt < ms("5min")) {
      return;
    }
    return _updateFolderList();
  }
  const _updateCollectionList = reusePendingPromise(async () => {
    const collections = await fetchAllFavCollections();
    favStore.favCollections = collections;
    favStore.favCollectionsUpdateAt = Date.now();
  });
  async function updateCollectionList(force = false) {
    if (force) return;
    const {
      favCollections,
      favCollectionsUpdateAt
    } = favStore;
    if (favCollections.length && favCollectionsUpdateAt && Date.now() - favCollectionsUpdateAt < ms("5min")) {
      return;
    }
    return _updateCollectionList();
  }
  if (SHOW_FAV_TAB_ONLY) {
    subscribeKey(favStore, "selectedLabel", () => {
      if (!favStore.selectedLabel) return;
      setPageTitle(favStore.selectedLabel);
    });
  }
  setupFavStore();
  const videoSourceTabState = await( proxyWithGmStorage({
    value: ETab.AppRecommend
  }, `video-source-tab`));
  if (SHOW_DYNAMIC_FEED_ONLY) {
    videoSourceTabState.value = ETab.DynamicFeed;
  }
  if (SHOW_FAV_TAB_ONLY) {
    videoSourceTabState.value = ETab.Fav;
  }
  if (SHOW_SPACE_UPLOAD_ONLY) {
    videoSourceTabState.value = ETab.SpaceUpload;
  }
  function getSortedTabKeys(customTabKeysOrder) {
    return CONFIGURABLE_TAB_KEYS.slice().sort((a2, b) => {
      let aIndex = customTabKeysOrder.indexOf(a2);
      let bIndex = customTabKeysOrder.indexOf(b);
      if (aIndex === -1) aIndex = ALL_TAB_KEYS.indexOf(a2);
      if (bIndex === -1) bIndex = ALL_TAB_KEYS.indexOf(b);
      return aIndex - bIndex;
    });
  }
  function useSortedTabKeys() {
    const {
      customTabKeysOrder
    } = useSettingsSnapshot();
    return H.useMemo(() => getSortedTabKeys(customTabKeysOrder), [customTabKeysOrder]);
  }
  function useCurrentDisplayingTabKeys() {
    const {
      hidingTabKeys,
      customTabKeysOrder
    } = useSettingsSnapshot();
    const logined = useHasLogined();
    const keys = H.useMemo(() => {
      const tabkeys = getSortedTabKeys(customTabKeysOrder);
      return tabkeys.filter((key) => {
        if (key === ETab.AppRecommend && !logined) {
          return true;
        }
        if (key === ETab.DynamicFeed && SHOW_DYNAMIC_FEED_ONLY) {
          return true;
        }
        if (key === ETab.Fav && SHOW_FAV_TAB_ONLY) {
          return true;
        }
        if (key === ETab.SpaceUpload && !SHOW_SPACE_UPLOAD_ONLY) {
          return false;
        }
        return !hidingTabKeys.includes(key);
      });
    }, [hidingTabKeys, customTabKeysOrder, logined]);
    if (SHOW_DYNAMIC_FEED_ONLY && keys.includes(ETab.DynamicFeed)) {
      return [ETab.DynamicFeed];
    }
    if (SHOW_FAV_TAB_ONLY && keys.includes(ETab.Fav)) {
      return [ETab.Fav];
    }
    if (SHOW_SPACE_UPLOAD_ONLY) {
      return [ETab.SpaceUpload];
    }
    return keys;
  }
  function useCurrentDisplayingTabConfigList() {
    const keys = useCurrentDisplayingTabKeys();
    return H.useMemo(() => keys.map((key) => ({
      key,
      ...TabConfig[key]
    })), [keys]);
  }
  function useCurrentUsingTab() {
    const tab2 = useSnapshot(videoSourceTabState).value;
    const displayTabKeys = useCurrentDisplayingTabKeys();
    const logined = useHasLogined();
    const fallbackTab = ETab.AppRecommend;
    if (!displayTabKeys.includes(tab2)) return fallbackTab;
    if (!logined) {
      if (!TabConfig[tab2].anonymousUsage) {
        return fallbackTab;
      }
    }
    return tab2;
  }
  const radioBtnCss = {
    name: "700njw",
    styles: "height:32px;line-height:unset;&:has(:focus-visible){outline:none;outline-offset:unset;}>.ant-radio-button+span{height:100%;}"
  };
  function VideoSourceTab({
    onRefresh
  }) {
    const logined = useHasLogined();
    const tab2 = useCurrentUsingTab();
    const currentTabConfigList = useCurrentDisplayingTabConfigList();
    const {
      __internalRecTabRenderAsSegments
    } = useSettingsSnapshot();
    const onChangeTab = useMemoizedFn((newTab) => {
      if (!logined) {
        if (!TabConfig[newTab].anonymousUsage) {
          if (!checkLoginStatus()) {
            return toastNeedLogin();
          }
        }
      }
      videoSourceTabState.value = newTab;
    });
    const renderAsRadio = /* @__PURE__ */ jsx$1(antd.Radio.Group, { optionType: "button", buttonStyle: "solid", size: "middle", value: tab2, className: "inline-flex items-center overflow-hidden", onFocus: (e2) => {
      const target = e2.target;
      target.blur();
    }, onChange: async (e2) => {
      const newValue = e2.target.value;
      onChangeTab(newValue);
    }, children: currentTabConfigList.map(({
      key,
      label
    }) => /* @__PURE__ */ jsx$1(
      antd.Radio.Button,
      {
        css: radioBtnCss,
        className: "video-source-tab",
        tabIndex: -1,
        value: key,
        children: /* @__PURE__ */ jsxs("span", { className: "h-full flex items-center line-height-unset", children: [
          /* @__PURE__ */ jsx$1(TabIcon, { tabKey: key, className: "mr-4px", active: key === tab2 }),
          label
        ] })
      },
      key
    )) });
    let renderAsSegment;
    {
      const options = H.useMemo(() => {
        return currentTabConfigList.map(({
          key,
          label
        }) => {
          return {
            value: key,
            label: /* @__PURE__ */ jsxs("div", { className: "flex items-center gap-x-6px", children: [
              /* @__PURE__ */ jsx$1(TabIcon, { tabKey: key, active: key === tab2 }),
              label
            ] })
          };
        });
      }, [currentTabConfigList, tab2]);
      renderAsSegment = /* @__PURE__ */ jsx$1(antd.Segmented, { size: "middle", options, value: tab2, onChange: onChangeTab });
    }
    return /* @__PURE__ */ jsxs("div", { className: "flex-v-center", children: [
      __internalRecTabRenderAsSegments ? renderAsSegment : renderAsRadio,
      /* @__PURE__ */ jsx$1(HelpInfo, { className: "size-16px ml-6px", children: /* @__PURE__ */ jsx$1(Fragment, { children: currentTabConfigList.map(({
        key,
        label,
        desc,
        extraHelpInfo: extraHelpInfo2
      }) => /* @__PURE__ */ jsxs(H.Fragment, { children: [
        /* @__PURE__ */ jsxs("div", { className: "flex items-center h-22px", children: [
          /* @__PURE__ */ jsx$1(TabIcon, { tabKey: key, className: "mr-4px", active: true }),
          label,
          ": ",
          desc
        ] }),
        !!extraHelpInfo2 && extraHelpInfo2
      ] }, key)) }) })
    ] });
  }
  function isEmptyFragment(fragment) {
    const fragChildren = H.Children.toArray(fragment.props.children);
    return !fragChildren.length;
  }
  function Picture({
    src,
    avif,
    webp,
    imgProps,
    className,
    ...props
  }) {
    avif ?? (avif = !isSafari);
    webp ?? (webp = true);
    return /* @__PURE__ */ jsxs("picture", { className: clsx("w-full h-full object-cover", className), ...props, children: [
      avif && /* @__PURE__ */ jsx$1("source", { srcSet: `${src}.avif`, type: "image/avif" }),
      webp && /* @__PURE__ */ jsx$1("source", { srcSet: `${src}.webp`, type: "image/webp" }),
      /* @__PURE__ */ jsx$1("img", { src, loading: "lazy", className: "block w-full h-full", ...imgProps })
    ] });
  }
  const debug$4 = baseDebug.extend("VideoCard:LargePreview");
  const DirectionConfig = {
    right: {
      multiplier: 1,
      axis: "x",
      reverse: "left"
    },
    left: {
      multiplier: -1,
      axis: "x",
      reverse: "right"
    },
    bottom: {
      multiplier: 1,
      axis: "y",
      reverse: "top"
    },
    top: {
      multiplier: -1,
      axis: "y",
      reverse: "bottom"
    }
  };
  const VisualPadding = {
    border: 40,
    card: 10
  };
  function getCoverRectDefaultImpl(placeholder) {
    var _a2, _b2, _c2, _d2;
    return (
      // Bilibili-Gate card
      ((_b2 = (_a2 = placeholder.closest(`.${APP_CLS_CARD}`)) == null ? void 0 : _a2.querySelector(`.${APP_CLS_CARD_COVER}`)) == null ? void 0 : _b2.getBoundingClientRect()) ?? // bilibili.com default card
      ((_d2 = (_c2 = placeholder.closest(".bili-video-card")) == null ? void 0 : _c2.querySelector(".bili-video-card__image")) == null ? void 0 : _d2.getBoundingClientRect())
    );
  }
  const LargePreview = H.forwardRef(({
    children,
    aspectRatio = 1.7777777777777777,
    getCoverRect = getCoverRectDefaultImpl,
    ...restProps
  }, forwardedRef) => {
    const placeholderRef = H.useRef(null);
    const popoverRef = useMixedRef(forwardedRef);
    const [visible, setVisible] = H.useState(false);
    const [position2, setPosition] = H.useState(void 0);
    const hide = useMemoizedFn(() => {
      setVisible(false);
      setPosition(void 0);
    });
    const calculatePostion = useMemoizedFn(() => {
      const placeholder = placeholderRef.current;
      if (!placeholder) return hide();
      const cardCoverRect = getCoverRect(placeholder);
      if (!cardCoverRect) return hide();
      const viewportWidth = document.documentElement.clientWidth;
      const viewportHeight = document.documentElement.clientHeight;
      const tolerance = 40;
      if (cardCoverRect.top > viewportHeight - tolerance || cardCoverRect.bottom < 0 + tolerance || cardCoverRect.left > viewportWidth - tolerance || cardCoverRect.right < 0 + tolerance) {
        return hide();
      }
      const possibleBoundingBox = {
        top: {
          x: 0,
          y: 0,
          width: viewportWidth,
          height: cardCoverRect.top
        },
        bottom: {
          x: 0,
          y: cardCoverRect.bottom,
          width: viewportWidth,
          height: viewportHeight - cardCoverRect.bottom
        },
        left: {
          x: 0,
          y: 0,
          width: cardCoverRect.left,
          height: viewportHeight
        },
        right: {
          x: cardCoverRect.right,
          y: 0,
          width: viewportWidth - cardCoverRect.right,
          height: viewportHeight
        }
      };
      const getScaleInBox = (bbox2) => {
        const w = aspectRatio;
        const h = 1;
        const scaleX = bbox2.width / w;
        const scaleY = bbox2.height / h;
        const scale2 = Math.min(scaleX, scaleY);
        return {
          scale: scale2,
          scaleLimit: scaleX > scaleY ? "height" : "width"
        };
      };
      const picked = orderBy(Object.entries(possibleBoundingBox).map(([direction2, bbox2]) => ({
        direction: direction2,
        bbox: bbox2,
        ...getScaleInBox(bbox2)
      })), ["scale", (x) => {
        switch (x.direction) {
          case "top":
            return cardCoverRect.top;
          case "bottom":
            return viewportHeight - cardCoverRect.bottom;
          case "left":
            return cardCoverRect.left;
          case "right":
            return viewportWidth - cardCoverRect.right;
        }
      }], ["desc", "desc"])[0];
      debug$4("picked direction", picked);
      const {
        direction,
        bbox,
        scale,
        scaleLimit
      } = picked;
      let elWidth;
      let elHeight;
      if (scaleLimit === "width") {
        elWidth = Math.floor(bbox.width - (VisualPadding.card + VisualPadding.border));
        elHeight = elWidth / aspectRatio;
      } else if (scaleLimit === "height") {
        elHeight = Math.floor(bbox.height - (VisualPadding.card + VisualPadding.border));
        elWidth = elHeight * aspectRatio;
      } else {
        throw new Error("unexpected scaleLimit");
      }
      let elPosX = 0;
      let elPosY = 0;
      let arrowTop = 0;
      let arrowLeft = 0;
      const setArrowTop = () => {
        arrowTop = cardCoverRect.y + cardCoverRect.height / 2 - elPosY;
      };
      const setArrowLeft = () => {
        arrowLeft = cardCoverRect.x + cardCoverRect.width / 2 - elPosX;
      };
      const fixX = () => {
        if (elPosX < VisualPadding.border) {
          elPosX = VisualPadding.border;
          return;
        }
        if (elPosX + elWidth > viewportWidth - VisualPadding.border) {
          elPosX = viewportWidth - VisualPadding.border - elWidth;
          return;
        }
      };
      const fixY = () => {
        if (elPosY < VisualPadding.border) {
          elPosY = VisualPadding.border;
          return;
        }
        if (elPosY + elHeight > viewportHeight - VisualPadding.border) {
          elPosY = viewportHeight - VisualPadding.border - elHeight;
          return;
        }
      };
      switch (direction) {
        case "top":
          elPosX = cardCoverRect.x + cardCoverRect.width / 2 - elWidth / 2;
          elPosY = cardCoverRect.top - VisualPadding.card - elHeight;
          fixX();
          setArrowLeft();
          break;
        case "bottom":
          elPosX = cardCoverRect.x + cardCoverRect.width / 2 - elWidth / 2;
          elPosY = cardCoverRect.bottom + VisualPadding.card;
          fixX();
          setArrowLeft();
          break;
        case "right":
          elPosX = cardCoverRect.right + VisualPadding.card;
          elPosY = cardCoverRect.y + cardCoverRect.height / 2 - elHeight / 2;
          fixY();
          setArrowTop();
          break;
        case "left":
          elPosX = cardCoverRect.left - VisualPadding.card - elWidth;
          elPosY = cardCoverRect.y + cardCoverRect.height / 2 - elHeight / 2;
          fixY();
          setArrowTop();
          break;
      }
      elPosX = Math.floor(elPosX);
      elPosY = Math.floor(elPosY);
      setVisible(true);
      setPosition({
        direction,
        elWidth,
        elHeight,
        elPosX,
        elPosY,
        arrowTop,
        arrowLeft
      });
    });
    const calculatePostionThrottled = H.useMemo(() => throttle$1(calculatePostion, 100), [calculatePostion]);
    useMount(calculatePostionThrottled);
    useEventListener("resize", calculatePostionThrottled, {
      target: window
    });
    useEventListener("scroll", calculatePostionThrottled, {
      target: window
    });
    const {
      useScale
    } = useSettingsSnapshot().videoCard.videoPreview;
    const animationDuration = useScale ? 0.2 : 0.3;
    const initial = H.useMemo(() => {
      const direction = position2 == null ? void 0 : position2.direction;
      if (!direction) return;
      const {
        axis,
        multiplier,
        reverse
      } = DirectionConfig[direction];
      if (!useScale) {
        let animateDistance = 30;
        if (direction === "top") animateDistance = 20;
        if (axis === "x") {
          return {
            x: -multiplier * animateDistance,
            y: 0
          };
        } else {
          return {
            x: 0,
            y: -multiplier * animateDistance
          };
        }
      } else {
        if (axis === "x") {
          return {
            scale: 0.5,
            transformOrigin: `${reverse} ${position2.arrowTop}px`
          };
        } else {
          return {
            scale: 0.5,
            transformOrigin: `${position2.arrowLeft}px ${reverse}`
          };
        }
      }
    }, [position2, useScale]);
    const placeholderEl = /* @__PURE__ */ jsx$1("div", { ref: placeholderRef, "data-role": "video-card-descendant" });
    const popoverEl = /* @__PURE__ */ jsx$1("div", { ...restProps, ref: popoverRef, css: [/* @__PURE__ */ css("display:", visible ? "block" : "none", ";", ""), position2 && /* @__PURE__ */ css("position:fixed;z-index:", zIndexVideoCardLargePreview, ";width:", position2.elWidth, "px;height:", position2.elHeight, "px;top:", position2.elPosY, "px;left:", position2.elPosX, "px;", ""), "", ""], children: visible && /* @__PURE__ */ jsxs(framerMotion.motion.div, { className: "relative h-100%", initial: {
      opacity: 0,
      ...initial
    }, animate: {
      opacity: 1,
      x: 0,
      y: 0,
      scale: 1
    }, transition: {
      bounce: false,
      duration: animationDuration
    }, children: [
      (position2 == null ? void 0 : position2.direction) && /* @__PURE__ */ jsx$1(PopoverArrow, { size: 7, direction: position2.direction, arrowTop: position2.arrowTop, arrowLeft: position2.arrowLeft }),
      /* @__PURE__ */ jsx$1("div", { className: "h-full overflow-hidden rounded-20px", css: /* @__PURE__ */ css("background-color:rgba(255 255 255 / 0.5);backdrop-filter:blur(10px);box-shadow:0px 0px 1px 1px ", colorPrimaryValue, ";", ""), children })
    ] }) });
    return /* @__PURE__ */ jsxs(Fragment, { children: [
      placeholderEl,
      isSafari ? require$$0.createPortal(popoverEl, document.body) : popoverEl
    ] });
  });
  function PopoverArrow({
    size,
    direction,
    arrowTop,
    arrowLeft
  }) {
    const {
      axis,
      multiplier,
      reverse
    } = DirectionConfig[direction];
    const extra = H.useMemo(() => {
      if (axis === "x") {
        return css`
        ${direction}: 100%;
        margin-${direction}: -1px;
        top: ${arrowTop}px;
        margin-top: -${size / 2}px;
      `;
      } else {
        return css`
        ${direction}: 100%;
        margin-${direction}: -1px;
        left: ${arrowLeft}px;
        margin-left: -${size / 2}px;
      `;
      }
    }, [size, direction, axis, arrowTop, arrowLeft]);
    return /* @__PURE__ */ jsx$1("div", { className: "absolute box-content h-0 w-0", css: [/* @__PURE__ */ css("border:", size, "px solid transparent;", ""), extra, css`
          border-${direction}-color: ${colorPrimaryValue};
        `, "", ""] });
  }
  const store$1 = await( proxyWithGmStorage({
    volume: void 0,
    // A double values must fall between 0 and 1, where 0 is effectively muted and 1 is the loudest possible value.
    muted: void 0
  }, "large-preview-store"));
  const RecoverableVideo = H.forwardRef(({
    currentTimeRef,
    ...videoProps
  }, forwardedRef) => {
    const ref = useMixedRef(forwardedRef);
    const mountedRef = H.useRef(false);
    useMount(() => {
      if (ref.current) {
        if (typeof currentTimeRef.current === "number") {
          ref.current.currentTime = currentTimeRef.current;
        }
        if (typeof store$1.volume === "number") {
          ref.current.volume = store$1.volume;
        }
        if (typeof store$1.muted === "boolean") {
          ref.current.muted = store$1.muted;
        }
      }
      mountedRef.current = true;
    });
    const onTimeUpdate = useMemoizedFn(() => {
      var _a2;
      if (!mountedRef.current) return;
      currentTimeRef.current = (_a2 = ref.current) == null ? void 0 : _a2.currentTime;
    });
    const onVolumeChange = useMemoizedFn(() => {
      if (!mountedRef.current) return;
      if (!ref.current) return;
      store$1.volume = ref.current.volume;
      store$1.muted = ref.current.muted;
    });
    return /* @__PURE__ */ jsx$1("video", { ref, ...videoProps, onTimeUpdate, onVolumeChange });
  });
  const iconParkOutlinePin = (props, ref) => /* @__PURE__ */ jsx$1("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref, ...props, children: /* @__PURE__ */ jsx$1("path", { fill: "none", stroke: "currentColor", strokeLinejoin: "round", strokeWidth: 4, d: "M10.696 17.504c2.639-2.638 5.774-2.565 9.182-.696L32.62 9.745l-.721-4.958L43.213 16.1l-4.947-.71l-7.074 12.73c1.783 3.638 1.942 6.544-.697 9.182l-7.778-7.778L6.443 41.556l11.995-16.31z" }) });
  const ForwardRef$k = H.forwardRef(iconParkOutlinePin);
  const iconParkOutlineVideoTwo = (props, ref) => /* @__PURE__ */ jsx$1("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref, ...props, children: /* @__PURE__ */ jsxs("g", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 4, children: [
    /* @__PURE__ */ jsx$1("path", { d: "M39 6H9a3 3 0 0 0-3 3v30a3 3 0 0 0 3 3h30a3 3 0 0 0 3-3V9a3 3 0 0 0-3-3" }),
    /* @__PURE__ */ jsx$1("path", { d: "M20.5 28v-6.062l5.25 3.03L31 28l-5.25 3.031l-5.25 3.031zM6 15h36m-9-9l-6 9m-6-9l-6 9" })
  ] }) });
  const ForwardRef$j = H.forwardRef(iconParkOutlineVideoTwo);
  function clearTimerRef(timerRef) {
    if (typeof timerRef.current === "undefined") return;
    clearTimeout(timerRef.current);
    timerRef.current = void 0;
  }
  function useLargePreviewRelated({
    // videoPreview data
    shouldFetchPreviewData,
    // render ActionButton?
    hasLargePreviewActionButton,
    actionButtonVisible,
    actionButtonProps,
    actionButtonCss,
    // required data
    bvid,
    cid,
    uniqId,
    sharedEmitter,
    // optional
    aspectRatioFromItem,
    cover,
    cardRef
  }) {
    var _a2, _b2, _c2, _d2, _e2;
    const {
      useMp4,
      __internal: {
        preferNormalCdn
      }
    } = useSnapshot(settings.videoCard.videoPreview);
    const videoPreviewDataBox = useRefStateBox(void 0);
    const tryFetchVideoPreviewData = useLockFn(async () => {
      if (!shouldFetchPreviewData) return;
      if (isVideoPreviewDataValid(videoPreviewDataBox.val)) return;
      const data2 = await fetchVideoPreviewData({
        bvid,
        cid,
        useMp4,
        preferNormalCdn,
        aspectRatioFromItem
      });
      videoPreviewDataBox.set(data2);
    });
    useUpdateEffect(() => {
      videoPreviewDataBox.set(void 0);
    }, [useMp4, preferNormalCdn]);
    const $req = useRequest(tryFetchVideoPreviewData, {
      manual: true,
      loadingDelay: 100
      // if request is fast, do not show loading at all
    });
    const [visible, setVisible] = H.useState(false);
    const triggerAction = useRefStateBox(void 0);
    const triggerElement = useRefStateBox(void 0);
    const hideAt = useRefStateBox(void 0);
    const isRecentlyHidden = useMemoizedFn(() => {
      if (!hideAt.val) return false;
      return Date.now() - hideAt.val < 1200;
    });
    const enterTimer = H.useRef(void 0);
    const leaveTimer = H.useRef(void 0);
    const clearTimers = useMemoizedFn(() => {
      clearTimerRef(enterTimer);
      clearTimerRef(leaveTimer);
    });
    const showBy = useMemoizedFn((action2, el) => {
      setVisible(true);
      triggerAction.set(action2);
      triggerElement.set(el);
      sharedEmitter.emit("show-large-preview", uniqId);
      hideAt.set(void 0);
    });
    const hide = useMemoizedFn(() => {
      setVisible(false);
      triggerAction.set(void 0);
      triggerElement.set(void 0);
      hideAt.set(Date.now());
    });
    useMittOn(sharedEmitter, "show-large-preview", (srcUniqId) => {
      if (srcUniqId === uniqId) return;
      clearTimers();
      hide();
    });
    const onMouseEnter = useMemoizedFn((triggerEl) => {
      if (triggerAction.val === "click") return;
      $req.run();
      clearTimers();
      if (triggerEl === "video-card-action-button") {
        enterTimer.current = setTimeout(() => showBy("hover", triggerEl), 200);
      } else {
        showBy("hover", triggerEl);
      }
    });
    const onMouseLeave = useMemoizedFn((triggerEl) => {
      if (triggerAction.val === "click") return;
      clearTimers();
      if (triggerEl === "video-card-action-button") {
        leaveTimer.current = setTimeout(hide, 250);
      } else {
        hide();
      }
    });
    const onClick = useMemoizedFn((el) => {
      clearTimers();
      if (triggerAction.val === "click") {
        hide();
      } else {
        showBy("click", el);
      }
    });
    const getLargePreviewCurrentTime = useMemoizedFn(() => {
      if (!currentTimeRef.current) return;
      return Math.floor(currentTimeRef.current);
    });
    const shouldUseLargePreviewCurrentTime = useMemoizedFn(() => {
      if (visible) return true;
      if (isRecentlyHidden()) return true;
      return false;
    });
    const onOpenInNewTab = useMemoizedFn(() => {
      var _a3;
      if (!bvid) return;
      const u2 = new URL(`https://${BiliDomain.Main}/video/${bvid}`);
      const t2 = getLargePreviewCurrentTime();
      if (t2) u2.searchParams.set("t", t2.toString());
      openNewTab(u2.href);
      (_a3 = videoRef.current) == null ? void 0 : _a3.pause();
      hide();
    });
    const usingAspectRatio = H.useMemo(() => {
      var _a3, _b3;
      return ((_b3 = getRecItemDimension({
        dimensionFromApi: (_a3 = videoPreviewDataBox.state) == null ? void 0 : _a3.dimension
      })) == null ? void 0 : _b3.aspectRatio) ?? aspectRatioFromItem;
    }, [(_a2 = videoPreviewDataBox.state) == null ? void 0 : _a2.dimension]);
    const videoRef = H.useRef(null);
    const currentTimeRef = H.useRef(void 0);
    const largePreviewRef = H.useRef(null);
    const willRenderLargePreview = visible && !!((_c2 = (_b2 = videoPreviewDataBox.state) == null ? void 0 : _b2.playUrls) == null ? void 0 : _c2.length);
    const largePreviewEl = willRenderLargePreview && /* @__PURE__ */ jsxs(LargePreview, { ref: largePreviewRef, aspectRatio: usingAspectRatio, onMouseEnter: (e2) => onMouseEnter("popover"), onMouseLeave: (e2) => onMouseLeave("popover"), children: [
      /* @__PURE__ */ jsx$1(
        RecoverableVideo,
        {
          ref: videoRef,
          currentTimeRef,
          autoPlay: true,
          controls: true,
          loop: true,
          poster: cover,
          className: "size-full object-contain",
          children: (_e2 = (_d2 = videoPreviewDataBox.state) == null ? void 0 : _d2.playUrls) == null ? void 0 : _e2.map((url, i2) => /* @__PURE__ */ jsx$1("source", { src: url }, i2))
        }
      ),
      /* @__PURE__ */ jsxs("div", { className: "absolute right-10px top-10px flex flex-row-reverse items-center justify-start gap-x-5px", children: [
        triggerAction.state === "click" ? /* @__PURE__ */ jsx$1(VideoCardActionButton, { inlinePosition: "right", icon: /* @__PURE__ */ jsx$1(ForwardRef$C, { className: "size-14px" }), tooltip: "关闭", onClick: (e2) => {
          e2.preventDefault();
          e2.stopPropagation();
          hide();
        } }) : /* @__PURE__ */ jsx$1(VideoCardActionButton, { inlinePosition: "right", icon: /* @__PURE__ */ jsx$1(ForwardRef$k, { className: "size-14px" }), tooltip: "固定", onClick: (e2) => {
          e2.preventDefault();
          e2.stopPropagation();
          onClick("popover-action-button");
        } }),
        /* @__PURE__ */ jsx$1(VideoCardActionButton, { inlinePosition: "right", icon: /* @__PURE__ */ jsx$1(ForwardRef$D, { className: "size-14px" }), tooltip: "新窗口打开", onClick: (e2) => {
          e2.preventDefault();
          e2.stopPropagation();
          onOpenInNewTab();
        } })
      ] })
    ] });
    const largePreviewActionButtonEl = hasLargePreviewActionButton && shouldFetchPreviewData && /* @__PURE__ */ jsx$1(VideoCardActionButton, { css: actionButtonCss, ...actionButtonProps, visible: actionButtonVisible, active: willRenderLargePreview, inlinePosition: "right", icon: $req.loading ? /* @__PURE__ */ jsx$1(IconForLoading, { className: "size-16px" }) : /* @__PURE__ */ jsx$1(ForwardRef$j, { className: "size-15px" }), tooltip: triggerAction.state === "click" ? visible ? "关闭浮动预览" : "浮动预览" : "浮动预览", onMouseEnter: (e2) => onMouseEnter("video-card-action-button"), onMouseLeave: (e2) => onMouseLeave("video-card-action-button"), onClick: (e2) => {
      e2.preventDefault();
      e2.stopPropagation();
      onClick("video-card-action-button");
    } }, "video-card-action-button");
    useKeyPress("esc", () => {
      if (shouldDisableShortcut()) return;
      hide();
    }, {
      exactMatch: true
    });
    useClickAway(() => hide(), [
      cardRef ? () => {
        var _a3;
        return (_a3 = cardRef == null ? void 0 : cardRef.current) == null ? void 0 : _a3.closest("." + APP_CLS_CARD);
      } : void 0,
      // click from card
      largePreviewRef
      // click from `LargePreview`, safari 中使用 createPortal 不再是 card descendant
    ].filter(Boolean));
    useEventListener("fullscreenchange", () => {
      if (!document.fullscreenElement) return;
      if (!visible || triggerAction.val === "click") return;
      if (document.fullscreenElement === videoRef.current) {
        showBy("click", "popover-video-fullscreen-button");
      }
    }, {
      target: document
    });
    return {
      largePreviewActionButtonEl,
      largePreviewEl,
      getLargePreviewCurrentTime,
      shouldUseLargePreviewCurrentTime,
      largePreviewVisible: visible,
      hideLargePreview: hide
    };
  }
  const c = tweakLightness(colorPrimaryValue, 0.1);
  const Styles = {
    normalBorder: /* @__PURE__ */ css("border-color:", borderColorValue, ";", ""),
    activeBorder: /* @__PURE__ */ css("border-color:", colorPrimaryValue, ";box-shadow:0px 0px 9px 4px ", c, ";", ""),
    rounded: /* @__PURE__ */ css("border-radius:", videoCardBorderRadiusValue, ";", ""),
    bgLv1: /* @__PURE__ */ css("background-color:", bgLv1Value, ";", ""),
    // make cover zoom
    coverZoomEffect: {
      name: "dj03ws",
      styles: ".bili-video-card__cover{transform-origin:center center;transition:transform 0.2s ease-out;transform:scale(1.05);}"
    }
  };
  const multiSelectedCss = /* @__PURE__ */ css(Styles.activeBorder, " &:hover{", Styles.activeBorder, ";}", "");
  function useBlockedCardCss(isBlockedCard) {
    const sepIdentifier = `--${APP_NAMESPACE}-separator-color`;
    return H.useMemo(() => {
      if (!isBlockedCard) return void 0;
      return css`
      ${Styles.rounded}
      ${Styles.normalBorder}

      background-color: ${bgValue};
      ${sepIdentifier}:  ${bgLv1Value};
      &:hover {
        background-color: ${bgLv1Value};
        ${sepIdentifier}: ${bgLv2Value};
      }

      /* disable padding */
      margin-inline: 0;
      .bili-video-card__wrap {
        padding: 0;
      }
    `;
    }, [isBlockedCard]);
  }
  var _ref$b = {
    name: "1ytxauw",
    styles: "margin-inline:-6px;.bili-video-card__wrap{padding:6px;padding-bottom:0;}"
  };
  var _ref2$6 = {
    name: "7dle4o",
    styles: "border:1px solid transparent;transition-property:border-color,box-shadow,background-color;transition-duration:0.3s;transition-timing-function:ease-in-out"
  };
  function useCardBorderCss() {
    const {
      useDelayForHover,
      style: {
        videoCard: {
          useBorder,
          useBorderOnlyOnHover,
          useBoxShadow,
          usePadding
        },
        pureRecommend: {
          cardDisplay
        }
      }
    } = useSettingsSnapshot();
    const {
      multiSelecting
    } = useSnapshot(multiSelectStore);
    return H.useMemo(() => {
      return [_ref2$6, (multiSelecting || useBorder && !isDisplayAsList(cardDisplay)) && [
        /* @__PURE__ */ css("cursor:pointer;", Styles.rounded, " &:hover{", Styles.bgLv1, " ", Styles.normalBorder, " ", useBoxShadow && Styles.activeBorder, " ", useDelayForHover && Styles.coverZoomEffect, ";}", ""),
        // show border not:hover
        (multiSelecting || !useBorderOnlyOnHover) && Styles.normalBorder,
        // add padding & negative margin
        useBorderOnlyOnHover && !useBoxShadow && usePadding && _ref$b
      ]];
    }, [useBorder, useBorderOnlyOnHover, useBoxShadow, usePadding, useDelayForHover, cardDisplay, multiSelecting]);
  }
  function getActiveCardBorderCss(active) {
    return active && [Styles.rounded, Styles.activeBorder];
  }
  const S$3 = {
    previewImageWrapper: /* @__PURE__ */ css("position:absolute;inset:0;z-index:", zIndexPreviewImageWrapper, ";overflow:hidden;pointer-events:none;border-top-left-radius:", videoCardBorderRadiusValue, ";border-top-right-radius:", videoCardBorderRadiusValue, ";border-bottom-left-radius:0;border-bottom-right-radius:0;", "")
  };
  const PreviewImage = H.memo(H.forwardRef(function({
    videoDuration,
    pvideo,
    progress,
    t: t2,
    ...restProps
  }, ref) {
    const rootElRef = H.useRef(null);
    const [size, setSize] = H.useState(() => ({
      width: 0,
      height: 0
    }));
    useMount(() => {
      var _a2;
      const rect = (_a2 = rootElRef.current) == null ? void 0 : _a2.getBoundingClientRect();
      if (!rect) return;
      setSize({
        width: rect.width,
        height: rect.height
      });
    });
    const usingProgress = H.useMemo(() => {
      function getProgress() {
        if (typeof progress === "number" && !isNaN(progress)) return progress;
        return 0;
      }
      return minmax(getProgress() ?? 0, 0, 1);
    }, [progress]);
    const usingT = H.useMemo(() => t2 ?? Math.floor((videoDuration || 0) * usingProgress), [t2, videoDuration, usingProgress]);
    const getT = useMemoizedFn(() => usingT);
    H.useImperativeHandle(ref, () => ({
      getT
    }), [getT]);
    const innerProps = {
      progress: usingProgress,
      t: usingT,
      pvideo,
      elWidth: size.width,
      elHeight: size.height
    };
    return /* @__PURE__ */ jsx$1("div", { ...restProps, ref: rootElRef, css: S$3.previewImageWrapper, children: !!(pvideo && size.width && size.height && usingProgress) && /* @__PURE__ */ jsx$1(PreviewImageInner, { ...innerProps }) });
  }));
  const PreviewImageInner = H.memo(function PreviewImageInner2({
    t: t2,
    progress,
    pvideo,
    elWidth,
    elHeight
  }) {
    var _a2;
    let index = H.useMemo(() => {
      return calcIndex((pvideo == null ? void 0 : pvideo.index) || [], t2) ?? 0;
    }, [pvideo, t2]);
    const {
      img_x_len: colCount,
      img_y_len: rowCount,
      img_x_size: w,
      img_y_size: h
    } = pvideo;
    const countPerPreview = rowCount * colCount;
    index = index + 1;
    const snapshotIndex = Math.floor(index / countPerPreview);
    const indexInSnapshot = index - snapshotIndex * countPerPreview;
    const snapshotUrl = ((_a2 = pvideo.image) == null ? void 0 : _a2[snapshotIndex]) || "";
    const indexRow = Math.floor(indexInSnapshot / colCount) + 1;
    const indexCol = indexInSnapshot - (indexRow - 1) * colCount;
    const newImgWidth = elWidth * colCount;
    const newImgHeight = elHeight * rowCount;
    const startY = (indexRow - 1) * elHeight;
    const startX = (indexCol - 1) * elWidth;
    return /* @__PURE__ */ jsx$1("div", { className: "size-full", style: {
      backgroundColor: "black",
      // 防止加载过程中闪屏
      backgroundImage: `url(${snapshotUrl})`,
      backgroundPosition: `-${startX}px -${startY}px`,
      backgroundSize: `${newImgWidth}px ${newImgHeight}px`
    }, children: /* @__PURE__ */ jsx$1(SimplePregressBar, { progress }) });
  });
  function SimplePregressBar({
    progress,
    ...rest
  }) {
    const backgroundColor = bgLv1Value;
    return /* @__PURE__ */ jsx$1("div", { ...rest, "data-role": "track", className: clsx("absolute bottom-0 left-0 right-0 h-2px", rest.className), css: /* @__PURE__ */ css("background-color:", backgroundColor, ";", ""), children: /* @__PURE__ */ jsx$1("div", { "data-role": "bar", className: "h-full bg-gate-primary", style: {
      width: `${progress * 100}%`
    } }) });
  }
  function calcIndex(arr, t2) {
    let index = findIndex(arr, t2);
    if (index !== -1) {
      return index;
    }
    if (t2 > arr[arr.length - 1]) {
      index = arr.length - 1;
    }
  }
  function findIndex(arr, target) {
    let l2 = 0;
    let r2 = arr.length - 1;
    let possible = -1;
    while (l2 <= r2) {
      const mid = Math.floor((l2 + r2) / 2);
      const mv = arr[mid];
      if (target === mv) {
        return mid;
      }
      if (mv < target) {
        l2 = mid + 1;
        possible = mid;
      } else {
        r2 = mid - 1;
      }
    }
    if (possible === -1) return -1;
    const v = arr[possible];
    const v1 = arr[possible + 1] ?? 0;
    if (v < target && target < v1) {
      return possible;
    } else {
      return -1;
    }
  }
  var render = function render2(props) {
    if (typeof props.children === "function") {
      return H.createElement(H.Fragment, null, props.children());
    }
    return H.createElement(H.Fragment, null, props.children || null);
  };
  var Case = function Case2(_ref7) {
    var _ref$children = _ref7.children, children = _ref$children === void 0 ? null : _ref$children;
    return render({
      children
    });
  };
  var Default = function Default2(_ref7) {
    var _ref$children = _ref7.children, children = _ref$children === void 0 ? null : _ref$children;
    return render({
      children
    });
  };
  var getConditionResult = function getConditionResult2(condition) {
    var conditionResult = Boolean(typeof condition === "function" ? condition() : condition);
    return conditionResult;
  };
  function isFunction(input) {
    return typeof input === "function";
  }
  var Switch = function Switch2(_ref7) {
    var _ref22, _matchingCase;
    var children = _ref7.children;
    var matchingCase = void 0;
    var defaultCase = void 0;
    if (isFunction(children)) {
      children = children();
    }
    H.Children.forEach(children, function(child) {
      if (!H.isValidElement(child)) {
        return;
      }
      if (!matchingCase && child.type === Case) {
        var condition = child.props.condition;
        var conditionResult = getConditionResult(condition);
        if (conditionResult) {
          matchingCase = child;
        }
      } else if (!defaultCase && child.type === Default) {
        defaultCase = child;
      }
    });
    return (_ref22 = (_matchingCase = matchingCase) != null ? _matchingCase : defaultCase) != null ? _ref22 : null;
  };
  const S$2 = {
    recommendReason: {
      name: "svh8ho",
      styles: "display:inline-block;cursor:default;color:var(--Or5);background-color:var(--Or1);border-radius:4px;font-size:var(--follow-icon-font-size);line-height:var(--follow-icon-line-height);height:var(--follow-icon-line-height);width:max-content;max-width:calc(100% - 6px);overflow:hidden;text-overflow:ellipsis;white-space:nowrap;padding-block:0;padding-inline:2px"
    },
    appBadge: {
      name: "1atx64h",
      styles: "color:#fa6a9d;border-radius:2px;border:1px #fa6a9d solid;line-height:20px;padding:0 10px;transform:scale(0.8);transform-origin:center left"
    }
  };
  const descOwnerCss = {
    name: "nux2qa",
    styles: "font-size:var(--subtitle-font-size);line-height:var(--subtitle-line-height);color:var(--text3);a&:visited{color:var(--text3);}display:inline-flex;width:max-content;max-width:100%;align-items:center;justify-content:flex-start"
  };
  var _ref$a = {
    name: "15xw6zv",
    styles: "display:-webkit-box;-webkit-box-orient:vertical;-webkit-line-clamp:1;overflow:hidden;text-overflow:ellipsis;max-width:100%"
  };
  var _ref2$5 = {
    name: "feo88y",
    styles: ".bili-video-card .bili-video-card__info--tit>a&{font-family:inherit;font-weight:initial;}"
  };
  var _ref3$1 = {
    name: "1eyh0r6",
    styles: "text-indent:0!important;.bili-video-card &.bili-video-card__info--tit{padding-right:0;height:auto;max-height:calc(2 * var(--title-line-height));}"
  };
  var _ref4$1 = {
    name: "y53ss",
    styles: "flex:1;margin-left:5px;display:flex;flex-direction:column;row-gap:4px;overflow:hidden"
  };
  const VideoCardBottom = H.memo(function({
    item,
    cardData,
    handleVideoLinkClick,
    className
  }) {
    const {
      useBorder
    } = useSnapshot(settings.style.videoCard);
    const target = useLinkTarget();
    const {
      // video
      goto,
      href,
      title,
      titleRender,
      pubdateDisplay,
      pubdateDisplayForTitleAttr,
      recommendReason,
      // author
      authorName,
      authorFace,
      authorMid,
      // adpater specific
      appBadge,
      appBadgeDesc,
      rankingDesc,
      liveExtraDesc
    } = cardData;
    const isNormalVideo = goto === "av";
    const authorHref = authorMid ? formatSpaceUrl(authorMid) : href;
    const streaming = item.api === EApiType.Live && item.live_status === ELiveStatus.Streaming;
    const {
      data: pubDateDisplayFromApi
    } = useRequest(() => fetchAppRecommendFollowedPubDate(item, cardData), {
      refreshDeps: [item, cardData]
    });
    let descTitleAttr;
    if (isNormalVideo) {
      if (authorName || pubdateDisplay || pubdateDisplayForTitleAttr || pubDateDisplayFromApi) {
        descTitleAttr = [
          //
          authorName,
          pubdateDisplayForTitleAttr || pubdateDisplay || pubDateDisplayFromApi
        ].filter(Boolean).join(" · ");
      }
    }
    return /* @__PURE__ */ jsxs("div", { className: clsx("mt-15px px-5px flex gap-x-5px overflow-hidden", useBorder ? "mb-10px" : "mb-5px", className), children: [
      !!authorMid && true && /* @__PURE__ */ jsx$1("a", { href: authorHref, target, children: /* @__PURE__ */ jsxs("span", { className: clsx("flex-center p-1px b-1px b-solid rounded-full relative", streaming ? "b-gate-primary" : "b-transparent"), children: [
        authorFace ? /* @__PURE__ */ jsx$1(antd.Avatar, { src: getAvatarSrc(authorFace) }) : /* @__PURE__ */ jsx$1(antd.Avatar, { children: (authorName == null ? void 0 : authorName[0]) || (appBadgeDesc == null ? void 0 : appBadgeDesc[0]) || "" }),
        streaming && /* @__PURE__ */ jsx$1(IconForLive, { className: "size-12px absolute bottom-0 right-0 rounded-full", active: true, css: /* @__PURE__ */ css("background-color:", colorPrimaryValue, ";", "") })
      ] }) }),
      /* @__PURE__ */ jsxs("div", { css: _ref4$1, children: [
        /* @__PURE__ */ jsx$1("h3", { className: "bili-video-card__info--tit", title, css: _ref3$1, children: /* @__PURE__ */ jsx$1("a", { onClick: handleVideoLinkClick, href, target, rel: "noopener", css: _ref2$5, children: titleRender ?? title }) }),
        renderDesc()
      ] })
    ] });
    function renderDesc() {
      if (isNormalVideo) {
        const date = pubdateDisplay || pubDateDisplayFromApi;
        return /* @__PURE__ */ jsxs(Fragment, { children: [
          /* @__PURE__ */ jsxs("a", { className: "bili-video-card__info--owner", href: authorHref, target, title: descTitleAttr, css: descOwnerCss, children: [
            /* @__PURE__ */ jsx$1("span", { className: "bili-video-card__info--author", children: authorName }),
            date && /* @__PURE__ */ jsx$1("span", { className: "bili-video-card__info--date", children: DESC_SEPARATOR + date })
          ] }),
          !!recommendReason && /* @__PURE__ */ jsx$1("span", { css: S$2.recommendReason, title: recommendReason, children: recommendReason })
        ] });
      }
      return /* @__PURE__ */ jsxs(Switch, { children: [
        /* @__PURE__ */ jsx$1(Case, { condition: appBadge || appBadgeDesc, children: /* @__PURE__ */ jsxs("a", { className: "bili-video-card__info--owner", css: descOwnerCss, href, target, children: [
          !!appBadge && /* @__PURE__ */ jsx$1("span", { css: S$2.appBadge, children: appBadge }),
          !!appBadgeDesc && /* @__PURE__ */ jsx$1("span", { children: appBadgeDesc })
        ] }) }),
        /* @__PURE__ */ jsx$1(Case, { condition: isRank(item) && rankingDesc, children: /* @__PURE__ */ jsx$1("div", { css: descOwnerCss, children: rankingDesc }) }),
        /* @__PURE__ */ jsx$1(Case, { condition: isLive(item) || isPcRecommend(item) && item.goto === PcRecGoto.Live, children: /* @__PURE__ */ jsxs(Fragment, { children: [
          /* @__PURE__ */ jsxs("a", { css: [descOwnerCss, _ref$a, "", ""], href: authorHref, target, title: (authorName || "") + (liveExtraDesc || ""), children: [
            authorName,
            liveExtraDesc && /* @__PURE__ */ jsx$1("span", { className: "ml-4px", children: liveExtraDesc })
          ] }),
          !!recommendReason && /* @__PURE__ */ jsx$1("span", { css: S$2.recommendReason, title: recommendReason, children: recommendReason })
        ] }) })
      ] });
    }
  });
  const skeletonActive = "_skeleton-active_g6pzk_15";
  const iconParkOutlineDistraughtFace = (props, ref) => /* @__PURE__ */ jsx$1("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref, ...props, children: /* @__PURE__ */ jsxs("g", { fill: "none", stroke: "currentColor", strokeLinejoin: "round", strokeWidth: 4, children: [
    /* @__PURE__ */ jsx$1("path", { d: "M24 44c11.046 0 20-8.954 20-20S35.046 4 24 4S4 12.954 4 24s8.954 20 20 20Z" }),
    /* @__PURE__ */ jsx$1("path", { strokeLinecap: "round", d: "M24 29c5 0 7 4 7 4H17s2-4 7-4m8-12l-3 3l3 3m-16-6l3 3l-3 3" })
  ] }) });
  const ForwardRef$i = H.forwardRef(iconParkOutlineDistraughtFace);
  const SkeletonCard = H.memo(function SkeletonCard2({
    loading
  }) {
    return /* @__PURE__ */ jsxs("div", { className: clsx("bili-video-card__skeleton", {
      hide: !loading,
      [skeletonActive]: loading
    }), children: [
      /* @__PURE__ */ jsx$1("div", { className: "bili-video-card__skeleton--cover", style: {
        borderRadius: videoCardBorderRadiusValue
      } }),
      /* @__PURE__ */ jsxs("div", { className: "bili-video-card__skeleton--info px-5px", children: [
        /* @__PURE__ */ jsx$1("div", { className: "bili-video-card__skeleton--avatar size-32px rounded-full" }),
        /* @__PURE__ */ jsxs("div", { className: "bili-video-card__skeleton--right flex-1 ml-10px", children: [
          /* @__PURE__ */ jsx$1("p", { className: "bili-video-card__skeleton--text" }),
          /* @__PURE__ */ jsx$1("p", { className: "bili-video-card__skeleton--text short" }),
          /* @__PURE__ */ jsx$1("p", { className: "bili-video-card__skeleton--light" }),
          /* @__PURE__ */ jsx$1("p", { className: "bili-video-card__skeleton--text tiny" })
        ] })
      ] })
    ] });
  });
  const blockedCardCss = {
    wrapper: {
      name: "g8mxb9",
      styles: "height:100%;display:flex;flex-direction:column;overflow:hidden"
    },
    cover: {
      name: "gcx5o1",
      styles: "border-top-left-radius:6px;border-top-right-radius:6px;aspect-ratio:16/9;position:relative"
    },
    coverInner: {
      name: "168b1mf",
      styles: "position:absolute;top:0;left:0;width:100%;height:100%;display:flex;flex-direction:column;align-items:center;justify-content:center"
    },
    dislikeReason: {
      name: "1965z4g",
      styles: "font-size:20px;text-align:center"
    },
    dislikeDesc: {
      name: "o0p24g",
      styles: "font-size:16px;text-align:center"
    },
    action: {
      name: "r7fjfn",
      styles: "flex:1;position:relative"
    },
    actionInner: /* @__PURE__ */ css("position:absolute;top:0;left:0;width:100%;height:100%;border-top:1px solid var(--", APP_NAMESPACE, "-separator-color);transition:border-top-color 0.3s;display:flex;align-items:center;justify-content:center;button{font-size:16px;color:inherit;display:flex;align-items:center;}", "")
  };
  const DislikedCard = H.memo(function DislikedCard2({
    item,
    cardData,
    dislikedReason,
    emitter: emitter2 = defaultEmitter
  }) {
    const onCancelDislike = useMemoizedFn(async () => {
      if (!(dislikedReason == null ? void 0 : dislikedReason.id)) return;
      let success = false;
      let message2 = "";
      let err;
      try {
        ;
        ({
          success,
          message: message2
        } = await cancelDislike(item, dislikedReason.id));
      } catch (e2) {
        err = e2;
      }
      if (err) {
        console.error(err.stack || err);
        return toastRequestFail();
      }
      if (success) {
        antMessage.success("已撤销");
        delDislikeId(item.param);
      } else {
        antMessage.error(message2 || OPERATION_FAIL_MSG);
      }
    });
    useMittOn(emitter2, "cancel-dislike", onCancelDislike);
    return /* @__PURE__ */ jsxs("div", { css: blockedCardCss.wrapper, children: [
      /* @__PURE__ */ jsx$1("div", { css: blockedCardCss.cover, children: /* @__PURE__ */ jsxs("div", { css: blockedCardCss.coverInner, children: [
        /* @__PURE__ */ jsx$1(ForwardRef$i, { className: "size-32px mb-5px" }),
        /* @__PURE__ */ jsx$1("div", { css: blockedCardCss.dislikeReason, children: dislikedReason == null ? void 0 : dislikedReason.name }),
        /* @__PURE__ */ jsx$1("div", { css: blockedCardCss.dislikeDesc, children: (dislikedReason == null ? void 0 : dislikedReason.toast) || "将减少此类内容推荐" })
      ] }) }),
      /* @__PURE__ */ jsx$1(__BottomRevertAction, { item, cardData, onClick: onCancelDislike })
    ] });
  });
  function __BottomRevertAction({
    item,
    cardData,
    onClick
  }) {
    return /* @__PURE__ */ jsxs("div", { css: blockedCardCss.action, children: [
      /* @__PURE__ */ jsx$1(VideoCardBottom, { item, cardData, className: "invisible" }),
      /* @__PURE__ */ jsx$1("div", { css: blockedCardCss.actionInner, children: /* @__PURE__ */ jsxs("button", { onClick, children: [
        /* @__PURE__ */ jsx$1(IconForReset, { className: "size-16px mr-4px mt--2px" }),
        "撤销"
      ] }) })
    ] });
  }
  const BlacklistCard = H.memo(function BlacklistCard2({
    item,
    cardData
  }) {
    const {
      authorMid,
      authorName
    } = cardData;
    const onCancel = useMemoizedFn(async () => {
      if (!authorMid) return;
      const success = await UserBlacklistService.remove(authorMid);
      if (success) antMessage.success(`已移出黑名单: ${authorName}`);
    });
    return /* @__PURE__ */ jsxs("div", { css: blockedCardCss.wrapper, children: [
      /* @__PURE__ */ jsx$1("div", { css: blockedCardCss.cover, children: /* @__PURE__ */ jsxs("div", { css: blockedCardCss.coverInner, children: [
        /* @__PURE__ */ jsx$1(IconForBlacklist, { className: "size-32px mb-5px" }),
        /* @__PURE__ */ jsx$1("div", { css: blockedCardCss.dislikeReason, children: "已拉黑" }),
        /* @__PURE__ */ jsxs("div", { css: blockedCardCss.dislikeDesc, children: [
          "UP: ",
          authorName
        ] })
      ] }) }),
      /* @__PURE__ */ jsx$1(__BottomRevertAction, { item, cardData, onClick: onCancel })
    ] });
  });
  const follow = followActionFactory("follow");
  const unfollow = followActionFactory("unfollow");
  const UserfollowService = {
    follow,
    unfollow
  };
  function followActionFactory(action2) {
    const act = action2 === "follow" ? 1 : 2;
    return async function followAction(upMid) {
      const success = await modifyRelations(upMid, act);
      return success;
    };
  }
  const iconParkOutlineAddTwo = (props, ref) => /* @__PURE__ */ jsx$1("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref, ...props, children: /* @__PURE__ */ jsxs("g", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeWidth: 4, children: [
    /* @__PURE__ */ jsx$1("path", { d: "M33 7.263A18.9 18.9 0 0 0 24 5C13.507 5 5 13.507 5 24s8.507 19 19 19a18.9 18.9 0 0 0 8-1.761" }),
    /* @__PURE__ */ jsx$1("path", { strokeLinejoin: "round", d: "M31 30h12m-28-8l7 7l19-18m-4 13v12" })
  ] }) });
  const ForwardRef$h = H.forwardRef(iconParkOutlineAddTwo);
  const iconParkOutlinePeopleMinus = (props, ref) => /* @__PURE__ */ jsx$1("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref, ...props, children: /* @__PURE__ */ jsxs("g", { fill: "none", children: [
    /* @__PURE__ */ jsx$1("path", { stroke: "currentColor", strokeLinejoin: "round", strokeWidth: 4, d: "M19 20a7 7 0 1 0 0-14a7 7 0 0 0 0 14Z" }),
    /* @__PURE__ */ jsx$1("path", { d: "M30 35h12z", clipRule: "evenodd" }),
    /* @__PURE__ */ jsx$1("path", { stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 4, d: "M30 35h12m-15-7h-8.2c-4.48 0-6.72 0-8.432.872a8 8 0 0 0-3.496 3.496C6 34.08 6 36.32 6 40.8V42h21" })
  ] }) });
  const ForwardRef$g = H.forwardRef(iconParkOutlinePeopleMinus);
  const letsIconsViewHide = (props, ref) => /* @__PURE__ */ jsx$1("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref, ...props, children: /* @__PURE__ */ jsxs("g", { fill: "none", children: [
    /* @__PURE__ */ jsx$1("path", { fill: "currentColor", fillRule: "evenodd", d: "M15.92 12.799Q16 12.41 16 12a4 4 0 0 0-4.799-3.92zM8.667 9.788a4 4 0 0 0 5.545 5.545l-1.474-1.474a2 2 0 0 1-2.597-2.597z", clipRule: "evenodd" }),
    /* @__PURE__ */ jsx$1("path", { fill: "currentColor", fillRule: "evenodd", d: "m16.52 17.64l-1.47-1.469c-.972.51-2.002.829-3.05.829c-1.526 0-3.014-.678-4.34-1.632c-1.32-.95-2.396-2.112-3.076-2.938c-.1-.121-.174-.212-.236-.291a2 2 0 0 1-.1-.139q.028-.045.1-.139c.062-.08.136-.17.236-.291c.665-.808 1.71-1.938 2.99-2.875l-1.43-1.43C4.797 8.297 3.723 9.47 3.04 10.3l-.073.088c-.314.375-.737.883-.737 1.613s.423 1.238.737 1.613l.073.088c.74.899 1.94 2.203 3.451 3.29C7.994 18.073 9.891 19 12 19c1.67 0 3.206-.581 4.52-1.36M8.806 5.686C9.79 5.269 10.864 5 12 5c2.11 0 4.006.927 5.509 2.009c1.51 1.087 2.711 2.391 3.45 3.29l.074.088c.314.375.737.883.737 1.613s-.423 1.238-.737 1.613l-.073.088a20.5 20.5 0 0 1-2.015 2.123l-1.416-1.416a18.5 18.5 0 0 0 2.123-2.27a2 2 0 0 0 .1-.138a2 2 0 0 0-.1-.139a14 14 0 0 0-.236-.291c-.68-.826-1.756-1.989-3.075-2.938C15.014 7.678 13.526 7 12 7c-.551 0-1.097.088-1.632.246z", clipRule: "evenodd" }),
    /* @__PURE__ */ jsx$1("path", { stroke: "currentColor", strokeWidth: 2, d: "m5 2l16 16" })
  ] }) });
  const ForwardRef$f = H.forwardRef(letsIconsViewHide);
  function useContextMenus({
    item,
    cardData,
    tab: tab2,
    isNormalVideo,
    onRefresh,
    watchlaterAdded,
    hasWatchlaterEntry,
    onToggleWatchlater,
    hasDislikeEntry,
    onTriggerDislike,
    favFolderNames,
    favFolderUrls,
    onMoveToFirst,
    onRemoveCurrent,
    consistentOpenMenus,
    conditionalOpenMenus,
    multiSelecting
  }) {
    const {
      avid,
      bvid,
      cover,
      href,
      recommendReason,
      // author
      authorName,
      authorMid
    } = cardData;
    const {
      enableHideSomeContents
    } = useSnapshot(settings.dynamicFeed.whenViewAll);
    const onCopyLink = useMemoizedFn(() => {
      let content = href;
      if (href.startsWith("/")) {
        content = new URL(href, location.href).href;
      }
      copyContent(content);
    });
    const hasBlacklistEntry = !!authorMid && isApiRecLike(item.api) && tab2 !== ETab.KeepFollowOnly;
    const onBlacklistUp = useMemoizedFn(async () => {
      if (!authorMid) return antMessage.error("UP mid 为空!");
      const success = await UserBlacklistService.add(authorMid);
      if (success) {
        antMessage.success(`已加入黑名单: ${authorName}`);
      }
    });
    const onAddUpToFilterList = useMemoizedFn(async () => {
      if (!authorMid) return antMessage.error("UP mid 为空!");
      const content = `${authorMid}`;
      if (settings.filter.byAuthor.keywords.includes(content)) {
        return toast(`已在过滤名单中: ${content}`);
      }
      await updateSettingsInnerArray("filter.byAuthor.keywords", {
        add: [content]
      });
      if (authorName) setNicknameCache(authorMid, authorName);
      let toastContent = content;
      if (authorName) toastContent += ` 用户名: ${authorName}`;
      antMessage.success(`已加入过滤名单: ${toastContent}, 刷新后生效~`);
    });
    const followed = item.api === EApiType.DynamicFeed || (item.api === EApiType.AppRecommend || item.api === EApiType.PcRecommend) && getFollowedStatus$1(recommendReason);
    const hasUnfollowEntry = followed;
    const onUnfollowUp = useMemoizedFn(async () => {
      if (!authorMid) return;
      const success = await UserfollowService.unfollow(authorMid);
      if (success) {
        antMessage.success("已取消关注");
      }
    });
    const hasViewUpVideoListEntry = (isNormalVideo || isLive(item)) && !!authorMid && !!authorName;
    const onViewUpDyn = useMemoizedFn(() => {
      if (!hasViewUpVideoListEntry) return;
      const u2 = `/?${DynamicFeedQueryKey.Mid}=${authorMid}`;
      openNewTab(u2);
    });
    const onViewUpSpaceUpload = useMemoizedFn(() => {
      if (!hasViewUpVideoListEntry) return;
      const u2 = `/?${SpaceUploadQueryKey.Mid}=${authorMid}`;
      openNewTab(u2);
    });
    const hasEntry_addMidTo_dynamicFeedWhenViewAllHideIds = enableHideSomeContents && isDynamicFeed(item) && dfStore.selectedKey === DF_SELECTED_KEY_ALL && !!authorMid;
    const onAddMidTo_dynamicFeedWhenViewAllHideIds = useMemoizedFn(async () => {
      if (!hasEntry_addMidTo_dynamicFeedWhenViewAllHideIds) return;
      await updateSettingsInnerArray("dynamicFeed.whenViewAll.hideIds", {
        add: [DF_SELECTED_KEY_PREFIX_UP + authorMid]
      });
      setNicknameCache(authorMid, authorName || "");
      antMessage.success(`在「全部」动态中隐藏【${authorName}】的动态`);
    });
    const hasEntry_dynamicFeed_offsetAndMinId = !!(isDynamicFeed(item) && QUERY_DYNAMIC_UP_MID && dfStore.viewingSomeUp && authorMid);
    const dynamicViewStartFromHere = H.useMemo(() => hasEntry_dynamicFeed_offsetAndMinId && {
      label: "动态: 从此项开始查看",
      key: "动态: 从此项开始查看",
      icon: /* @__PURE__ */ jsx$1(ForwardRef$12, { className: "size-17px" }),
      onClick() {
        var _a2;
        const u2 = new URL("/", location.href);
        u2.searchParams.set(DynamicFeedQueryKey.Mid, authorMid);
        const currentIndexInGrid = currentGridItems.findIndex((x) => x.api === EApiType.DynamicFeed && x.id_str === item.id_str);
        const prevIdStr = ((_a2 = currentGridItems[currentIndexInGrid - 1]) == null ? void 0 : _a2.id_str) || item.id_str;
        u2.searchParams.set(DynamicFeedQueryKey.Offset, prevIdStr);
        openNewTab(u2.href);
      }
    }, [hasEntry_dynamicFeed_offsetAndMinId, item]);
    const dynamicViewUpdateSinceThis = H.useMemo(() => hasEntry_dynamicFeed_offsetAndMinId && {
      icon: /* @__PURE__ */ jsx$1(ForwardRef$13, { className: "size-17px" }),
      label: "动态: 从此项开始截止",
      key: "动态: 从此项开始截止",
      onClick() {
        const u2 = new URL("/", location.href);
        u2.searchParams.set(DynamicFeedQueryKey.Mid, authorMid);
        u2.searchParams.set(DynamicFeedQueryKey.MinId, item.id_str);
        openNewTab(u2.href);
      }
    }, [hasEntry_dynamicFeed_offsetAndMinId, item]);
    return H.useMemo(() => {
      const divider = {
        type: "divider"
      };
      const multiSelectingAppendix = multiSelecting ? " (多选)" : "";
      const copyMenus = defineAntMenus([{
        key: "copy-link",
        label: "复制视频链接" + multiSelectingAppendix,
        icon: /* @__PURE__ */ jsx$1(IconForCopy, { className: "size-15px" }),
        onClick() {
          if (multiSelectStore.multiSelecting) {
            copyVideoLinks();
          } else {
            onCopyLink();
          }
        }
      }, {
        test: !!bvid,
        key: "copy-bvid",
        label: "复制 BVID" + multiSelectingAppendix,
        icon: /* @__PURE__ */ jsx$1(IconForCopy, { className: "size-15px" }),
        onClick() {
          if (multiSelectStore.multiSelecting) {
            copyBvidsSingleLine();
          } else {
            copyContent(bvid);
          }
        }
      }, {
        test: !!bvid && settings.__internalEnableCopyBvidInfo,
        key: "copy-bvid-info",
        label: "复制 BVID 信息" + multiSelectingAppendix,
        icon: /* @__PURE__ */ jsx$1(IconForCopy, { className: "size-15px" }),
        onClick() {
          if (multiSelectStore.multiSelecting) {
            copyBvidInfos();
          } else {
            copyContent(getBvidInfo(cardData));
          }
        }
      }, {
        test: !!cover,
        key: "view-cover",
        label: "查看封面",
        icon: /* @__PURE__ */ jsx$1(IconForOpenExternalLink, { className: "size-16px" }),
        onClick() {
          if (!cover) return;
          const url = cover;
          openNewTab(url);
        }
      }]);
      const interestedMenus = defineAntMenus([
        {
          test: hasViewUpVideoListEntry,
          key: "view-up-space-upload",
          label: `查看 UP 的投稿`,
          icon: /* @__PURE__ */ jsx$1(IconForSpaceUpload, { className: "size-15px" }),
          onClick: onViewUpSpaceUpload
        },
        {
          test: hasViewUpVideoListEntry && followed,
          key: "view-up-dyn",
          label: `查看 UP 的动态`,
          icon: /* @__PURE__ */ jsx$1(IconForDynamicFeed, { className: "size-15px" }),
          onClick: onViewUpDyn
        },
        {
          test: hasWatchlaterEntry,
          key: "watchlater",
          label: watchlaterAdded ? "移除稍后再看" : "稍后再看",
          icon: watchlaterAdded ? /* @__PURE__ */ jsx$1(IconForRemove, { className: "size-15px" }) : /* @__PURE__ */ jsx$1(IconForWatchlater, { className: "size-15px" }),
          onClick() {
            onToggleWatchlater();
          }
        },
        {
          test: hasWatchlaterEntry && watchlaterAdded,
          key: "watchlater-readd",
          label: `重新添加稍候再看${tab2 === ETab.Watchlater ? " (移到最前)" : ""}`,
          icon: /* @__PURE__ */ jsx$1(ForwardRef$h, { className: "size-15px" }),
          async onClick() {
            const {
              success
            } = await onToggleWatchlater(void 0, watchlaterAdd);
            if (!success) return;
            antMessage.success("已重新添加");
            if (tab2 === ETab.Watchlater) {
              onMoveToFirst == null ? void 0 : onMoveToFirst(item, cardData);
            }
          }
        },
        {
          test: isWatchlater(item),
          key: "add-fav",
          icon: (favFolderNames == null ? void 0 : favFolderNames.length) ? /* @__PURE__ */ jsx$1(IconForFaved, { className: clsx("size-15px", appClsColorPrimary) }) : /* @__PURE__ */ jsx$1(IconForFav, { className: "size-15px" }),
          label: (favFolderNames == null ? void 0 : favFolderNames.length) ? `已收藏 ${favFolderNames.map((n2) => `「${n2}」`).join("")}` : "快速收藏",
          async onClick() {
            if (!avid) return;
            const hasFaved = Boolean(favFolderNames == null ? void 0 : favFolderNames.length);
            if (hasFaved) {
              favFolderUrls == null ? void 0 : favFolderUrls.forEach((u2) => {
                window.open(u2, getLinkTarget());
              });
            } else {
              const success = await UserFavService.addFav(avid);
              if (success) {
                antMessage.success(`已加入收藏夹「${defaultFavFolderName}」`);
              }
            }
          }
        },
        // 动态
        dynamicViewUpdateSinceThis,
        dynamicViewStartFromHere
      ]);
      const dislikeMenus = defineAntMenus([{
        test: hasDislikeEntry,
        key: "dislike",
        label: "我不想看",
        icon: /* @__PURE__ */ jsx$1(IconForDislike, { width: 15, height: 15 }),
        onClick() {
          onTriggerDislike();
        }
      }, {
        test: hasUnfollowEntry,
        key: "unfollow-up",
        label: "取消关注",
        icon: /* @__PURE__ */ jsx$1(ForwardRef$g, { className: "size-15px" }),
        onClick: onUnfollowUp
      }, {
        test: hasEntry_addMidTo_dynamicFeedWhenViewAllHideIds,
        key: "hasEntry_addMidTo_dynamicFeedWhenViewAllHideIds",
        label: "在「全部」动态中隐藏 UP 的动态",
        icon: /* @__PURE__ */ jsx$1(ForwardRef$f, { className: "size-15px" }),
        onClick: onAddMidTo_dynamicFeedWhenViewAllHideIds
      }, {
        test: hasBlacklistEntry,
        key: "blacklist-up",
        label: "将 UP 加入黑名单",
        icon: /* @__PURE__ */ jsx$1(IconForBlacklist, { className: "size-15px" }),
        onClick: onBlacklistUp
      }, {
        test: hasBlacklistEntry,
        key: "add-up-to-filterlist",
        label: "将 UP 加入过滤列表",
        icon: /* @__PURE__ */ jsx$1(IconForBlacklist, { className: "size-15px" }),
        onClick: onAddUpToFilterList
      }]);
      const favMenus = !isFav(item) ? [] : defineAntMenus([
        // 收藏夹
        ...item.from === "fav-folder" ? [{
          key: "open-fav-folder",
          label: "浏览收藏夹",
          icon: /* @__PURE__ */ jsx$1(IconForOpenExternalLink, { className: "size-15px" }),
          onClick() {
            if (!isFav(item)) return;
            const {
              id
            } = item.folder;
            const url = tab2 !== ETab.Fav || favStore.selectedKey === "all" && favStore.usingShuffle ? `/?${FavQueryKey.FolderIdFull}=${id}` : formatFavFolderUrl(id);
            window.open(url, getLinkTarget());
          }
        }, {
          key: "remove-fav",
          label: "移除收藏",
          icon: /* @__PURE__ */ jsx$1(ForwardRef$O, { className: "size-15px" }),
          async onClick() {
            if (!isFav(item)) return;
            const success = await UserFavService.removeFav(item.folder.id, `${item.id}:${item.type}`);
            if (success) {
              await delay(1e3);
              onRemoveCurrent == null ? void 0 : onRemoveCurrent(item, cardData);
            }
          }
        }] : [],
        // 合集
        ...item.from === "fav-collection" ? [{
          key: "open-fav-collection",
          label: "浏览合集",
          icon: /* @__PURE__ */ jsx$1(IconForOpenExternalLink, { className: "size-15px" }),
          onClick() {
            if (!isFav(item)) return;
            const {
              id
            } = item.collection;
            const url = tab2 !== ETab.Fav || favStore.selectedKey === "all" && favStore.usingShuffle ? `/?${FavQueryKey.CollectionIdFull}=${id}` : formatFavCollectionUrl(id);
            window.open(url, getLinkTarget());
          }
        }] : []
      ]);
      return defineAntMenus([...consistentOpenMenus, !!copyMenus.length && divider, ...copyMenus, !!interestedMenus.length && divider, ...interestedMenus, !!dislikeMenus.length && divider, ...dislikeMenus, !!favMenus.length && divider, ...favMenus, !!conditionalOpenMenus.length && divider, ...conditionalOpenMenus]);
    }, [
      item,
      cardData,
      tab2,
      // entries
      hasWatchlaterEntry,
      watchlaterAdded,
      hasDislikeEntry,
      hasUnfollowEntry,
      hasBlacklistEntry,
      hasViewUpVideoListEntry,
      hasEntry_addMidTo_dynamicFeedWhenViewAllHideIds,
      // others
      favFolderNames,
      favFolderUrls,
      consistentOpenMenus,
      conditionalOpenMenus,
      //
      multiSelecting
    ]);
  }
  const dislikeIcon = /* @__PURE__ */ jsx$1(IconForDislike, { className: "size-16px" });
  function useDislikeRelated({
    item,
    authed,
    actionButtonVisible
  }) {
    var _a2, _b2;
    const hasDislikeEntry = isAppRecommend(item) && !!((_b2 = (_a2 = item.three_point) == null ? void 0 : _a2.dislike_reasons) == null ? void 0 : _b2.length);
    const onTriggerDislike = useMemoizedFn((e2) => {
      e2 == null ? void 0 : e2.preventDefault();
      e2 == null ? void 0 : e2.stopPropagation();
      if (!hasDislikeEntry) {
        if (item.api !== EApiType.AppRecommend) {
          return antMessage.error("当前视频不支持提交「我不想看」");
        }
        return;
      }
      if (!authed) {
        return toast("请先获取 access_key ~");
      }
      showModalDislike(item);
    });
    const dislikeButtonEl = hasDislikeEntry && /* @__PURE__ */ jsx$1(VideoCardActionButton, { visible: actionButtonVisible, inlinePosition: "left", icon: dislikeIcon, tooltip: "我不想看", onClick: onTriggerDislike });
    return {
      dislikeButtonEl,
      hasDislikeEntry,
      onTriggerDislike
    };
  }
  const lucideCircle = (props, ref) => /* @__PURE__ */ jsx$1("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref, ...props, children: /* @__PURE__ */ jsx$1("circle", { cx: 12, cy: 12, r: 10, fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2 }) });
  const ForwardRef$e = H.forwardRef(lucideCircle);
  const lucideCircleCheck = (props, ref) => /* @__PURE__ */ jsx$1("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref, ...props, children: /* @__PURE__ */ jsxs("g", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, children: [
    /* @__PURE__ */ jsx$1("circle", { cx: 12, cy: 12, r: 10 }),
    /* @__PURE__ */ jsx$1("path", { d: "m9 12l2 2l4-4" })
  ] }) });
  const ForwardRef$d = H.forwardRef(lucideCircleCheck);
  const IconForMultiSelectUnchecked = ForwardRef$e;
  const IconForMultiSelectChecked = ForwardRef$d;
  const clsForIconChecked = /* @__PURE__ */ css$1({
    name: "bosmd2",
    styles: "g{fill:inherit;}"
  });
  function useMultiSelectRelated({
    multiSelecting,
    multiSelected,
    uniqId
  }) {
    const toggleMultiSelect = useMemoizedFn((e2) => {
      e2 == null ? void 0 : e2.preventDefault();
      e2 == null ? void 0 : e2.stopPropagation();
      if (multiSelected) {
        multiSelectStore.selectedIdSet.delete(uniqId);
      } else {
        multiSelectStore.selectedIdSet.add(uniqId);
      }
    });
    const multiSelectBgEl = multiSelecting && /* @__PURE__ */ jsx$1("div", { onClick: toggleMultiSelect, className: "absolute inset-0 flex items-center justify-center bg-black/10", style: {
      zIndex: zIndexMultiSelectBg
    } });
    const Icon = multiSelected ? IconForMultiSelectChecked : IconForMultiSelectUnchecked;
    const multiSelectEl = multiSelecting && /* @__PURE__ */ jsx$1(Icon, { onClick: toggleMultiSelect, className: clsx(clsForIconChecked, "size-30px cursor-pointer text-white", multiSelected ? "fill-gate-primary" : "fill-none") });
    return {
      toggleMultiSelect,
      multiSelectBgEl,
      multiSelectEl
    };
  }
  function debugAnimation(...args) {
    return;
  }
  function usePreviewRelated({
    uniqId,
    sharedEmitter,
    title,
    active,
    videoDuration,
    tryFetchImagePreviewData,
    imagePreviewDataBox,
    autoPreviewWhenHover,
    videoPreviewWrapperRef
  }) {
    var _a2, _b2, _c2;
    const hasVideoData = useMemoizedFn(() => {
      var _a3, _b3, _c3, _d2;
      const data2 = (_b3 = (_a3 = imagePreviewDataBox.val) == null ? void 0 : _a3.videoshotJson) == null ? void 0 : _b3.data;
      return Boolean(((_c3 = data2 == null ? void 0 : data2.index) == null ? void 0 : _c3.length) && ((_d2 = data2 == null ? void 0 : data2.image) == null ? void 0 : _d2.length));
    });
    const [autoPreviewing, setAutoPreviewing] = H.useState(false);
    const [previewProgress, setPreviewProgress] = useRafState();
    const [previewT, setPreviewT] = useRafState();
    const getProgress = useMemoizedFn(() => previewProgress || 0);
    const [mouseMoved, setMouseMoved] = H.useState(false);
    const isHoveringBox = useRefStateBox(false);
    const isHoveringAfterDelayBox = useRefStateBox(false);
    const startByHoverBox = useRefBox(false);
    const [mouseProgress, setMouseProgress] = H.useState(void 0);
    const updateMouseProgress = (e2) => {
      var _a3;
      const rect = (_a3 = videoPreviewWrapperRef.current) == null ? void 0 : _a3.getBoundingClientRect();
      if (!rect) return;
      const {
        x,
        width
      } = rect;
      const relativeX = e2.pageX - window.scrollX - x;
      setMouseProgress(relativeX / width);
    };
    useEventListener("mouseenter", async (e2) => {
      sharedEmitter.emit("mouseenter", uniqId);
      isHoveringBox.set(true);
      updateMouseProgress(e2);
      const p2 = tryFetchImagePreviewData();
      const HOVER_DELAY = 800;
      let delayPromise;
      if (settings.useDelayForHover) {
        delayPromise = delay(HOVER_DELAY);
      }
      await Promise.all([p2, delayPromise].filter(Boolean));
      if (!isHoveringBox.val) return;
      isHoveringAfterDelayBox.set(true);
      if (autoPreviewWhenHover && !idBox.val && hasVideoData()) {
        onStartPreviewAnimation(true);
      }
    }, {
      target: videoPreviewWrapperRef
    });
    const _mouseleaveAction = useMemoizedFn(() => {
      isHoveringBox.set(false);
      isHoveringAfterDelayBox.set(false);
    });
    useEventListener("mouseleave", _mouseleaveAction, {
      target: videoPreviewWrapperRef
    });
    useMittOn(sharedEmitter, "mouseenter", (srcUniqId) => {
      if (srcUniqId === uniqId) return;
      _mouseleaveAction();
    });
    useEventListener("mousemove", (e2) => {
      setMouseMoved(true);
      if (isHoveringBox.val && (!isHoveringAfterDelayBox.val || !autoPreviewWhenHover)) {
        updateMouseProgress(e2);
      }
      if (!autoPreviewWhenHover) {
        animationController.stop();
      }
    }, {
      target: videoPreviewWrapperRef
    });
    const idBox = useRefBox(void 0);
    const onResume = H.useRef(void 0);
    const animationController = useAnimationController({
      startByHoverBox,
      isHoveringBox,
      active,
      mouseMoved,
      idBox,
      autoPreviewWhenHover,
      setAutoPreviewing,
      setPreviewT,
      setPreviewProgress,
      onResume() {
        var _a3;
        (_a3 = onResume.current) == null ? void 0 : _a3.call(onResume);
      }
    });
    const onHotkeyPreviewAnimation = useMemoizedFn(async () => {
      if (!idBox.val) {
        await tryFetchImagePreviewData();
        if (hasVideoData()) {
          onStartPreviewAnimation(false);
        }
        return;
      }
      animationController.togglePaused();
    });
    const onStartPreviewAnimation = useMemoizedFn((startByHover) => {
      startByHoverBox.set(startByHover);
      setMouseMoved(false);
      animationController.reset();
      animationController.stop(true);
      setAutoPreviewing(true);
      setPreviewProgress((val) => typeof val === "undefined" ? 0 : val);
      setPreviewT(void 0);
      const RUN_DURATION = 8e3;
      let start = performance.now();
      let updateAt = 0;
      onResume.current = () => {
        start = performance.now() - getProgress() * RUN_DURATION;
      };
      function frame(t2) {
        if (animationController.shouldStop()) {
          return animationController.stop();
        }
        if (!animationController.paused) {
          const now = performance.now();
          const elapsed = now - start;
          const p2 = minmax(elapsed % RUN_DURATION / RUN_DURATION, 0, 1);
          setPreviewProgress(p2);
          if (!updateAt || now - updateAt >= settings.autoPreviewUpdateInterval) {
            setPreviewProgress(p2);
            updateAt = now;
            if (videoDuration) {
              const t22 = minmax(Math.round(p2 * videoDuration), 0, videoDuration);
              setPreviewT(t22);
            }
          }
        }
        idBox.val = requestAnimationFrame(frame);
      }
      idBox.val = requestAnimationFrame(frame);
    });
    const isHovering = isHoveringBox.state;
    const isHoveringAfterDelay = isHoveringAfterDelayBox.state;
    const videoshotData = (_b2 = (_a2 = imagePreviewDataBox.state) == null ? void 0 : _a2.videoshotJson) == null ? void 0 : _b2.data;
    const shouldShowPreview = !!((_c2 = videoshotData == null ? void 0 : videoshotData.image) == null ? void 0 : _c2.length) && !!videoDuration && (isHoveringAfterDelay || active) && (autoPreviewWhenHover ? autoPreviewing : true);
    const previewImageRef = H.useRef(null);
    let previewImgProps;
    let previewImageEl;
    if (shouldShowPreview) {
      const sharedProps = {
        videoDuration,
        pvideo: videoshotData
      };
      if (autoPreviewWhenHover) {
        previewImgProps = {
          ...sharedProps,
          progress: previewProgress,
          t: previewT
        };
      } else {
        previewImgProps = {
          ...sharedProps,
          progress: mouseProgress
        };
      }
      previewImageEl = /* @__PURE__ */ jsx$1(PreviewImage, { ref: previewImageRef, ...previewImgProps });
    }
    return {
      onHotkeyPreviewAnimation,
      onStartPreviewAnimation,
      autoPreviewing,
      mouseProgress,
      previewProgress,
      previewT,
      //
      isHovering,
      isHoveringAfterDelay,
      // el
      shouldShowPreview,
      previewImageRef,
      previewImgProps,
      previewImageEl
    };
  }
  function useAnimationController({
    startByHoverBox,
    isHoveringBox,
    idBox,
    active,
    mouseMoved,
    autoPreviewWhenHover,
    setAutoPreviewing,
    setPreviewT,
    setPreviewProgress,
    onResume
  }) {
    const unmounted = useUnmountedRef();
    const shouldStop = useMemoizedFn(() => {
      if (unmounted.current) return true;
      if (startByHoverBox.val) {
        if (!isHoveringBox.val) return true;
      } else {
        if (!active) return true;
        if (mouseMoved) return true;
      }
      return false;
    });
    const stop = useMemoizedFn((isClear = false) => {
      if (!isClear) {
        debugAnimation(`stopAnimation: %o`, {
          autoPreviewWhenHover,
          unmounted: unmounted.current,
          isHovering: isHoveringBox.val,
          active,
          mouseMoved
        });
      }
      if (idBox.val) cancelAnimationFrame(idBox.val);
      idBox.val = void 0;
      setAutoPreviewing(false);
      setPreviewProgress(void 0);
      setPreviewT(void 0);
      controller.reset();
    });
    const _paused = H.useRef(false);
    const controller = H.useMemo(() => {
      return {
        shouldStop,
        stop,
        get paused() {
          return _paused.current;
        },
        set paused(val) {
          _paused.current = val;
        },
        togglePaused() {
          const prev2 = this.paused;
          this.paused = !this.paused;
          if (prev2) {
            onResume == null ? void 0 : onResume();
          }
        },
        reset() {
          this.paused = false;
        }
      };
    }, [shouldStop, stop, _paused, onResume]);
    return controller;
  }
  function useWatchlaterRelated({
    item,
    cardData,
    onRemoveCurrent,
    actionButtonVisible,
    watchlaterAdded
  }) {
    const {
      avid,
      bvid
    } = cardData;
    const hasWatchlaterEntry = H.useMemo(() => {
      if (isAppRecommend(item) || isPcRecommend(item)) {
        return item.goto === "av";
      }
      if (item.api === EApiType.Rank) {
        return cardData.goto === "av";
      }
      if (item.api === EApiType.Live) {
        return false;
      }
      return true;
    }, [item, cardData]);
    const $req = useRequest((usingAction, avid2) => usingAction(avid2), {
      manual: true
    });
    const watchlaterAddedPrevious = usePrevious$1(watchlaterAdded);
    const onToggleWatchlater = useMemoizedFn(async (e2, usingAction) => {
      e2 == null ? void 0 : e2.preventDefault();
      e2 == null ? void 0 : e2.stopPropagation();
      if ($req.loading) return {
        success: false
      };
      if (!avid || !bvid) {
        return {
          success: false
        };
      }
      usingAction ?? (usingAction = watchlaterAdded ? watchlaterDel : watchlaterAdd);
      const success = await $req.runAsync(usingAction, avid);
      const targetState = usingAction === watchlaterAdd ? true : false;
      if (success) {
        if (targetState) {
          watchlaterState.bvidSet.add(bvid);
        } else {
          watchlaterState.bvidSet.delete(bvid);
        }
        if (item.api === EApiType.Watchlater) {
          if (!targetState) {
            await delay(250);
            onRemoveCurrent == null ? void 0 : onRemoveCurrent(item, cardData);
          }
        } else {
          antMessage.success(`已${targetState ? "添加" : "移除"}稍后再看`);
        }
      }
      return {
        success,
        targetState
      };
    });
    const addedSize = 18;
    const icon = (() => {
      if ($req.loading) {
        return /* @__PURE__ */ jsx$1(IconForLoading, { className: "size-16px" });
      }
      if (item.api === EApiType.Watchlater) {
        return watchlaterAdded ? /* @__PURE__ */ jsx$1(ForwardRef$O, { className: "size-16px" }) : /* @__PURE__ */ jsx$1(IconAnimatedChecked, { size: addedSize, useAnimation: watchlaterAddedPrevious === true });
      }
      return watchlaterAdded ? /* @__PURE__ */ jsx$1(IconAnimatedChecked, { size: addedSize, useAnimation: watchlaterAddedPrevious === false }) : /* @__PURE__ */ jsx$1(IconForWatchlater, { className: "size-20px" });
    })();
    const tooltip = item.api === EApiType.Watchlater ? watchlaterAdded ? "已添加稍后再看, 点击移除" : "已移除稍后再看" : watchlaterAdded ? "已添加稍后再看, 点击移除" : "稍后再看";
    const watchlaterButtonEl = hasWatchlaterEntry && /* @__PURE__ */ jsx$1(VideoCardActionButton, { visible: actionButtonVisible, inlinePosition: "right", icon, tooltip, onClick: onToggleWatchlater });
    return {
      watchlaterButtonEl,
      onToggleWatchlater,
      watchlaterAdded,
      hasWatchlaterEntry
    };
  }
  const VideoCard = H.memo(function VideoCard2({
    style,
    className,
    item,
    loading,
    active,
    onRemoveCurrent,
    onMoveToFirst,
    onRefresh,
    emitter: emitter2,
    sharedEmitter,
    tab: tab2,
    baseCss,
    cardDisplay,
    multiSelecting,
    ...restProps
  }) {
    loading = loading ?? !item;
    const dislikedReason = useDislikedReason((item == null ? void 0 : item.api) === EApiType.AppRecommend && item.param);
    const cardData = H.useMemo(() => item && normalizeCardData(item), [item]);
    const blacklisted = useInBlacklist(cardData == null ? void 0 : cardData.authorMid);
    const watchlaterAdded = useWatchlaterState(cardData == null ? void 0 : cardData.bvid);
    const multiSelected = useMultiSelectState(item == null ? void 0 : item.uniqId);
    const showingDislikeCard = !!dislikedReason;
    const showingBlacklistCard = blacklisted;
    const isBlockedCard = showingDislikeCard || showingBlacklistCard;
    const blockedCardCss2 = useBlockedCardCss(isBlockedCard);
    const _className = clsx("bili-video-card", APP_CLS_CARD, {
      [APP_CLS_CARD_ACTIVE]: active
    }, "relative", className);
    const _css = [baseCss, blockedCardCss2, isDisplayAsList(cardDisplay) && displayAsListCss.card, multiSelecting && multiSelected && multiSelectedCss];
    return /* @__PURE__ */ jsx$1("div", { "data-bvid": cardData == null ? void 0 : cardData.bvid, style, className: _className, css: _css, ...restProps, children: loading ? /* @__PURE__ */ jsx$1(SkeletonCard, { loading }) : item && cardData && (showingDislikeCard ? /* @__PURE__ */ jsx$1(DislikedCard, { item, cardData, emitter: emitter2, dislikedReason }) : showingBlacklistCard ? /* @__PURE__ */ jsx$1(BlacklistCard, { item, cardData }) : /* @__PURE__ */ jsx$1(VideoCardInner, { item, cardData, active, emitter: emitter2, sharedEmitter, tab: tab2, onRemoveCurrent, onMoveToFirst, onRefresh, watchlaterAdded, cardDisplay, multiSelecting, multiSelected })) });
  });
  var _ref$9 = {
    name: "vpmszz",
    styles: "background-color:unset;position:static;height:100%"
  };
  var _ref2$4 = {
    name: "he9puu",
    styles: "display:block;position:relative;overflow:hidden;isolation:isolate"
  };
  const VideoCardInner = H.memo(function VideoCardInner2({
    item,
    cardData,
    tab: tab2,
    active = false,
    onRemoveCurrent,
    onMoveToFirst,
    onRefresh,
    emitter: emitter2 = defaultEmitter,
    sharedEmitter = defaultSharedEmitter,
    watchlaterAdded,
    cardDisplay,
    multiSelecting = false,
    multiSelected
  }) {
    const {
      autoPreviewWhenHover,
      accessKey,
      style: {
        videoCard: {
          useBorder: cardUseBorder,
          useBorderOnlyOnHover: cardUseBorderOnlyOnHover
        }
      },
      videoCard: {
        actions: videoCardActions,
        videoPreview: {
          useMp4,
          __internal: {
            preferNormalCdn
          }
        }
      },
      spaceUpload: {
        showVol
      }
    } = useSettingsSnapshot();
    const authed = !!accessKey;
    const {
      // video
      avid,
      bvid,
      cid,
      goto,
      href,
      title,
      cover,
      duration: duration2,
      durationStr,
      recommendReason,
      // stat
      statItems,
      // author
      authorName,
      authorMid
    } = cardData;
    const isNormalVideo = goto === "av";
    const allowed = ["av", "bangumi", "picture", "live"];
    if (!allowed.includes(goto)) {
      appWarn(`none (${allowed.join(",")}) goto type %s`, goto, item);
    }
    const aspectRatioFromItem = H.useMemo(() => {
      var _a2;
      return (_a2 = getRecItemDimension({
        item
      })) == null ? void 0 : _a2.aspectRatio;
    }, [item]);
    const imagePreviewDataBox = useRefStateBox(void 0);
    const shouldFetchPreviewData = H.useMemo(() => {
      if (!bvid) return false;
      if (!bvid.startsWith("BV")) return false;
      if (goto !== "av") return false;
      return true;
    }, [bvid, goto]);
    const tryFetchImagePreviewData = useLockFn(async () => {
      if (!shouldFetchPreviewData) return;
      if (multiSelecting) return;
      if (isImagePreviewDataValid(imagePreviewDataBox.val)) return;
      const data2 = await fetchImagePreviewData(bvid);
      imagePreviewDataBox.set(data2);
      if (!isWebApiSuccess(data2.videoshotJson)) {
        warnNoPreview(data2.videoshotJson);
      }
    });
    const warnNoPreview = useLessFrequentFn((json) => {
      antNotification.warning({
        message: `${json.message} (code: ${json.code})`,
        description: `${title} (${bvid})`,
        duration: 2
      });
    }, 3, false);
    const cardRef = H.useRef(null);
    const coverRef = H.useRef(null);
    const videoPreviewWrapperRef = cardUseBorder && !isDisplayAsList(cardDisplay) ? cardRef : coverRef;
    const {
      onStartPreviewAnimation,
      onHotkeyPreviewAnimation,
      // flag
      isHovering,
      previewImageEl
    } = usePreviewRelated({
      uniqId: item.uniqId,
      sharedEmitter,
      title,
      active,
      videoDuration: duration2,
      tryFetchImagePreviewData,
      imagePreviewDataBox,
      autoPreviewWhenHover,
      videoPreviewWrapperRef
    });
    useUpdateEffect(() => {
      if (!active) return;
      setGlobalValue(`${APP_KEY_PREFIX}_activeItem`, item);
      if (settings.autoPreviewWhenKeyboardSelect) {
        tryFetchImagePreviewData().then(() => {
          onStartPreviewAnimation(false);
        });
      }
    }, [active]);
    const actionButtonVisible = active || isHovering;
    const {
      watchlaterButtonEl,
      onToggleWatchlater,
      hasWatchlaterEntry
    } = useWatchlaterRelated({
      item,
      cardData,
      onRemoveCurrent,
      actionButtonVisible,
      watchlaterAdded
    });
    const {
      dislikeButtonEl,
      hasDislikeEntry,
      onTriggerDislike
    } = useDislikeRelated({
      item,
      authed,
      actionButtonVisible
    });
    const {
      largePreviewActionButtonEl,
      largePreviewEl,
      shouldUseLargePreviewCurrentTime,
      getLargePreviewCurrentTime,
      largePreviewVisible,
      hideLargePreview
    } = useLargePreviewRelated({
      shouldFetchPreviewData,
      actionButtonVisible,
      hasLargePreviewActionButton: videoCardActions.showLargePreview,
      // required
      bvid,
      cid,
      uniqId: item.uniqId,
      sharedEmitter,
      // optional
      aspectRatioFromItem,
      cover,
      cardRef
    });
    const [favFolderNames, setFavFolderNames] = H.useState(void 0);
    const [favFolderUrls, setFavFolderUrls] = H.useState(void 0);
    const updateFavFolderNames = useMemoizedFn(async () => {
      if (item.api !== "watchlater") return;
      if (!avid) return;
      const result = await UserFavService.getVideoFavState(avid);
      if (result) {
        const {
          favFolderNames: favFolderNames2,
          favFolderUrls: favFolderUrls2
        } = result;
        setFavFolderNames(favFolderNames2);
        setFavFolderUrls(favFolderUrls2);
      }
    });
    const {
      onOpenWithMode,
      handleVideoLinkClick,
      consistentOpenMenus,
      conditionalOpenMenus,
      openInPopupActionButtonEl,
      onOpenInPopup
    } = useOpenRelated({
      href,
      item,
      cardData,
      actionButtonVisible,
      hasOpenInPopupActionButton: videoCardActions.openInPipWindow,
      getLargePreviewCurrentTime,
      hideLargePreview,
      shouldUseLargePreviewCurrentTime
    });
    const {
      multiSelectBgEl,
      multiSelectEl,
      toggleMultiSelect
    } = useMultiSelectRelated({
      multiSelecting,
      multiSelected,
      uniqId: item.uniqId
    });
    const handleCardClick = useMemoizedFn((e2) => {
      if (!cardUseBorder) return;
      if (e2.target.closest("a")) return;
      onOpenWithMode();
    });
    useMittOn(emitter2, "open", () => onOpenWithMode());
    useMittOn(emitter2, "open-in-popup", onOpenInPopup);
    useMittOn(emitter2, "open-with-large-preview-visible", () => {
      if (!largePreviewVisible) return;
      hideLargePreview();
      onOpenWithMode();
    });
    useMittOn(emitter2, "toggle-watch-later", () => onToggleWatchlater());
    useMittOn(emitter2, "trigger-dislike", () => onTriggerDislike());
    useMittOn(emitter2, "start-preview-animation", onStartPreviewAnimation);
    useMittOn(emitter2, "hotkey-preview-animation", onHotkeyPreviewAnimation);
    const contextMenus = useContextMenus({
      item,
      cardData,
      tab: tab2,
      isNormalVideo,
      onRefresh,
      watchlaterAdded,
      hasWatchlaterEntry,
      onToggleWatchlater,
      favFolderNames,
      favFolderUrls,
      onMoveToFirst,
      hasDislikeEntry,
      onTriggerDislike,
      onRemoveCurrent,
      consistentOpenMenus,
      conditionalOpenMenus,
      multiSelecting
    });
    const onContextMenuOpenChange = useMemoizedFn((open) => {
      if (!open) return;
      updateFavFolderNames();
    });
    const _isChargeOnly = isChargeOnlyVideo(item, recommendReason);
    const _isRank = isRank(item);
    const _isStreaming = (
      // 直播中
      isLive(item) && item.live_status === ELiveStatus.Streaming || isPcRecommend(item) && item.goto === PcRecGoto.Live
    );
    const hasVolMark = isSpaceUpload(item) && showVol || item.api === EApiType.Fav && !!item.vol;
    const topLeftMarksEl = /* @__PURE__ */ jsxs(Fragment, { children: [
      multiSelecting && multiSelectEl,
      dislikeButtonEl,
      _isChargeOnly && /* @__PURE__ */ jsx$1(ChargeOnlyTag, {}, "ChargeOnlyTag"),
      _isRank && /* @__PURE__ */ jsx$1(RankNumMark, { item }, "RankNumMark"),
      _isStreaming && /* @__PURE__ */ jsx$1(LiveBadge, {}, "LiveBadge"),
      tab2 === ETab.AppRecommend && !isAppRecommend(item) && !isLive(item) && /* @__PURE__ */ jsx$1(ApiTypeTag, { item }, "ApiTypeTag"),
      hasVolMark && !!item.vol && /* @__PURE__ */ jsx$1(VolMark, { vol: item.vol }, "VolMark")
    ] });
    const topRightActionsEl = /* @__PURE__ */ jsxs(Fragment, { children: [
      watchlaterButtonEl,
      openInPopupActionButtonEl,
      largePreviewActionButtonEl
    ] });
    const hasTopLeftMarks = !isEmptyFragment(topLeftMarksEl);
    const hasTopRightActions = !isEmptyFragment(topRightActionsEl);
    const watchlaterProgressBar = isWatchlater(item) && item.progress > 0 ? /* @__PURE__ */ jsx$1(SimplePregressBar, { progress: item.progress / item.duration, css: /* @__PURE__ */ css("z-index:", zIndexWatchlaterProgressBar, ";height:3px;", "") }) : void 0;
    const prefixCls = `.${APP_CLS_ROOT} .${APP_CLS_CARD}`;
    const coverBottomNoRoundCss = /* @__PURE__ */ css(prefixCls, " &{border-bottom-left-radius:0;border-bottom-right-radius:0;}", "");
    const coverRoundCss = [/* @__PURE__ */ css(prefixCls, " &{overflow:hidden;border-radius:", videoCardBorderRadiusValue, ";}", ""), !isDisplayAsList(cardDisplay) && (isHovering || active || multiSelecting || cardUseBorder && !cardUseBorderOnlyOnHover) && coverBottomNoRoundCss];
    const shouldMakeCoverClear = H.useMemo(() => {
      if (cardUseBorder && !cardUseBorderOnlyOnHover) return false;
      if (multiSelecting) return false;
      return !cardUseBorder || cardUseBorder && cardUseBorderOnlyOnHover && !isHovering;
    }, [cardUseBorder, cardUseBorderOnlyOnHover, isHovering, multiSelecting]);
    const target = useLinkTarget();
    const coverContent = /* @__PURE__ */ jsxs("a", { ref: (el) => coverRef.current = el, href, target, className: clsx(APP_CLS_CARD_COVER, shouldMakeCoverClear && "ring-1px ring-gate-border"), css: [_ref2$4, coverRoundCss, isDisplayAsList(cardDisplay) && displayAsListCss.cover, "", ""], onClick: handleVideoLinkClick, onContextMenu: (e2) => {
      e2.preventDefault();
    }, children: [
      /* @__PURE__ */ jsx$1("div", { className: "bili-video-card__image", style: {
        aspectRatio: "16 / 9"
      }, children: /* @__PURE__ */ jsx$1("div", { className: "bili-video-card__image--wrap", children: /* @__PURE__ */ jsx$1(Picture, { src: `${cover}@672w_378h_1c_!web-home-common-cover`, className: "v-img bili-video-card__cover", style: {
        borderRadius: 0
      }, imgProps: {
        // in firefox, alt text is visible during loading
        alt: isFirefox ? "" : title
      } }) }) }),
      /* @__PURE__ */ jsxs("div", { className: "bili-video-card__stats", css: [/* @__PURE__ */ css(prefixCls, " &{pointer-events:none;border-radius:0;}", ""), "", ""], children: [
        /* @__PURE__ */ jsx$1("div", { className: "bili-video-card__stats--left gap-x-4px xl:gap-x-8px", children: statItems.map(({
          field,
          value
        }) => /* @__PURE__ */ jsx$1(StatItemDisplay, { field, value }, field)) }),
        /* @__PURE__ */ jsx$1("span", { className: "bili-video-card__stats__duration relative top-0.5px", children: isNormalVideo && durationStr })
      ] }),
      watchlaterProgressBar,
      !multiSelecting && previewImageEl,
      multiSelectBgEl,
      hasTopLeftMarks && /* @__PURE__ */ jsx$1("div", { className: "left-top-marks", css: S$5.topContainer("left"), style: {
        columnGap: multiSelecting ? 10 : void 0
      }, children: topLeftMarksEl }),
      hasTopRightActions && /* @__PURE__ */ jsx$1("div", { className: "right-actions", css: S$5.topContainer("right"), children: topRightActionsEl })
    ] });
    const bottomContent = /* @__PURE__ */ jsx$1(VideoCardBottom, { item, cardData, handleVideoLinkClick: multiSelecting ? toggleMultiSelect : handleVideoLinkClick });
    const extraContent = /* @__PURE__ */ jsx$1(Fragment, { children: largePreviewEl });
    function wrapDropdown(c2) {
      return /* @__PURE__ */ jsx$1(antd.Dropdown, { getPopupContainer: () => {
        if (isSafari) return document.body;
        return cardRef.current || document.body;
      }, overlayStyle: {
        zIndex: Number(zIndexVideoCardContextMenu)
      }, menu: {
        items: contextMenus,
        style: {
          // 需要设置宽度, 否则闪屏
          width: "max-content"
        }
      }, trigger: ["contextMenu"], onOpenChange: onContextMenuOpenChange, children: c2 });
    }
    function wrapCardWrapper(c2) {
      return /* @__PURE__ */ jsx$1("div", { className: "bili-video-card__wrap", ref: (el) => cardRef.current = el, css: [_ref$9, isDisplayAsList(cardDisplay) && displayAsListCss.cardWrap, "", ""], onClick: multiSelecting ? toggleMultiSelect : handleCardClick, onContextMenu: (e2) => {
        if (cardUseBorder) {
          e2.preventDefault();
        }
      }, children: c2 });
    }
    const wrappedContent = cardUseBorder && !isDisplayAsList(cardDisplay) ? wrapDropdown(wrapCardWrapper(/* @__PURE__ */ jsxs(Fragment, { children: [
      coverContent,
      bottomContent
    ] }))) : wrapCardWrapper(/* @__PURE__ */ jsxs(Fragment, { children: [
      wrapDropdown(coverContent),
      bottomContent
    ] }));
    return /* @__PURE__ */ jsxs(Fragment, { children: [
      wrappedContent,
      extraContent
    ] });
  });
  var observerMap = /* @__PURE__ */ new Map();
  var RootIds = /* @__PURE__ */ new WeakMap();
  var rootId = 0;
  var unsupportedValue = void 0;
  function getRootId(root2) {
    if (!root2) return "0";
    if (RootIds.has(root2)) return RootIds.get(root2);
    rootId += 1;
    RootIds.set(root2, rootId.toString());
    return RootIds.get(root2);
  }
  function optionsToId(options) {
    return Object.keys(options).sort().filter(
      (key) => options[key] !== void 0
    ).map((key) => {
      return `${key}_${key === "root" ? getRootId(options.root) : options[key]}`;
    }).toString();
  }
  function createObserver(options) {
    const id = optionsToId(options);
    let instance = observerMap.get(id);
    if (!instance) {
      const elements = /* @__PURE__ */ new Map();
      let thresholds;
      const observer = new IntersectionObserver((entries) => {
        entries.forEach((entry) => {
          var _a2;
          const inView = entry.isIntersecting && thresholds.some((threshold) => entry.intersectionRatio >= threshold);
          if (options.trackVisibility && typeof entry.isVisible === "undefined") {
            entry.isVisible = inView;
          }
          (_a2 = elements.get(entry.target)) == null ? void 0 : _a2.forEach((callback) => {
            callback(inView, entry);
          });
        });
      }, options);
      thresholds = observer.thresholds || (Array.isArray(options.threshold) ? options.threshold : [options.threshold || 0]);
      instance = {
        id,
        observer,
        elements
      };
      observerMap.set(id, instance);
    }
    return instance;
  }
  function observe(element, callback, options = {}, fallbackInView = unsupportedValue) {
    if (typeof window.IntersectionObserver === "undefined" && fallbackInView !== void 0) {
      const bounds = element.getBoundingClientRect();
      callback(fallbackInView, {
        isIntersecting: fallbackInView,
        target: element,
        intersectionRatio: typeof options.threshold === "number" ? options.threshold : 0,
        time: 0,
        boundingClientRect: bounds,
        intersectionRect: bounds,
        rootBounds: bounds
      });
      return () => {
      };
    }
    const { id, observer, elements } = createObserver(options);
    const callbacks = elements.get(element) || [];
    if (!elements.has(element)) {
      elements.set(element, callbacks);
    }
    callbacks.push(callback);
    observer.observe(element);
    return function unobserve() {
      callbacks.splice(callbacks.indexOf(callback), 1);
      if (callbacks.length === 0) {
        elements.delete(element);
        observer.unobserve(element);
      }
      if (elements.size === 0) {
        observer.disconnect();
        observerMap.delete(id);
      }
    };
  }
  function useInView({
    threshold,
    delay: delay2,
    trackVisibility,
    rootMargin,
    root: root2,
    triggerOnce,
    skip,
    initialInView,
    fallbackInView,
    onChange
  } = {}) {
    var _a2;
    const [ref, setRef] = H__namespace.useState(null);
    const callback = H__namespace.useRef(onChange);
    const [state2, setState] = H__namespace.useState({
      inView: !!initialInView,
      entry: void 0
    });
    callback.current = onChange;
    H__namespace.useEffect(
      () => {
        if (skip || !ref) return;
        let unobserve;
        unobserve = observe(
          ref,
          (inView, entry) => {
            setState({
              inView,
              entry
            });
            if (callback.current) callback.current(inView, entry);
            if (entry.isIntersecting && triggerOnce && unobserve) {
              unobserve();
              unobserve = void 0;
            }
          },
          {
            root: root2,
            rootMargin,
            threshold,
            // @ts-ignore
            trackVisibility,
            // @ts-ignore
            delay: delay2
          },
          fallbackInView
        );
        return () => {
          if (unobserve) {
            unobserve();
          }
        };
      },
      // We break the rule here, because we aren't including the actual `threshold` variable
      // eslint-disable-next-line react-hooks/exhaustive-deps
      [
        // If the threshold is an array, convert it to a string, so it won't change between renders.
        Array.isArray(threshold) ? threshold.toString() : threshold,
        ref,
        root2,
        rootMargin,
        triggerOnce,
        skip,
        trackVisibility,
        fallbackInView,
        delay2
      ]
    );
    const entryTarget = (_a2 = state2.entry) == null ? void 0 : _a2.target;
    const previousEntryTarget = H__namespace.useRef(void 0);
    if (!ref && entryTarget && !triggerOnce && !skip && previousEntryTarget.current !== entryTarget) {
      previousEntryTarget.current = entryTarget;
      setState({
        inView: !!initialInView,
        entry: void 0
      });
    }
    const result = [setRef, state2.inView, state2.entry];
    result.ref = result[0];
    result.inView = result[1];
    result.entry = result[2];
    return result;
  }
  ({
    List: H.forwardRef(({
      context: ctx,
      children,
      ...props
    }, ref) => {
      function setForwardedRef2(el) {
        if (!ref) return;
        if (typeof ref === "function") {
          ref(el);
        } else {
          ref.current = el;
        }
      }
      return /* @__PURE__ */ jsx$1("div", { ref: (el) => {
        setForwardedRef2(el);
        ctx.containerRef.current = el;
      }, ...props, className: ctx.gridClassName, children });
    })
  });
  const iconParkOutlineLoading = (props, ref) => /* @__PURE__ */ jsx$1("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref, ...props, children: /* @__PURE__ */ jsxs("g", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 4, children: [
    /* @__PURE__ */ jsx$1("path", { d: "M4 24c0 11.046 8.954 20 20 20v0c11.046 0 20-8.954 20-20S35.046 4 24 4" }),
    /* @__PURE__ */ jsx$1("path", { d: "M36 24c0-6.627-5.373-12-12-12s-12 5.373-12 12s5.373 12 12 12v0" })
  ] }) });
  const ForwardRef$c = H.forwardRef(iconParkOutlineLoading);
  const tablerFaceIdError = (props, ref) => /* @__PURE__ */ jsx$1("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref, ...props, children: /* @__PURE__ */ jsx$1("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M4 8V6a2 2 0 0 1 2-2h2M4 16v2a2 2 0 0 0 2 2h2m8-16h2a2 2 0 0 1 2 2v2m-4 12h2a2 2 0 0 0 2-2v-2M9 10h.01M15 10h.01M9.5 15.05a3.5 3.5 0 0 1 5 0" }) });
  const ForwardRef$b = H.forwardRef(tablerFaceIdError);
  const debug$3 = baseDebug.extend("components:RecGrid");
  const initHeaderState = () => ({
    refreshing: false,
    onRefresh: noop$1,
    extraInfo: null
  });
  const RecGrid = H.forwardRef(function(props, ref) {
    const servicesRegistry = useRefStateBox(() => ({}));
    const tab2 = H.useDeferredValue(useCurrentUsingTab());
    const prevTab = usePrevious$1(tab2);
    const tabOrders = useSortedTabKeys();
    const direction = H.useMemo(() => {
      return prevTab ? tabOrders.indexOf(tab2) > tabOrders.indexOf(prevTab) ? "right" : "left" : void 0;
    }, [tabOrders, tab2]);
    return /* @__PURE__ */ jsx$1(RecGridInner, { tab: tab2, direction, handlersRef: ref, servicesRegistry, ...props }, tab2);
  });
  var _ref$8 = {
    name: "nuv8c9",
    styles: ".ant-divider-inner-text{display:inline-flex;align-items:center;min-height:30px;a{color:var(--ant-color-link);&:hover{color:var(--ant-color-primary);}}}"
  };
  const RecGridInner = H.memo(function({
    shortcutEnabled,
    className,
    tab: tab2,
    handlersRef,
    servicesRegistry,
    infiniteScrollUseWindow,
    onScrollToTop,
    scrollerRef,
    onSyncHeaderState
  }) {
    const unmountedRef = useUnmountedRef();
    const {
      cardDisplay
    } = useSnapshot(settings.style.pureRecommend);
    const {
      multiSelecting
    } = useSnapshot(multiSelectStore);
    const loadCompleteCountBox = useRefStateBox(0);
    const [extraInfo, setExtraInfo] = H.useState(void 0);
    const updateExtraInfo = useMemoizedFn(() => {
      var _a2;
      setExtraInfo((_a2 = servicesRegistry.val[tab2]) == null ? void 0 : _a2.usageInfo);
    });
    const preAction = useMemoizedFn(() => {
      clearActiveIndex();
      updateExtraInfo();
      onScrollToTop == null ? void 0 : onScrollToTop();
    });
    const postAction = useMemoizedFn(() => {
      clearActiveIndex();
      updateExtraInfo();
      loadCompleteCountBox.set(1);
      setTimeout(checkShouldLoadMore);
    });
    const {
      itemsBox,
      error: refreshError,
      refresh,
      hasMoreBox,
      refreshingBox,
      refreshTsBox,
      refreshAbortController,
      showSkeleton,
      beforeMount
    } = useRefresh({
      tab: tab2,
      servicesRegistry,
      debug: debug$3,
      fetcher: refreshForGrid,
      // actions
      preAction,
      postAction,
      updateExtraInfo
    });
    H.useImperativeHandle(handlersRef, () => ({
      refresh
    }), [refresh]);
    const refreshing = refreshingBox.state;
    const hasMore = hasMoreBox.state;
    H.useEffect(() => {
      if (unmountedRef.current) return;
      onSyncHeaderState == null ? void 0 : onSyncHeaderState({
        refreshing,
        onRefresh: refresh,
        extraInfo
      });
    }, [refreshing, refresh, extraInfo, onSyncHeaderState]);
    const goOutAt = H.useRef();
    useEventListener("visibilitychange", (e2) => {
      const visible = document.visibilityState === "visible";
      if (!visible) {
        goOutAt.current = Date.now();
        return;
      }
      if (refreshingBox.val) return;
      if (loadMoreLocker.current[refreshTsBox.val]) return;
      if (tab2 === ETab.Watchlater && goOutAt.current && Date.now() - goOutAt.current > ms("1h")) {
        refresh(true);
      }
    }, {
      target: document
    });
    const checkShouldLoadMore = useMemoizedFn(async () => {
      await delay(isSafari ? 100 : 0);
      debug$3("checkShouldLoadMore(): footerInView = %s", footerInViewRef.current);
      if (footerInViewRef.current) {
        loadMore();
      }
    });
    const loadMoreLocker = H.useRef({});
    const lock = H.useCallback((lockKey) => loadMoreLocker.current = {
      [lockKey]: true
    }, []);
    const unlock = H.useCallback((lockKey) => loadMoreLocker.current[lockKey] = false, []);
    const isLocked = useMemoizedFn((lockKey) => !!loadMoreLocker.current[lockKey]);
    const loadMore = useMemoizedFn(async () => {
      if (unmountedRef.current) return;
      if (!hasMoreBox.val) return;
      if (refreshAbortController.signal.aborted) return;
      if (refreshingBox.val) return;
      const getState = () => ({
        refreshTs: refreshTsBox.val
      });
      const startingState = getState();
      const lockKey = startingState.refreshTs;
      if (isLocked(lockKey)) return;
      lock(lockKey);
      let newItems = itemsBox.val;
      let newHasMore = true;
      let err;
      try {
        const service = getServiceFromRegistry(servicesRegistry, tab2);
        let more = await service.loadMore(refreshAbortController.signal) || [];
        more = filterRecItems(more, tab2);
        newItems = concatThenUniq(newItems, more);
        newHasMore = service.hasMore;
      } catch (e2) {
        err = e2;
      }
      if (err) {
        unlock(lockKey);
        throw err;
      }
      {
        const currentState = getState();
        if (!isEqual$2(startingState, currentState)) {
          debug$3("loadMore: skip update for mismatch refresh state, %o != %o", startingState, currentState);
          unlock(lockKey);
          return;
        }
      }
      debug$3("loadMore: seq(%s) len %s -> %s", loadCompleteCountBox.val + 1, itemsBox.val.length, newItems.length);
      hasMoreBox.set(newHasMore);
      itemsBox.set(newItems);
      loadCompleteCountBox.set((c2) => c2 + 1);
      unlock(lockKey);
      checkShouldLoadMore();
    });
    const usingItems = itemsBox.state;
    const containerRef = H.useRef(null);
    const getScrollerRect = useMemoizedFn(() => {
      var _a2;
      if (infiniteScrollUseWindow) {
        const yStart = $headerHeight.get() + 50;
        return new DOMRect(0, yStart, window.innerWidth, window.innerHeight - yStart);
      } else {
        return (_a2 = scrollerRef == null ? void 0 : scrollerRef.current) == null ? void 0 : _a2.getBoundingClientRect();
      }
    });
    const modalDislikeVisible = useModalDislikeVisible();
    const usingVideoItems = H.useMemo(() => {
      return usingItems.filter((x) => x.api !== EApiType.Separator);
    }, [usingItems]);
    const emitterCache = H.useMemo(() => /* @__PURE__ */ new Map(), [refreshTsBox.state]);
    const videoCardEmitters = H.useMemo(() => {
      return usingVideoItems.map(({
        uniqId
      }) => {
        const cacheKey2 = uniqId;
        return emitterCache.get(cacheKey2) || (() => {
          const instance = mitt();
          emitterCache.set(cacheKey2, instance);
          return instance;
        })();
      });
    }, [usingVideoItems]);
    const sharedEmitter = H.useMemo(() => createSharedEmitter(), []);
    H.useEffect(() => setCurrentGridSharedEmitter(sharedEmitter), [sharedEmitter]);
    const [activeLargePreviewUniqId, setActiveLargePreviewUniqId] = H.useState(void 0);
    useMittOn(sharedEmitter, "show-large-preview", setActiveLargePreviewUniqId);
    const activeLargePreviewItemIndex = H.useMemo(() => {
      if (!activeLargePreviewUniqId) return;
      return usingVideoItems.findIndex((item) => item.uniqId === activeLargePreviewUniqId);
    }, [usingItems, activeLargePreviewUniqId]);
    const {
      activeIndex,
      clearActiveIndex
    } = useShortcut({
      enabled: shortcutEnabled && !modalDislikeVisible,
      refresh,
      maxIndex: usingVideoItems.length - 1,
      containerRef,
      getScrollerRect,
      videoCardEmitters,
      activeLargePreviewItemIndex,
      changeScrollY: infiniteScrollUseWindow ? function({
        offset,
        absolute
      }) {
        const scroller = document.documentElement;
        if (typeof offset === "number") {
          scroller.scrollTop += offset;
          return;
        }
        if (typeof absolute === "number") {
          scroller.scrollTop = absolute;
          return;
        }
      } : void 0
    });
    const setItems = itemsBox.set;
    const handleRemoveCards = useMemoizedFn((uniqIds, titles) => {
      setItems((items) => {
        var _a2, _b2;
        const newItems = items.slice();
        const removedTitles = [];
        for (const [i2, uniqId] of uniqIds.entries()) {
          const index = newItems.findIndex((x) => x.uniqId === uniqId);
          if (index === -1) continue;
          newItems.splice(index, 1);
          const title = titles == null ? void 0 : titles[i2];
          if (title) removedTitles.push(title);
          if (tab2 === ETab.Watchlater) {
            (_a2 = servicesRegistry.val[tab2]) == null ? void 0 : _a2.decreaseTotal();
          }
          if (tab2 === ETab.Fav) {
            (_b2 = servicesRegistry.val[tab2]) == null ? void 0 : _b2.decreaseTotal();
          }
        }
        if (removedTitles.length) {
          if (removedTitles.length <= 3) {
            removedTitles.forEach((t2) => antMessage.success(`已移除: ${removedTitles.join(", ")}`));
          } else {
            antMessage.success(`已移除: ${removedTitles.length}个视频`);
          }
        }
        return newItems;
      });
    });
    const handleMoveCardToFirst = useMemoizedFn((item, data2) => {
      setItems((items) => {
        const currentItem = items.find((x) => x.uniqId === item.uniqId);
        if (!currentItem) return items;
        const index = items.indexOf(currentItem);
        const newItems = items.slice();
        newItems.splice(index, 1);
        const newIndex = newItems.findIndex((x) => x.api !== EApiType.Separator);
        newItems.splice(newIndex, 0, currentItem);
        return newItems;
      });
    });
    useMittOn(sharedEmitter, "remove-cards", ([uniqIds, titles]) => handleRemoveCards(uniqIds, titles));
    const {
      ref: footerRef,
      inView: __footerInView
    } = useInView({
      root: infiniteScrollUseWindow ? null : (scrollerRef == null ? void 0 : scrollerRef.current) || null,
      rootMargin: `0px 0px ${window.innerHeight}px 0px`,
      onChange(inView) {
        if (inView) {
          debug$3("footerInView change to visible", inView);
          setTimeout(checkShouldLoadMore);
        }
      }
    });
    const footerInViewRef = useLatest(__footerInView);
    const footer = /* @__PURE__ */ jsx$1("div", { ref: footerRef, className: "flex items-center justify-center py-30px text-size-120% grid-col-span-full", children: !refreshing && /* @__PURE__ */ jsx$1(Fragment, { children: hasMore ? /* @__PURE__ */ jsxs(Fragment, { children: [
      /* @__PURE__ */ jsx$1(ForwardRef$c, { className: "size-40px animate-spin mr-10px color-gate-primary" }),
      "加载中~"
    ] }) : /* @__PURE__ */ jsx$1(Fragment, { children: "没有更多了~" }) }) });
    const {
      useNarrowMode,
      style
    } = useSettingsSnapshot();
    const gridClassName = clsx(
      APP_CLS_GRID,
      // for customize css
      videoGrid,
      style.pureRecommend.useCustomGrid ? videoGridCustom : videoGridBiliFeed4,
      useNarrowMode && narrowMode,
      // 居中
      className
    );
    const cardBorderCss = useCardBorderCss();
    H.useMemo(() => {
      return {
        footerContent: footer,
        containerRef,
        gridClassName
        // renderItem,
      };
    }, [footer, containerRef, gridClassName]);
    const render5 = ({
      gridChildren,
      gridSiblings
    } = {}) => {
      return /* @__PURE__ */ jsxs("div", { ref: containerRef, className: clsx("min-h-100vh", videoGridContainer), "data-tab": tab2, children: [
        /* @__PURE__ */ jsx$1("div", { className: gridClassName, "data-tab": tab2, children: gridChildren }),
        gridSiblings
      ] });
    };
    if (beforeMount) {
      return render5();
    }
    if (refreshError) {
      console.error("RecGrid.refresh error:", refreshError.stack || refreshError);
      return render5({
        gridSiblings: /* @__PURE__ */ jsx$1(ErrorDetail, { tab: tab2, err: refreshError })
      });
    }
    if (refreshing && showSkeleton) {
      const cardCount = getGridRefreshCount();
      return render5({
        gridChildren: Array.from({
          length: cardCount
        }).fill(0).map((_, index) => {
          return /* @__PURE__ */ jsx$1(VideoCard, { loading: true, tab: tab2 }, index);
        })
      });
    }
    const renderItem = (item) => {
      if (item.api === EApiType.Separator) {
        return /* @__PURE__ */ jsx$1(antd.Divider, { className: "grid-col-span-full", css: _ref$8, orientation: "left", children: item.content }, item.uniqId);
      } else {
        const index = usingVideoItems.findIndex((x) => x.uniqId === item.uniqId);
        const active = index === activeIndex;
        return /* @__PURE__ */ jsx$1(VideoCard, { baseCss: [cardBorderCss, getActiveCardBorderCss(active)], tab: tab2, item, active, onRemoveCurrent: (item2, data2) => handleRemoveCards([item2.uniqId], [data2.title]), onMoveToFirst: handleMoveCardToFirst, onRefresh: refresh, emitter: videoCardEmitters[index], sharedEmitter, cardDisplay, multiSelecting }, item.uniqId);
      }
    };
    return render5({
      gridChildren: usingItems.map((item) => renderItem(item)),
      gridSiblings: footer
    });
  });
  const isAxiosError = (err) => {
    return err instanceof Error && err.name === "AxiosError";
  };
  function inspectErr(err) {
    var _a2, _b2;
    const nodes = [];
    const wrapParagraph = (key, node2) => /* @__PURE__ */ jsx$1("p", { className: "mt-10px", children: node2 });
    if (!(err instanceof Error)) {
      nodes.push(/* @__PURE__ */ jsx$1(H.Fragment, { children: JSON.stringify(err) }, "json-stringify-err"));
    } else {
      if (err.stack) {
        nodes.push(wrapParagraph("error-stack", /* @__PURE__ */ jsxs(Fragment, { children: [
          "Error Stack: ",
          /* @__PURE__ */ jsx$1("br", {}),
          err.stack
        ] })));
      } else {
        nodes.push(wrapParagraph("error-message", /* @__PURE__ */ jsxs(Fragment, { children: [
          "Error Message: ",
          err.message
        ] })));
      }
      if (err.cause) {
        nodes.push(wrapParagraph("error-cause", /* @__PURE__ */ jsxs(Fragment, { children: [
          "Error Cause: ",
          inspectErr(err.cause)
        ] })));
      }
      if (isAxiosError(err)) {
        const _err = cloneDeep(err);
        if ((_b2 = (_a2 = _err.config) == null ? void 0 : _a2.params) == null ? void 0 : _b2.access_key) {
          _err.config.params.access_key = "*".repeat(_err.config.params.access_key.length);
        }
        nodes.push(wrapParagraph("axios-config", /* @__PURE__ */ jsxs(Fragment, { children: [
          "axios config: ",
          JSON.stringify(_err.config, null, 2)
        ] })));
      }
    }
    return nodes;
  }
  function ErrorDetail({
    err,
    tab: tab2
  }) {
    const target = useLinkTarget();
    const errDetail = H.useMemo(() => inspectErr(err), [err]);
    return /* @__PURE__ */ jsxs("div", { className: "text-center text-size-20px p-20px", children: [
      /* @__PURE__ */ jsx$1(AntdTooltip, { title: /* @__PURE__ */ jsxs("div", { className: "py-10px", children: [
        /* @__PURE__ */ jsx$1("h3", { children: "错误详情" }),
        /* @__PURE__ */ jsx$1("div", { className: "overflow-hidden whitespace-pre-wrap break-normal max-h-50vh overflow-y-auto", children: errDetail })
      ] }), children: /* @__PURE__ */ jsxs("p", { className: "cursor-pointer flex items-center justify-center", children: [
        /* @__PURE__ */ jsx$1(ForwardRef$b, { className: "mr-4px" }),
        "出错了, 请刷新重试!"
      ] }) }),
      tab2 === ETab.Hot && hotStore.subtab === EHotSubTab.PopularWeekly && /* @__PURE__ */ jsxs("p", { className: "mt-8px flex items-center justify-center", children: [
        "可能需手动输入验证码",
        /* @__PURE__ */ jsx$1(IconForOpenExternalLink, { className: "ml-12px" }),
        /* @__PURE__ */ jsx$1("a", { href: "https://www.bilibili.com/v/popular/weekly", target, className: "ml-2px", children: "每周必看" })
      ] })
    ] });
  }
  function useSizeExpression(target, fn, initialValue2) {
    const _fn = useMemoizedFn(fn);
    const box = useRefStateBox(initialValue2);
    H.useEffect(() => {
      const observer = new ResizeObserver((entries) => {
        for (const entry of entries) {
          if (entry.target === target && entry.contentRect) {
            const val = _fn(entry);
            if (!isEqual$2(box.val, val)) {
              box.set(val);
            }
          }
        }
      });
      observer.observe(target);
      return () => {
        observer.disconnect();
      };
    }, [target, _fn]);
    return box.state;
  }
  function useSticky() {
    const stickyRef = H.useRef(null);
    const [sticky, setSticky] = H.useState(false);
    H.useEffect(() => {
      function observe2() {
        if (!stickyRef.current) return;
        const refPageOffset = Math.trunc(stickyRef.current.getBoundingClientRect().top * 10) / 10;
        const stickyOffset = parseInt(getComputedStyle(stickyRef.current).top);
        const stickyActive = refPageOffset <= stickyOffset;
        setSticky(stickyActive);
      }
      observe2();
      document.addEventListener("scroll", observe2);
      window.addEventListener("resize", observe2);
      window.addEventListener("orientationchange", observe2);
      return () => {
        document.removeEventListener("scroll", observe2);
        window.removeEventListener("resize", observe2);
        window.removeEventListener("orientationchange", observe2);
      };
    }, [sticky]);
    return [stickyRef, sticky];
  }
  function CollapsePanel({
    expanded,
    children,
    ...props
  }) {
    return /* @__PURE__ */ jsx$1("div", { ...props, "data-classname": "wrapper", css: /* @__PURE__ */ css("transition:grid-template-rows 0.2s ease-out;display:grid;grid-template-rows:", expanded ? 1 : 0, "fr;", ""), children: /* @__PURE__ */ jsx$1("div", { "data-classname": "inner", className: "overflow-hidden", children }) });
  }
  async function toastAndReload(msg = "即将刷新网页!") {
    antMessage.info(msg);
    await delay(500);
    location.reload();
  }
  function explainForFlag(checked, unchecked) {
    return /* @__PURE__ */ jsxs(Fragment, { children: [
      "✅: ",
      checked,
      " ",
      /* @__PURE__ */ jsx$1("br", {}),
      "❎: ",
      unchecked,
      " ",
      /* @__PURE__ */ jsx$1("br", {})
    ] });
  }
  let lastUrl;
  function genUrl() {
    tryit(() => {
      if (lastUrl) URL.revokeObjectURL(lastUrl);
      lastUrl = void 0;
    })();
    const val = getSettingsSnapshot();
    const json = JSON.stringify(val, null, 2);
    const blob = new Blob([json], {
      type: "application/json"
    });
    lastUrl = URL.createObjectURL(blob);
    return lastUrl;
  }
  async function exportSettings() {
    const url = genUrl();
    const filename = `${APP_NAME}-settings ${dayjs().format("YYYY-MM-DD HH:mm:ss")}.json`;
    if (typeof GM_download !== "undefined") {
      GM_download == null ? void 0 : GM_download({
        url,
        name: filename
      });
    } else {
      const link = document.createElement("a");
      link.href = url;
      link.download = filename;
      link.click();
    }
  }
  async function importSettings() {
    const file = await chooseSingleJsonFile();
    if (!file) return;
    const text = await file.text();
    if (!text) return toast("文件内容为空!");
    let settingsFromFile;
    try {
      settingsFromFile = JSON.parse(text);
    } catch (error) {
      return toast("无法解析文件内容!");
    }
    runSettingsMigration(settingsFromFile);
    const {
      pickedPaths,
      pickedSettings
    } = pickSettings(settingsFromFile, allowedLeafSettingsPaths);
    if (!pickedPaths.length) {
      return toast("没有有效的设置!");
    }
    set_HAS_RESTORED_SETTINGS(true);
    updateSettings(pickedSettings);
    antMessage.success("导入成功!");
    return toastAndReload();
  }
  function chooseSingleJsonFile() {
    return chooseFile({
      accept: ".json",
      multiple: false
    });
  }
  function chooseFile(options) {
    return new Promise((resolve) => {
      const input = document.createElement("input");
      input.type = "file";
      Object.assign(input, options);
      input.addEventListener("change", () => {
        var _a2;
        resolve(((_a2 = input.files) == null ? void 0 : _a2[0]) || null);
      });
      input.click();
    });
  }
  const S$1 = {
    tabPane: /* @__PURE__ */ css("overflow-y:auto;min-height:362px;max-height:max(362px, calc(90vh - ", 50 + 56 + 15, "px));", ""),
    settingsGroup: {
      name: "pr10xp",
      styles: "margin-bottom:10px"
    },
    settingsGroupTitle: {
      name: "1njdmmk",
      styles: "font-size:2em;display:flex;align-items:center"
    },
    settingsGroupSubTitle: {
      name: "q5l76e",
      styles: "font-size:1.3em;display:flex;align-items:center;margin-top:15px"
    },
    settingsGroupContent: {
      name: "99q1m7",
      styles: "color:default;button:first-child{margin-left:0;}"
    }
  };
  function SettingsGroup({
    children,
    title,
    titleCss,
    titleClassName,
    contentCss,
    contentClassName,
    ...rest
  }) {
    return /* @__PURE__ */ jsxs("div", { css: S$1.settingsGroup, "data-role": "settings-group", ...rest, children: [
      /* @__PURE__ */ jsx$1("div", { "data-role": "settings-group-title", className: titleClassName, css: [S$1.settingsGroupTitle, titleCss, "", ""], children: title }),
      /* @__PURE__ */ jsx$1("div", { css: [S$1.settingsGroupContent, contentCss, "", ""], "data-role": "settings-group-content", className: n("flex flex-col gap-y-5px", contentClassName), children })
    ] });
  }
  function resetPartialSettings(paths) {
    const {
      pickedSettings
    } = pickSettings(initialSettings, paths);
    updateSettings(pickedSettings);
  }
  var _ref$7 = {
    name: "1opo4ia",
    styles: "column-gap:4px"
  };
  function ResetPartialSettingsButton({
    paths,
    className
  }) {
    return /* @__PURE__ */ jsx$1(antd.Popconfirm, { title: "确定重置下面的设置项?", onConfirm: () => resetPartialSettings(paths), children: /* @__PURE__ */ jsxs(antd.Button, { className, css: _ref$7, children: [
      /* @__PURE__ */ jsx$1(ForwardRef$R, { className: "size-12px mt--1px" }),
      /* @__PURE__ */ jsx$1("span", { children: "重置" })
    ] }) });
  }
  const tablerRestore = (props, ref) => /* @__PURE__ */ jsx$1("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref, ...props, children: /* @__PURE__ */ jsxs("g", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, children: [
    /* @__PURE__ */ jsx$1("path", { d: "M3.06 13a9 9 0 1 0 .49-4.087" }),
    /* @__PURE__ */ jsx$1("path", { d: "M3 4.001v5h5M11 12a1 1 0 1 0 2 0a1 1 0 1 0-2 0" })
  ] }) });
  const ForwardRef$a = H.forwardRef(tablerRestore);
  const tablerFileExport = (props, ref) => /* @__PURE__ */ jsx$1("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref, ...props, children: /* @__PURE__ */ jsxs("g", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, children: [
    /* @__PURE__ */ jsx$1("path", { d: "M14 3v4a1 1 0 0 0 1 1h4" }),
    /* @__PURE__ */ jsx$1("path", { d: "M11.5 21H7a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h7l5 5v5m-5 6h7m-3-3l3 3l-3 3" })
  ] }) });
  const ForwardRef$9 = H.forwardRef(tablerFileExport);
  const tablerFileImport = (props, ref) => /* @__PURE__ */ jsx$1("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref, ...props, children: /* @__PURE__ */ jsxs("g", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, children: [
    /* @__PURE__ */ jsx$1("path", { d: "M14 3v4a1 1 0 0 0 1 1h4" }),
    /* @__PURE__ */ jsx$1("path", { d: "M5 13V5a2 2 0 0 1 2-2h7l5 5v11a2 2 0 0 1-2 2h-5.5M2 19h7m-3-3l3 3l-3 3" })
  ] }) });
  const ForwardRef$8 = H.forwardRef(tablerFileImport);
  const icOutlineCloud = (props, ref) => /* @__PURE__ */ jsx$1("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref, ...props, children: /* @__PURE__ */ jsx$1("path", { fill: "currentColor", d: "M12 6c2.62 0 4.88 1.86 5.39 4.43l.3 1.5l1.53.11A2.98 2.98 0 0 1 22 15c0 1.65-1.35 3-3 3H6c-2.21 0-4-1.79-4-4c0-2.05 1.53-3.76 3.56-3.97l1.07-.11l.5-.95A5.47 5.47 0 0 1 12 6m0-2C9.11 4 6.6 5.64 5.35 8.04A5.994 5.994 0 0 0 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5c0-2.64-2.05-4.78-4.65-4.96A7.49 7.49 0 0 0 12 4" }) });
  const ForwardRef$7 = H.forwardRef(icOutlineCloud);
  const iconParkOutlineDownC = (props, ref) => /* @__PURE__ */ jsx$1("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref, ...props, children: /* @__PURE__ */ jsxs("g", { fill: "none", stroke: "currentColor", strokeLinejoin: "round", strokeWidth: 4, children: [
    /* @__PURE__ */ jsx$1("path", { d: "M24 44c11.046 0 20-8.954 20-20S35.046 4 24 4S4 12.954 4 24s8.954 20 20 20Z" }),
    /* @__PURE__ */ jsx$1("path", { strokeLinecap: "round", d: "m33 21l-9 9l-9-9" })
  ] }) });
  const ForwardRef$6 = H.forwardRef(iconParkOutlineDownC);
  function onResetSettings() {
    resetSettings();
    return toastAndReload();
  }
  async function onRestoreSettings() {
    const remoteSettings = await articleDraft.getData();
    runSettingsMigration(remoteSettings);
    const {
      pickedPaths,
      pickedSettings
    } = pickSettings(remoteSettings, allowedLeafSettingsPaths, restoreOmitPaths);
    if (!pickedPaths.length) {
      return antMessage.error("备份不存在或没有有效的配置");
    }
    set_HAS_RESTORED_SETTINGS(true);
    updateSettings(pickedSettings);
    return toastAndReload();
  }
  function TabPaneAdvance() {
    const {
      autoPreviewUpdateInterval
    } = useSettingsSnapshot();
    const [internalKeysExpanded, setInternalKeysExpanded] = H.useState(false);
    return /* @__PURE__ */ jsxs("div", { css: S$1.tabPane, children: [
      /* @__PURE__ */ jsx$1(SettingsGroup, { title: "设置项", children: /* @__PURE__ */ jsxs(antd.Space, { size: 20, children: [
        /* @__PURE__ */ jsx$1(antd.Popconfirm, { title: "确定", description: "确定恢复默认设置? 此操作不可逆!", onConfirm: onResetSettings, children: /* @__PURE__ */ jsxs(antd.Button, { danger: true, type: "primary", children: [
          /* @__PURE__ */ jsx$1(ForwardRef$a, {}),
          "恢复默认设置"
        ] }) }),
        /* @__PURE__ */ jsxs(antd.Space, { size: 5, children: [
          /* @__PURE__ */ jsx$1(AntdTooltip, { title: "导出所有设置项到文件中, 包含 access_key 等数据, 请妥善保存", children: /* @__PURE__ */ jsxs(antd.Button, { onClick: () => exportSettings(), children: [
            /* @__PURE__ */ jsx$1(ForwardRef$9, {}),
            "导出设置"
          ] }) }),
          /* @__PURE__ */ jsx$1(AntdTooltip, { title: "从文件中导入设置项, 将覆盖当前设置, 此操作不可逆!", children: /* @__PURE__ */ jsxs(antd.Button, { onClick: () => importSettings(), children: [
            /* @__PURE__ */ jsx$1(ForwardRef$8, {}),
            "导入设置"
          ] }) })
        ] })
      ] }) }),
      /* @__PURE__ */ jsx$1(SettingsGroup, { title: /* @__PURE__ */ jsxs(Fragment, { children: [
        /* @__PURE__ */ jsx$1(ForwardRef$7, { className: "size-28px mr-4px" }),
        "备份"
      ] }), children: /* @__PURE__ */ jsxs("div", { className: "flex items-center gap-x-40px", children: [
        /* @__PURE__ */ jsxs("span", { className: "flex items-center gap-x-8px", children: [
          /* @__PURE__ */ jsx$1(CheckboxSettingItem, { configPath: "backupSettingsToArticleDraft", label: "备份设置到专栏草稿箱中", tooltip: `专栏 - 草稿箱 - ${APP_NAME}` }),
          /* @__PURE__ */ jsxs("a", { className: "inline-flex items-center", href: "https://member.bilibili.com/platform/upload/text/draft", target: "_blank", children: [
            /* @__PURE__ */ jsx$1(IconForOpenExternalLink, { className: "size-16px mr-4px" }),
            "去草稿箱浏览"
          ] })
        ] }),
        /* @__PURE__ */ jsx$1(antd.Popconfirm, { title: "确定", description: "将覆盖本地设置? 此操作不可逆!", onConfirm: onRestoreSettings, children: /* @__PURE__ */ jsxs(antd.Button, { danger: true, type: "primary", children: [
          /* @__PURE__ */ jsx$1(ForwardRef$a, {}),
          "从专栏草稿箱中恢复"
        ] }) })
      ] }) }),
      /* @__PURE__ */ jsx$1(SettingsGroup, { titleClassName: "justify-between", title: /* @__PURE__ */ jsxs(Fragment, { children: [
        "预览",
        /* @__PURE__ */ jsx$1(ResetPartialSettingsButton, { paths: ["autoPreviewUpdateInterval"] })
      ] }), children: /* @__PURE__ */ jsxs("div", { className: "flex-v-center", children: [
        "自动预览更新间隔",
        /* @__PURE__ */ jsx$1(antd.Slider, { style: {
          flex: 1,
          margin: "0 15px"
        }, min: 0, max: 1e3, keyboard: true, onChange: (val) => settings.autoPreviewUpdateInterval = val, value: autoPreviewUpdateInterval }),
        /* @__PURE__ */ jsxs("span", { style: {
          width: "65px"
        }, children: [
          "(",
          autoPreviewUpdateInterval,
          "ms)"
        ] })
      ] }) }),
      /* @__PURE__ */ jsx$1(SettingsGroup, { title: /* @__PURE__ */ jsxs(Fragment, { children: [
        "其他",
        /* @__PURE__ */ jsx$1(HelpInfo, { children: "这里是一些作者不愿意解释的设置项 😬" }),
        /* @__PURE__ */ jsx$1(antd.Button, { onClick: () => setInternalKeysExpanded((v) => !v), className: "ml-10px inline-icon-only-round-button", css: internalKeysExpanded && buttonOpenCss, children: /* @__PURE__ */ jsx$1(ForwardRef$6, { className: clsx("size-16px transition-transform transition-300", internalKeysExpanded ? "rotate-180" : "rotate-0") }) })
      ] }), children: /* @__PURE__ */ jsx$1(CollapsePanel, { expanded: internalKeysExpanded, children: /* @__PURE__ */ jsxs("div", { className: "b-1px b-solid b-gate-border rounded-6px p-10px w-full flex gap-x-20px", children: [
        /* @__PURE__ */ jsx$1(ResetPartialSettingsButton, { paths: internalBooleanPaths, className: "flex-none" }),
        /* @__PURE__ */ jsx$1("div", { className: "flex-1 flex flex-wrap gap-x-20px gap-y-10px items-start", children: internalBooleanPaths.map((k) => /* @__PURE__ */ jsx$1(CheckboxSettingItem, { configPath: k, tooltip: k, label: startCase(k.startsWith("__internal") ? k.slice("__internal".length) : k.replaceAll("__internal.", "")) }, k)) })
      ] }) }) })
    ] });
  }
  class TimeoutError extends Error {
    constructor(message2) {
      super(message2);
      this.name = "TimeoutError";
    }
  }
  class AbortError3 extends Error {
    constructor(message2) {
      super();
      this.name = "AbortError";
      this.message = message2;
    }
  }
  const getDOMException = (errorMessage) => globalThis.DOMException === void 0 ? new AbortError3(errorMessage) : new DOMException(errorMessage);
  const getAbortedReason = (signal) => {
    const reason = signal.reason === void 0 ? getDOMException("This operation was aborted.") : signal.reason;
    return reason instanceof Error ? reason : getDOMException(reason);
  };
  function pTimeout(promise, options) {
    const {
      milliseconds,
      fallback,
      message: message2,
      customTimers = { setTimeout, clearTimeout }
    } = options;
    let timer;
    const wrappedPromise = new Promise((resolve, reject) => {
      if (typeof milliseconds !== "number" || Math.sign(milliseconds) !== 1) {
        throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${milliseconds}\``);
      }
      if (options.signal) {
        const { signal } = options;
        if (signal.aborted) {
          reject(getAbortedReason(signal));
        }
        signal.addEventListener("abort", () => {
          reject(getAbortedReason(signal));
        });
      }
      if (milliseconds === Number.POSITIVE_INFINITY) {
        promise.then(resolve, reject);
        return;
      }
      const timeoutError = new TimeoutError();
      timer = customTimers.setTimeout.call(void 0, () => {
        if (fallback) {
          try {
            resolve(fallback());
          } catch (error) {
            reject(error);
          }
          return;
        }
        if (typeof promise.cancel === "function") {
          promise.cancel();
        }
        if (message2 === false) {
          resolve();
        } else if (message2 instanceof Error) {
          reject(message2);
        } else {
          timeoutError.message = message2 ?? `Promise timed out after ${milliseconds} milliseconds`;
          reject(timeoutError);
        }
      }, milliseconds);
      (async () => {
        try {
          resolve(await promise);
        } catch (error) {
          reject(error);
        }
      })();
    });
    const cancelablePromise = wrappedPromise.finally(() => {
      cancelablePromise.clear();
    });
    cancelablePromise.clear = () => {
      customTimers.clearTimeout.call(void 0, timer);
      timer = void 0;
    };
    return cancelablePromise;
  }
  const normalizeEmitter = (emitter2) => {
    const addListener = emitter2.addEventListener || emitter2.on || emitter2.addListener;
    const removeListener = emitter2.removeEventListener || emitter2.off || emitter2.removeListener;
    if (!addListener || !removeListener) {
      throw new TypeError("Emitter is not compatible");
    }
    return {
      addListener: addListener.bind(emitter2),
      removeListener: removeListener.bind(emitter2)
    };
  };
  function pEventMultiple(emitter2, event, options) {
    let cancel;
    const returnValue = new Promise((resolve, reject) => {
      var _a2;
      options = {
        rejectionEvents: ["error"],
        multiArgs: false,
        resolveImmediately: false,
        ...options
      };
      if (!(options.count >= 0 && (options.count === Number.POSITIVE_INFINITY || Number.isInteger(options.count)))) {
        throw new TypeError("The `count` option should be at least 0 or more");
      }
      (_a2 = options.signal) == null ? void 0 : _a2.throwIfAborted();
      const events2 = [event].flat();
      const items = [];
      const { addListener, removeListener } = normalizeEmitter(emitter2);
      const onItem = (...arguments_) => {
        const value = options.multiArgs ? arguments_ : arguments_[0];
        if (options.filter && !options.filter(value)) {
          return;
        }
        items.push(value);
        if (options.count === items.length) {
          cancel();
          resolve(items);
        }
      };
      const rejectHandler = (error) => {
        cancel();
        reject(error);
      };
      cancel = () => {
        for (const event2 of events2) {
          removeListener(event2, onItem);
        }
        for (const rejectionEvent of options.rejectionEvents) {
          removeListener(rejectionEvent, rejectHandler);
        }
      };
      for (const event2 of events2) {
        addListener(event2, onItem);
      }
      for (const rejectionEvent of options.rejectionEvents) {
        addListener(rejectionEvent, rejectHandler);
      }
      if (options.signal) {
        options.signal.addEventListener("abort", () => {
          rejectHandler(options.signal.reason);
        }, { once: true });
      }
      if (options.resolveImmediately) {
        resolve(items);
      }
    });
    returnValue.cancel = cancel;
    if (typeof options.timeout === "number") {
      const timeout = pTimeout(returnValue, { milliseconds: options.timeout });
      timeout.cancel = cancel;
      return timeout;
    }
    return returnValue;
  }
  function pEvent(emitter2, event, options) {
    if (typeof options === "function") {
      options = { filter: options };
    }
    options = {
      ...options,
      count: 1,
      resolveImmediately: false
    };
    const arrayPromise = pEventMultiple(emitter2, event, options);
    const promise = arrayPromise.then((array) => array[0]);
    promise.cancel = arrayPromise.cancel;
    return promise;
  }
  const newSignedForm = (params) => {
    const sign = appSign(params, TVKeyInfo.appkey, TVKeyInfo.appsec);
    return new URLSearchParams({
      ...params,
      sign
    });
  };
  async function getQrCodeInfo() {
    const res = await request.post(
      "https://passport.bilibili.com/x/passport-tv-login/qrcode/auth_code",
      newSignedForm({
        appkey: TVKeyInfo.appkey,
        local_id: "0",
        ts: "0"
      })
      // sign: 'e134154ed6add881d28fbdf68653cd9c',
    );
    const json = res.data;
    if (!isWebApiSuccess(json)) {
      toast((json == null ? void 0 : json.message) || "获取 auth_code 失败");
      return;
    }
    return json.data;
  }
  async function poll(auth_code) {
    const res = await request.post("https://passport.bilibili.com/x/passport-tv-login/qrcode/poll", newSignedForm({
      appkey: TVKeyInfo.appkey,
      auth_code,
      local_id: "0",
      ts: "0"
    }));
    const json = res.data;
    const msgMap = {
      "0": "成功",
      "-3": "API校验密匙错误",
      "-400": "请求错误",
      "-404": "啥都木有",
      "86038": "二维码已失效",
      "86039": "二维码尚未确认",
      "86090": "二维码已扫码未确认"
    };
    if (!isWebApiSuccess(json)) {
      const code = json.code.toString();
      const message2 = json.message || msgMap[code] || "未知错误";
      if (code === "86038") {
        return {
          success: false,
          message: message2,
          action: "refresh"
        };
      }
      if (code === "86039" || code === "86090") {
        return {
          success: false,
          message: message2,
          action: "wait"
        };
      }
      return {
        success: false,
        message: message2,
        action: void 0
      };
    }
    const accessKey = json.data.access_token;
    const accessKeyExpireAt = Date.now() + json.data.expires_in * 1e3;
    return {
      success: true,
      message: "获取成功",
      accessKey,
      accessKeyExpireAt
    };
  }
  const initialValue = {
    show: false,
    qrcodeUrl: "",
    auth_code: "",
    message: ""
  };
  const store = proxy({
    ...initialValue
  });
  function updateStore(data2) {
    renderOnce$1();
    Object.assign(store, data2);
  }
  function showQrCodeModal(data2) {
    updateStore({
      ...initialValue,
      ...data2,
      show: true
    });
  }
  function hideQrCodeModal() {
    emitter.emit("hide");
    updateStore({
      ...initialValue
    });
  }
  const emitter = mitt();
  function whenQrCodeModalHide() {
    return pEvent(emitter, "hide");
  }
  var _ref$6 = {
    name: "9vstlm",
    styles: "backdrop-filter:blur(10px)"
  };
  function TvQrCodeAuth() {
    const {
      qrcodeUrl,
      show,
      message: message2
    } = useSnapshot(store);
    const onHide2 = hideQrCodeModal;
    return /* @__PURE__ */ jsxs(BaseModal, { show, onHide: onHide2, hideWhenMaskOnClick: false, hideWhenEsc: false, cssModalMask: _ref$6, width: 260, clsModal: "aspect-ratio-10/16", children: [
      /* @__PURE__ */ jsxs("div", { css: BaseModalStyle.modalHeader, children: [
        /* @__PURE__ */ jsx$1("div", { css: BaseModalStyle.modalTitle }),
        /* @__PURE__ */ jsx$1("div", { className: "space", style: {
          flex: 1
        } }),
        /* @__PURE__ */ jsx$1(ModalClose, { onClick: onHide2 })
      ] }),
      /* @__PURE__ */ jsxs("div", { css: BaseModalStyle.modalBody, className: "flex flex-col items-center justify-center text-center", children: [
        /* @__PURE__ */ jsx$1("div", { className: "flex-center min-h-25px text-size-14px mb-2px", children: message2 || "" }),
        qrcodeUrl && /* @__PURE__ */ jsx$1(antd.QRCode, { className: "mx-auto mb-40px p-8px flex-shrink-0", value: qrcodeUrl, size: 200, icon: "https://is1-ssl.mzstatic.com/image/thumb/Purple211/v4/72/9c/b6/729cb6d8-75f5-0a56-0508-3a26cbba69ae/AppIcon-1x_U007emarketing-0-6-0-0-85-220-0.png/230x0w.webp" }),
        /* @__PURE__ */ jsxs("div", { className: "footnote text-size-13px", children: [
          "打开「哔哩哔哩」或「bilibili」App ",
          /* @__PURE__ */ jsx$1("br", {}),
          "扫码获取 access_key"
        ] })
      ] })
    ] });
  }
  const renderOnce$1 = once(function render3() {
    const container = document.createElement("div");
    container.classList.add("modal-tv-qrcode-auth", APP_CLS_ROOT);
    document.body.appendChild(container);
    const r2 = clientExports.createRoot(container);
    r2.render(/* @__PURE__ */ jsx$1(AppRoot, { children: /* @__PURE__ */ jsx$1(TvQrCodeAuth, {}) }));
  });
  async function refreshQrCode() {
    const qrinfo = await getQrCodeInfo();
    if (!qrinfo) return;
    showQrCodeModal({
      qrcodeUrl: qrinfo.url,
      auth_code: qrinfo.auth_code
    });
    return true;
  }
  async function getAccessKeyByQrCode() {
    const next2 = await refreshQrCode();
    if (!next2) return;
    let res;
    let pollfor = store.auth_code;
    function shouldBreak() {
      if (!store.show) return true;
      if (!store.auth_code) return true;
      if (pollfor !== store.auth_code) return true;
    }
    function shouldContinue() {
      return !shouldBreak();
    }
    while (shouldContinue()) {
      const p1 = delay(1500);
      const p2 = whenQrCodeModalHide();
      await Promise.race([p1, p2]);
      p2.cancel();
      if (shouldBreak()) return;
      res = await poll(store.auth_code);
      const {
        success,
        accessKey,
        accessKeyExpireAt,
        message: message2,
        action: action2
      } = res;
      if (shouldBreak()) return;
      updateStore({
        message: message2
      });
      if (success) {
        await delay(1e3);
        hideQrCodeModal();
        return {
          accessKey,
          accessKeyExpireAt
        };
      }
      if (action2 === "refresh") {
        await delay(2e3);
        if (shouldBreak()) return;
        await refreshQrCode();
        pollfor = store.auth_code;
        updateStore({
          message: "已刷新二维码"
        });
        continue;
      }
      if (action2 === "wait") {
        continue;
      }
      updateStore({
        message: message2
      });
      toast(message2);
      return;
    }
  }
  async function getAccessKey() {
    const {
      accessKey,
      accessKeyExpireAt
    } = await getAccessKeyByQrCode() || {};
    if (!accessKey || !accessKeyExpireAt) return;
    settings.accessKey = accessKey;
    settings.accessKeyExpireAt = accessKeyExpireAt;
    toast("获取成功");
  }
  function deleteAccessKey() {
    settings.accessKey = "";
    settings.accessKeyExpireAt = 0;
    toast("已删除 access_key");
  }
  const btnAccessKeyHelpLink = /* @__PURE__ */ jsx$1(antd.Button, { target: "_blank", href: "https://github.com/indefined/UserScripts/tree/master/bilibiliHome#%E6%8E%88%E6%9D%83%E8%AF%B4%E6%98%8E", children: "access_key 说明" });
  function AccessKeyManage({
    style,
    className
  }) {
    const {
      runAsync,
      loading
    } = useRequest(getAccessKey, {
      manual: true
    });
    const {
      accessKey
    } = useSettingsSnapshot();
    const onDeleteAccessKey = deleteAccessKey;
    return /* @__PURE__ */ jsx$1(antd.Space, { size: "small", style, className, children: !accessKey ? /* @__PURE__ */ jsxs(Fragment, { children: [
      /* @__PURE__ */ jsx$1(antd.Button, { onClick: runAsync, loading, children: "获取 access_key" }),
      btnAccessKeyHelpLink
    ] }) : /* @__PURE__ */ jsxs(Fragment, { children: [
      /* @__PURE__ */ jsx$1(antd.Button, { onClick: runAsync, loading, children: "重新获取 access_key" }),
      /* @__PURE__ */ jsx$1(antd.Popconfirm, { onConfirm: onDeleteAccessKey, title: "确定删除 access_key?", children: /* @__PURE__ */ jsx$1(antd.Button, { children: "删除 access_key" }) }),
      btnAccessKeyHelpLink
    ] }) });
  }
  const iconParkOutlineHelp = (props, ref) => /* @__PURE__ */ jsx$1("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref, ...props, children: /* @__PURE__ */ jsxs("g", { fill: "none", children: [
    /* @__PURE__ */ jsx$1("path", { stroke: "currentColor", strokeLinejoin: "round", strokeWidth: 4, d: "M24 44a19.94 19.94 0 0 0 14.142-5.858A19.94 19.94 0 0 0 44 24a19.94 19.94 0 0 0-5.858-14.142A19.94 19.94 0 0 0 24 4A19.94 19.94 0 0 0 9.858 9.858A19.94 19.94 0 0 0 4 24a19.94 19.94 0 0 0 5.858 14.142A19.94 19.94 0 0 0 24 44Z" }),
    /* @__PURE__ */ jsx$1("path", { stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 4, d: "M24 28.625v-4a6 6 0 1 0-6-6" }),
    /* @__PURE__ */ jsx$1("path", { fill: "currentColor", fillRule: "evenodd", d: "M24 37.625a2.5 2.5 0 1 0 0-5a2.5 2.5 0 0 0 0 5", clipRule: "evenodd" })
  ] }) });
  const ForwardRef$5 = H.forwardRef(iconParkOutlineHelp);
  function TabPaneBasic() {
    const {
      videoLinkOpenMode,
      videoCard: {
        actions: {
          showLargePreview,
          openInPipWindow: openInPipWindow2
        }
      }
    } = useSettingsSnapshot();
    const openModeOptions = H.useMemo(() => {
      return Object.values(VideoLinkOpenMode).filter((mode) => VideoLinkOpenModeConfig[mode].enabled ?? true).map((mode) => {
        const config = VideoLinkOpenModeConfig[mode];
        return {
          config,
          value: mode,
          label: /* @__PURE__ */ jsxs("span", { className: "flex-v-center gap-x-8px", children: [
            config.icon,
            /* @__PURE__ */ jsx$1("span", { children: config.label })
          ] })
        };
      });
    }, []);
    const handleCopyScriptVersion = useMemoizedFn(() => {
      const content = `v${"0.32.8"}`;
      GM.setClipboard(content);
      antMessage.success(`已复制当前版本: ${content}`);
    });
    return /* @__PURE__ */ jsxs("div", { css: S$1.tabPane, children: [
      /* @__PURE__ */ jsx$1(SettingsGroup, { title: /* @__PURE__ */ jsxs(Fragment, { children: [
        /* @__PURE__ */ jsx$1(TabIcon, { tabKey: ETab.AppRecommend, className: "size-30px mr-5px mt-2px" }),
        "推荐 access_key",
        /* @__PURE__ */ jsxs(HelpInfo, { className: "size-18px ml-5px mt-6px", IconComponent: ForwardRef$5, children: [
          /* @__PURE__ */ jsxs("span", { className: "inline-flex items-center", children: [
            "用于「",
            /* @__PURE__ */ jsx$1(TabIcon, { tabKey: ETab.AppRecommend, className: "mr-5px" }),
            "推荐」Tab"
          ] }),
          /* @__PURE__ */ jsx$1("br", {}),
          "用于 获取推荐 / 提交不喜欢等操作"
        ] })
      ] }), children: /* @__PURE__ */ jsx$1(AccessKeyManage, {}) }),
      /* @__PURE__ */ jsx$1(SettingsGroup, { titleClassName: "justify-between", title: /* @__PURE__ */ jsxs(Fragment, { children: [
        "开关",
        /* @__PURE__ */ jsx$1(ResetPartialSettingsButton, { paths: ["pureRecommend", "useNarrowMode", "showModalFeedOnLoad", "showModalFeedEntry", "multiSelect.showIcon"] })
      ] }), children: /* @__PURE__ */ jsxs(antd.Space, { size: 10, wrap: true, children: [
        /* @__PURE__ */ jsx$1(CheckboxSettingItem, { configPath: "pureRecommend", label: "全屏模式", tooltip: /* @__PURE__ */ jsxs(Fragment, { children: [
          "清空自带推荐内容, 只显示脚本推荐",
          /* @__PURE__ */ jsx$1("br", {}),
          "P.S 需要刷新网页~",
          /* @__PURE__ */ jsx$1("br", {}),
          "P.S 之前版本称 (纯推荐模式)"
        ] }), extraAction: () => toastAndReload() }),
        /* @__PURE__ */ jsx$1(CheckboxSettingItem, { configPath: "useNarrowMode", label: "居中模式", tooltip: /* @__PURE__ */ jsxs(Fragment, { children: [
          "居中两列",
          /* @__PURE__ */ jsx$1("br", {}),
          "切换设置快捷键: ",
          /* @__PURE__ */ jsx$1(antd.Tag, { color: "green", children: "shift+c" })
        ] }) }),
        /* @__PURE__ */ jsx$1(CheckboxSettingItem, { configPath: "showModalFeedOnLoad", label: "自动「查看更多」", tooltip: "打开首页时自动打开「查看更多」弹窗", extraAction: (val) => {
          if (val) {
            antMessage.success("已开启自动「查看更多」: 下次打开首页时将自动打开「查看更多」弹窗");
          }
        } }),
        /* @__PURE__ */ jsx$1(CheckboxSettingItem, { configPath: "showModalFeedEntry", label: "「查看更多」按钮", tooltip: "是否显示「查看更多」按钮" }),
        /* @__PURE__ */ jsx$1(CheckboxSettingItem, { configPath: "multiSelect.showIcon", label: "「多选」按钮", tooltip: "是否显示「多选」按钮" })
      ] }) }),
      /* @__PURE__ */ jsx$1(SettingsGroup, { titleClassName: "justify-between", title: /* @__PURE__ */ jsxs(Fragment, { children: [
        "视频链接",
        /* @__PURE__ */ jsx$1(ResetPartialSettingsButton, { paths: ["videoLinkOpenMode"] })
      ] }), children: /* @__PURE__ */ jsx$1(antd.Space, { size: 20, children: /* @__PURE__ */ jsxs("div", { className: "flex-v-center", children: [
        "默认打开模式",
        /* @__PURE__ */ jsxs(
          HelpInfo,
          {
            tooltipProps: {
              color: "rgba(0, 0, 0, 0.85)"
            },
            children: [
              "选择点击视频(封面图片 或 标题)时打开的模式 ",
              /* @__PURE__ */ jsx$1("br", {}),
              openModeOptions.map(({
                value,
                config
              }) => {
                return !!config.desc && /* @__PURE__ */ jsxs("div", { className: "flex items-start mt-10px first:mt-0", children: [
                  /* @__PURE__ */ jsxs("span", { className: "inline-flex items-center", children: [
                    config.icon,
                    /* @__PURE__ */ jsx$1("span", { className: "min-w-95px ml-4px mr-10px", children: config.label })
                  ] }),
                  /* @__PURE__ */ jsx$1("span", { className: "desc", children: config.desc })
                ] }, value);
              })
            ]
          }
        ),
        /* @__PURE__ */ jsx$1(antd.Select, { className: "w-160px ml-8px", options: openModeOptions, value: videoLinkOpenMode, onChange: (v) => {
          updateSettings({
            videoLinkOpenMode: v
          });
        } })
      ] }) }) }),
      /* @__PURE__ */ jsx$1(SettingsGroup, { titleClassName: "justify-between", title: /* @__PURE__ */ jsxs(Fragment, { children: [
        /* @__PURE__ */ jsxs("span", { className: "flex items-center", children: [
          "视频卡片操作 ",
          /* @__PURE__ */ jsx$1(HelpInfo, { children: "视频卡片右上角「稍后再看」按钮旁" })
        ] }),
        /* @__PURE__ */ jsx$1(ResetPartialSettingsButton, { paths: ["videoCard.actions.showLargePreview", "videoCard.actions.openInPipWindow", "videoCard.videoPreview.useMp4", "videoCard.videoPreview.useScale", "videoCard.videoPreview.addTo.searchPage", "pipWindow.defaultLocked", "pipWindow.autoWebFullscreen"] })
      ] }), children: /* @__PURE__ */ jsxs("div", { className: "grid grid-cols-[repeat(2,max-content)_1fr] items-start gap-x-20px", children: [
        /* @__PURE__ */ jsx$1(CheckboxSettingItem, { configPath: "videoCard.actions.showLargePreview", label: "浮动预览", tooltip: /* @__PURE__ */ jsxs(Fragment, { children: [
          "创意来源「浮图秀」, 但使用视频预览 ",
          /* @__PURE__ */ jsx$1("br", {}),
          "操作说明: ",
          /* @__PURE__ */ jsx$1("br", {}),
          "1. 鼠标悬浮打开 「浮动预览」, 离开关闭 ",
          /* @__PURE__ */ jsx$1("br", {}),
          "2. 点击固定「浮动预览」, 固定指: 不再随鼠标移出关闭预览 ",
          /* @__PURE__ */ jsx$1("br", {}),
          "3. 可使用以下方式关闭固定的「浮动预览」",
          /* @__PURE__ */ jsxs("ul", { className: "list-circle ml-30px", children: [
            /* @__PURE__ */ jsx$1("li", { children: "再次点击视频卡片按钮" }),
            /* @__PURE__ */ jsx$1("li", { children: "点击预览视频右上方的「关闭」按钮" }),
            /* @__PURE__ */ jsx$1("li", { children: "触发其他卡片的「浮动预览」" }),
            /* @__PURE__ */ jsx$1("li", { children: "Esc键" }),
            /* @__PURE__ */ jsx$1("li", { children: "点击页面空白处" })
          ] })
        ] }) }),
        /* @__PURE__ */ jsx$1(CheckboxSettingItem, { configPath: "videoCard.actions.openInPipWindow", label: "小窗打开", tooltip: /* @__PURE__ */ jsx$1(Fragment, { children: "仅当「文档画中画」API 可用时, 勾选生效" }) }),
        /* @__PURE__ */ jsx$1(antd.Divider, { className: "py-0 my-2px grid-col-span-full" }),
        /* @__PURE__ */ jsxs("div", { className: "flex flex-col", children: [
          /* @__PURE__ */ jsx$1(CheckboxSettingItem, { configPath: "videoCard.videoPreview.useMp4", disabled: !showLargePreview, label: "浮动预览: 使用 mp4", tooltip: /* @__PURE__ */ jsx$1(Fragment, { children: explainForFlag("使用 mp4, 最高 720p, 有声音", "使用 dash, 最高 1080p, 无声音, 理论上更快") }) }),
          /* @__PURE__ */ jsx$1(CheckboxSettingItem, { configPath: "videoCard.videoPreview.useScale", disabled: !showLargePreview, label: "浮动预览: 使用放大效果", tooltip: /* @__PURE__ */ jsx$1(Fragment, { children: explainForFlag("浮动预览面板: 放大展开 (类似浮图秀)", "浮动预览面板: 滑动展开") }) }),
          /* @__PURE__ */ jsx$1(CheckboxSettingItem, { configPath: "videoCard.videoPreview.addTo.searchPage", disabled: !showLargePreview, label: "浮动预览: 添加到「搜索页」", tooltip: /* @__PURE__ */ jsx$1(Fragment, { children: "在搜索页的视频也添加「浮动预览」" }) })
        ] }),
        /* @__PURE__ */ jsxs("div", { className: "flex flex-col", children: [
          /* @__PURE__ */ jsx$1(CheckboxSettingItem, { configPath: "pipWindow.defaultLocked", disabled: !openInPipWindow2, label: "小窗: 默认锁定", tooltip: explainForFlag("小窗打开时: 默认锁定", "小窗打开时: 不锁定") }),
          /* @__PURE__ */ jsx$1(CheckboxSettingItem, { configPath: "pipWindow.autoWebFullscreen", disabled: !openInPipWindow2, label: "小窗: 自动网页全屏", tooltip: explainForFlag("自动网页全屏", "不启用") })
        ] })
      ] }) }),
      /* @__PURE__ */ jsx$1(SettingsGroup, { titleClassName: "justify-between", title: /* @__PURE__ */ jsxs(Fragment, { children: [
        "预览",
        /* @__PURE__ */ jsx$1(ResetPartialSettingsButton, { paths: ["autoPreviewWhenKeyboardSelect", "autoPreviewWhenHover"] })
      ] }), children: /* @__PURE__ */ jsxs("div", { className: "flex flex-wrap items-center gap-x-10px", children: [
        /* @__PURE__ */ jsx$1(CheckboxSettingItem, { configPath: "autoPreviewWhenKeyboardSelect", label: "键盘选中后自动开始预览", tooltip: /* @__PURE__ */ jsxs(Fragment, { children: [
          "手动预览快捷键: ",
          /* @__PURE__ */ jsx$1(antd.Tag, { color: "green", children: "." }),
          " or ",
          /* @__PURE__ */ jsx$1(antd.Tag, { color: "green", children: "p" }),
          /* @__PURE__ */ jsx$1("br", {}),
          "切换设置快捷键: ",
          /* @__PURE__ */ jsx$1(antd.Tag, { color: "green", children: "shift+p" })
        ] }) }),
        /* @__PURE__ */ jsx$1(CheckboxSettingItem, { configPath: "autoPreviewWhenHover", label: "鼠标悬浮后自动开始预览", tooltip: /* @__PURE__ */ jsxs(Fragment, { children: [
          "鼠标悬浮后自动开始预览, 预览不再跟随鼠标位置 ",
          /* @__PURE__ */ jsx$1("br", {}),
          "切换设置快捷键: ",
          /* @__PURE__ */ jsx$1(antd.Tag, { color: "green", children: "shift+m" })
        ] }) })
      ] }) }),
      /* @__PURE__ */ jsx$1(SettingsGroup, { title: /* @__PURE__ */ jsxs(Fragment, { children: [
        "帮助",
        /* @__PURE__ */ jsxs("span", { className: "ml-8px mr-4px text-size-14px relative top-4px inline-flex items-center", children: [
          "当前版本",
          /* @__PURE__ */ jsxs(antd.Tag, { color: "green", className: "cursor-pointer mx-4px", onClick: handleCopyScriptVersion, children: [
            APP_NAME,
            " v",
            "0.32.8"
          ] }),
          /* @__PURE__ */ jsx$1(IconForCopy, { className: "size-16px cursor-pointer", onClick: handleCopyScriptVersion })
        ] })
      ] }), children: /* @__PURE__ */ jsxs(antd.Space, { size: 10, wrap: true, children: [
        /* @__PURE__ */ jsx$1(antd.Button, { href: "https://github.com/magicdawn/bilibili-gate", target: "_blank", children: "GitHub 主页" }),
        /* @__PURE__ */ jsx$1(antd.Button, { href: "https://greasyfork.org/zh-CN/scripts/443530-bilibili-gate", target: "_blank", children: "GreasyFork 主页" }),
        /* @__PURE__ */ jsx$1(antd.Button, { href: "https://github.com/magicdawn/bilibili-gate#%E5%BF%AB%E6%8D%B7%E9%94%AE%E8%AF%B4%E6%98%8E", target: "_blank", children: "查看可用的快捷键" }),
        /* @__PURE__ */ jsx$1(antd.Button, { href: "https://github.com/magicdawn/bilibili-gate/releases", target: "_blank", children: "更新日志" }),
        /* @__PURE__ */ jsx$1(antd.Button, { href: "https://afdian.com/a/magicdawn", target: "_blank", children: "去「爱发电」支持" })
      ] }) })
    ] });
  }
  const borderCycleList = [
    {
      useBorder: false
    },
    // no border
    {
      useBorder: true,
      useBorderOnlyOnHover: true
    },
    // on hover
    {
      useBorder: true,
      useBorderOnlyOnHover: false
    }
    // always
  ];
  const borderCycleListLabels = ["「卡片边框」: 禁用", "「卡片边框」: 仅在悬浮时显示", "「卡片边框」: 总是显示"];
  function useHotkeyForConfigBorder() {
    return useKeyPress(["shift.b"], (e2) => {
      if (shouldDisableShortcut()) return;
      const curState = pick(settings.style.videoCard, ["useBorder", "useBorderOnlyOnHover"]);
      const curIndex = borderCycleList.findIndex((state2) => {
        return isEqual$2(state2, pick(curState, Object.keys(state2)));
      });
      if (curIndex === -1) throw new Error("unexpected curIndex = -1");
      const nextIndex = (curIndex + 1) % borderCycleList.length;
      const nextState = borderCycleList[nextIndex];
      Object.assign(settings.style.videoCard, nextState);
      const nextLabel = borderCycleListLabels[nextIndex];
      antMessage.success(nextLabel);
    }, {
      exactMatch: true
    });
  }
  function TabPaneCustomUI() {
    const {
      style
    } = useSettingsSnapshot();
    const itemsContainerClassName = "flex flex-col gap-y-4px";
    return /* @__PURE__ */ jsxs("div", { css: S$1.tabPane, className: "flex flex-col flex-wrap gap-y-10px gap-x-30px content-start", children: [
      /* @__PURE__ */ jsx$1(SettingsGroup, { title: /* @__PURE__ */ jsxs(Fragment, { children: [
        "通用",
        /* @__PURE__ */ jsx$1(ResetPartialSettingsButton, { className: "ml-10px", paths: ["style.general.popoverBorderColorUseColorPrimary"] })
      ] }), children: /* @__PURE__ */ jsx$1("div", { className: itemsContainerClassName, children: /* @__PURE__ */ jsx$1(CheckboxSettingItem, { configPath: "style.general.popoverBorderColorUseColorPrimary", label: "下拉面板使用主题色边框" }) }) }),
      /* @__PURE__ */ jsx$1(SettingsGroup, { title: /* @__PURE__ */ jsxs(Fragment, { children: [
        "全屏模式",
        /* @__PURE__ */ jsx$1(ResetPartialSettingsButton, { className: "ml-10px", paths: ["style.pureRecommend.useStickyTabbar", "style.pureRecommend.useCustomGrid", "style.pureRecommend.useWhiteBackground", "style.pureRecommend.hideTopChannel"] })
      ] }), children: /* @__PURE__ */ jsxs("div", { className: itemsContainerClassName, children: [
        /* @__PURE__ */ jsx$1(CheckboxSettingItem, { configPath: "style.pureRecommend.useStickyTabbar", label: "全屏模式: sticky tab bar", tooltip: explainForFlag("Tab 栏会吸附在顶栏下方", "Tab 栏会随页面一起滚动") }),
        /* @__PURE__ */ jsx$1(CheckboxSettingItem, { configPath: "style.pureRecommend.useCustomGrid", label: "全屏模式: 使用自定义网格配置", tooltip: /* @__PURE__ */ jsxs(Fragment, { children: [
          "网格配置指: 网格宽度, 间距, 列数等. ",
          /* @__PURE__ */ jsx$1("br", {}),
          "自定义网格配置: 宽度为90%; 可跟随 Bilibili-Evolved 自定义顶栏配置; 列数: 4 - 10列; 由",
          APP_NAME,
          " 自定义; ",
          /* @__PURE__ */ jsx$1("br", {}),
          "默认网格配置: bili-feed4 版本B站首页默认的网格配置; 在 Sarari 中使用建议取消勾选此项."
        ] }) }),
        /* @__PURE__ */ jsx$1(CheckboxSettingItem, { configPath: "style.pureRecommend.useWhiteBackground", label: "全屏模式: 使用纯白背景", tooltip: explainForFlag("纯白背景", "浅灰色背景") }),
        /* @__PURE__ */ jsx$1(CheckboxSettingItem, { configPath: "style.pureRecommend.hideTopChannel", label: "全屏模式: 隐藏顶部分区和Banner" })
      ] }) }),
      /* @__PURE__ */ jsx$1(SettingsGroup, { title: /* @__PURE__ */ jsxs(Fragment, { children: [
        "视频卡片",
        /* @__PURE__ */ jsx$1(ResetPartialSettingsButton, { className: "ml-10px", paths: ["style.videoCard.useBorder", "style.videoCard.useBorderOnlyOnHover", "style.videoCard.useBoxShadow", "style.videoCard.usePadding", "useDelayForHover"] })
      ] }), children: /* @__PURE__ */ jsxs("div", { className: itemsContainerClassName, children: [
        /* @__PURE__ */ jsx$1(CheckboxSettingItem, { configPath: "style.videoCard.useBorder", label: "使用卡片边框", tooltip: /* @__PURE__ */ jsxs(Fragment, { children: [
          "勾选后, 视频卡片会有边框包裹, 更像是一个卡片~ ",
          /* @__PURE__ */ jsx$1("br", {}),
          "整个卡片区域可点击 / 可触发预览 / 可使用右键菜单 ",
          /* @__PURE__ */ jsx$1("br", {}),
          "否则只是封面区域可以 ",
          /* @__PURE__ */ jsx$1("br", {}),
          "使用快捷键 ",
          /* @__PURE__ */ jsx$1(antd.Tag, { color: "green", children: "shift+b" }),
          " 切换状态",
          /* @__PURE__ */ jsx$1("br", {}),
          borderCycleListLabels.map((label) => /* @__PURE__ */ jsx$1(antd.Tag, { color: "success", children: label }, label))
        ] }) }),
        /* @__PURE__ */ jsx$1(CheckboxSettingItem, { configPath: "style.videoCard.useBorderOnlyOnHover", label: "仅在悬浮时显示", disabled: !style.videoCard.useBorder, tooltip: explainForFlag("仅在悬浮时显示", "一直显示") }),
        /* @__PURE__ */ jsx$1(CheckboxSettingItem, { configPath: "style.videoCard.useBoxShadow", disabled: !style.videoCard.useBorder, label: "悬浮卡片时使用发光效果", tooltip: /* @__PURE__ */ jsx$1(Fragment, { children: "悬浮卡片时使用发光效果, 看起来比较花哨~" }) }),
        /* @__PURE__ */ jsx$1(CheckboxSettingItem, { configPath: "useDelayForHover", label: "延迟悬浮预览", tooltip: /* @__PURE__ */ jsx$1(Fragment, { children: "延迟悬浮预览" }) }),
        /* @__PURE__ */ jsx$1(CheckboxSettingItem, { configPath: "style.videoCard.usePadding", label: "卡片外扩", tooltip: /* @__PURE__ */ jsx$1(Fragment, { children: "卡片会外扩一点距离" }) })
      ] }) })
    ] });
  }
  const iconParkOutlineCloseSmall = (props, ref) => /* @__PURE__ */ jsx$1("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref, ...props, children: /* @__PURE__ */ jsx$1("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 4, d: "m14 14l20 20m-20 0l20-20" }) });
  const ForwardRef$4 = H.forwardRef(iconParkOutlineCloseSmall);
  const {
    Search
  } = antd.Input;
  var _ref$5 = {
    name: "n2wo5l",
    styles: "&.ant-empty-normal{margin-block:5px;}"
  };
  var _ref2$3 = {
    name: "2vv6yp",
    styles: "color:var(--ant-color-text-disabled);background-color:var(--ant-color-bg-container-disabled);border-color:var(--ant-color-border);box-shadow:none;opacity:1;pointer-events:none;cursor:not-allowed"
  };
  function EditableListSettingItem({
    configPath,
    searchProps,
    disabled
  }) {
    const rawList = useSettingsInnerArray(configPath);
    const list2 = H.useMemo(() => uniq(rawList).toReversed(), [rawList]);
    return /* @__PURE__ */ jsxs(Fragment, { children: [
      /* @__PURE__ */ jsx$1(Search, { className: "my-5px", enterButton: "添加", allowClear: true, disabled, ...searchProps, onSearch: async (val, e2) => {
        var _a2;
        if (!val) return;
        const set2 = new Set(await getNewestValueOfSettingsInnerArray(configPath));
        if (set2.has(val)) {
          antMessage.warning(`${val} 已存在`);
          return;
        }
        await updateSettingsInnerArray(configPath, {
          add: [val]
        });
        if (e2 == null ? void 0 : e2.target) {
          const el = e2.target;
          const clearBtn = (_a2 = el.closest(".ant-input-wrapper")) == null ? void 0 : _a2.querySelector(".ant-input-clear-icon");
          clearBtn == null ? void 0 : clearBtn.click();
        }
      } }),
      /* @__PURE__ */ jsx$1("div", { css: [/* @__PURE__ */ css("min-height:82px;border-radius:6px;border:1px solid ", borderColorValue, ";margin-top:3px;", ""), disabled && _ref2$3, "", ""], children: list2.length ? /* @__PURE__ */ jsx$1("div", { className: clsx("flex flex-wrap items-start gap-y-5px gap-x-10px", "py-5px pl-5px pr-10px", "overflow-y-auto max-h-250px"), children: list2.map((t2) => {
        return /* @__PURE__ */ jsx$1(TagItemDisplay, { tag: t2.toString(), onDelete: async (tag) => {
          await updateSettingsInnerArray(configPath, {
            remove: [tag]
          });
        }, renderTag: configPath === "filter.byAuthor.keywords" ? (tag) => /* @__PURE__ */ jsx$1(UpTagItemDisplay, { tag }) : void 0 }, t2);
      }) }) : /* @__PURE__ */ jsx$1(antd.Empty, { image: antd.Empty.PRESENTED_IMAGE_SIMPLE, description: "空空如也", css: _ref$5 }) })
    ] });
  }
  const TagItemDisplay = H.forwardRef(({
    tag,
    renderTag,
    onDelete,
    className,
    ...restProps
  }, ref) => {
    return /* @__PURE__ */ jsxs("div", { ref, className: clsx("b-1px b-solid b-gate-border rounded-5px relative inline-flex items-center px-6px py-2px hover:b-gate-primary hover:color-gate-primary", className), ...restProps, children: [
      renderTag ? renderTag(tag) : tag,
      /* @__PURE__ */ jsx$1(ForwardRef$4, { className: "size-16px ml-2px cursor-pointer text-size-12px", onClick: () => {
        onDelete == null ? void 0 : onDelete(tag);
      } })
    ] });
  });
  function UpTagItemDisplay({
    tag
  }) {
    const regMidWithRemark = /^(?<mid>\d+)\((?<remark>[\S ]+)\)$/;
    const regMid = /^\d+$/;
    const {
      mid,
      remark
    } = H.useMemo(() => {
      var _a2;
      if (regMidWithRemark.test(tag)) {
        const groups = (_a2 = regMidWithRemark.exec(tag)) == null ? void 0 : _a2.groups;
        const mid2 = groups == null ? void 0 : groups.mid;
        const remark2 = groups == null ? void 0 : groups.remark;
        return {
          mid: mid2,
          remark: remark2
        };
      } else if (regMid.test(tag)) {
        return {
          mid: tag
        };
      } else {
        return {};
      }
    }, [tag]);
    const [nicknameByMid, setNicknameByMid] = H.useState(void 0);
    H.useEffect(() => {
      void (async () => {
        if (!mid) return;
        const nickname = await getUserNickname(mid);
        if (nickname) setNicknameByMid(nickname);
      })();
    }, [mid]);
    const label = mid ? (
      //
      nicknameByMid || remark || mid
    ) : tag;
    const tooltip = /* @__PURE__ */ jsxs(Fragment, { children: [
      !!mid && /* @__PURE__ */ jsxs(Fragment, { children: [
        "mid: ",
        mid,
        " ",
        /* @__PURE__ */ jsx$1("br", {})
      ] }),
      !!remark && /* @__PURE__ */ jsxs(Fragment, { children: [
        "备注: ",
        remark,
        " ",
        /* @__PURE__ */ jsx$1("br", {}),
        remark === nicknameByMid && /* @__PURE__ */ jsxs(Fragment, { children: [
          "P.S 备注是之前的数据, 现在你只需要填写 mid, 会自动获取昵称 ",
          /* @__PURE__ */ jsx$1("br", {})
        ] })
      ] }),
      !mid && /* @__PURE__ */ jsxs(Fragment, { children: [
        "使用用户名过滤: 用户可能改名, 建议使用 mid 过滤 ",
        /* @__PURE__ */ jsx$1("br", {})
      ] })
    ] });
    return /* @__PURE__ */ jsx$1(Fragment, { children: /* @__PURE__ */ jsx$1(AntdTooltip, { title: tooltip, children: /* @__PURE__ */ jsxs("span", { className: clsx("inline-flex items-center justify-center", mid ? "cursor-pointer" : "cursor-[edit]"), children: [
      mid && /* @__PURE__ */ jsx$1(ForwardRef$G, { className: "size-12px mr-2px" }),
      mid ? /* @__PURE__ */ jsx$1("a", { href: formatSpaceUrl(mid), target: "_blank", style: {
        color: "inherit"
      }, children: label }) : label
    ] }) }) });
  }
  function TabPaneFilter() {
    const {
      enabled,
      minDuration,
      minPlayCount,
      minDanmakuCount,
      hideGotoTypeBangumi,
      hideGotoTypePicture,
      byAuthor,
      byTitle
    } = useSettingsSnapshot().filter;
    const getExemptFollowedTooltipProps = (label) => {
      return {
        label: "「已关注」豁免",
        tooltipProps: {
          color: "rgba(0, 0, 0, 0.85)"
        },
        tooltip: /* @__PURE__ */ jsxs(Fragment, { children: [
          "「已关注」内容不考虑过滤条件, 总是展示",
          /* @__PURE__ */ jsx$1("br", {}),
          '"豁免" 一词来源',
          " ",
          /* @__PURE__ */ jsx$1("a", { target: "_blank", href: "https://github.com/magicdawn/bilibili-gate/issues/1#issuecomment-2197868587", children: "pilipala" })
        ] })
      };
    };
    return /* @__PURE__ */ jsx$1("div", { css: S$1.tabPane, className: "pr-15px", children: /* @__PURE__ */ jsx$1(SettingsGroup, { title: /* @__PURE__ */ jsxs(Fragment, { children: [
      "内容过滤",
      /* @__PURE__ */ jsxs(HelpInfo, { children: [
        "启用过滤会大幅降低加载速度, 谨慎开启! ",
        /* @__PURE__ */ jsx$1("br", {}),
        "视频/图文/影视: 仅推荐类 Tab 生效 ",
        /* @__PURE__ */ jsx$1("br", {}),
        "UP/标题: 推荐类 / 热门 等Tab 生效"
      ] }),
      /* @__PURE__ */ jsx$1(SwitchSettingItem, { configPath: "filter.enabled", className: "ml-10px" })
    ] }), children: /* @__PURE__ */ jsxs("div", { className: "grid grid-cols-2 gap-x-15px", children: [
      /* @__PURE__ */ jsxs("div", { className: "col", children: [
        /* @__PURE__ */ jsx$1("div", { css: S$1.settingsGroupSubTitle, children: "视频" }),
        /* @__PURE__ */ jsxs("div", { className: "flex flex-col gap-y-5px", children: [
          /* @__PURE__ */ jsxs("div", { className: "flex items-center", children: [
            /* @__PURE__ */ jsx$1(CheckboxSettingItem, { configPath: "filter.minDuration.enabled", label: "按视频时长过滤", tooltip: /* @__PURE__ */ jsx$1(Fragment, { children: "不显示短视频" }), disabled: !enabled, className: "min-w-130px" }),
            /* @__PURE__ */ jsx$1(antd.InputNumber, { className: "w-130px", size: "small", min: 1, step: 10, addonAfter: "秒", value: minDuration.value, onChange: (val) => !isNil(val) && (settings.filter.minDuration.value = val), disabled: !enabled || !minDuration.enabled })
          ] }),
          /* @__PURE__ */ jsxs("div", { className: "flex items-center", children: [
            /* @__PURE__ */ jsx$1(CheckboxSettingItem, { disabled: !enabled, configPath: "filter.minPlayCount.enabled", label: "按播放次数过滤", tooltip: /* @__PURE__ */ jsx$1(Fragment, { children: "不显示播放次数很少的视频" }), className: "min-w-130px" }),
            /* @__PURE__ */ jsx$1(antd.InputNumber, { className: "w-130px", size: "small", min: 1, step: 1e3, value: minPlayCount.value, onChange: (val) => !isNil(val) && (settings.filter.minPlayCount.value = val), disabled: !enabled || !minPlayCount.enabled, addonAfter: "次" })
          ] }),
          /* @__PURE__ */ jsxs("div", { className: "flex items-center", children: [
            /* @__PURE__ */ jsx$1(CheckboxSettingItem, { disabled: !enabled, configPath: "filter.minDanmakuCount.enabled", label: "按弹幕条数过滤", tooltip: /* @__PURE__ */ jsx$1(Fragment, { children: "不显示弹幕条数很少的视频" }), className: "min-w-130px" }),
            /* @__PURE__ */ jsx$1(antd.InputNumber, { className: "w-130px", size: "small", min: 1, step: 100, value: minDanmakuCount.value, onChange: (val) => !isNil(val) && (settings.filter.minDanmakuCount.value = val), disabled: !enabled || !minDanmakuCount.enabled, addonAfter: "条" })
          ] }),
          /* @__PURE__ */ jsx$1(CheckboxSettingItem, { configPath: "filter.exemptForFollowed.video", disabled: !enabled, ...getExemptFollowedTooltipProps() })
        ] })
      ] }),
      /* @__PURE__ */ jsxs("div", { className: "col", children: [
        /* @__PURE__ */ jsx$1("div", { css: S$1.settingsGroupSubTitle, children: "图文" }),
        /* @__PURE__ */ jsx$1(CheckboxSettingItem, { configPath: "filter.hideGotoTypePicture", label: "过滤图文类型推荐", disabled: !enabled, className: "flex", tooltip: /* @__PURE__ */ jsxs(Fragment, { children: [
          "过滤 ",
          /* @__PURE__ */ jsx$1("kbd", { children: "goto = picture" }),
          " 的内容: 包括 (动态 & 专栏) 等"
        ] }) }),
        /* @__PURE__ */ jsx$1(CheckboxSettingItem, { className: "flex", disabled: !enabled || !hideGotoTypePicture, configPath: "filter.exemptForFollowed.picture", ...getExemptFollowedTooltipProps() }),
        /* @__PURE__ */ jsx$1("div", { css: S$1.settingsGroupSubTitle, children: "影视" }),
        /* @__PURE__ */ jsx$1(CheckboxSettingItem, { configPath: "filter.hideGotoTypeBangumi", label: "过滤影视类型推荐", tooltip: /* @__PURE__ */ jsxs(Fragment, { children: [
          "过滤 ",
          /* @__PURE__ */ jsx$1("kbd", { children: "goto = bangumi" }),
          " 的内容: 包括 (番剧 / 电影 / 国创 / 纪录片) 等"
        ] }), disabled: !enabled })
      ] }),
      /* @__PURE__ */ jsxs("div", { className: "col", children: [
        /* @__PURE__ */ jsxs("div", { css: S$1.settingsGroupSubTitle, children: [
          "UP",
          /* @__PURE__ */ jsxs(HelpInfo, { children: [
            "根据 UP 过滤视频 ",
            /* @__PURE__ */ jsx$1("br", {}),
            "使用 mid 屏蔽时支持备注, 格式: ",
            /* @__PURE__ */ jsx$1(antd.Tag, { color: "success", children: "mid(备注)" }),
            "  ",
            "如 ",
            /* @__PURE__ */ jsx$1(antd.Tag, { color: "success", children: "8047632(B站官方)" }),
            " ",
            /* @__PURE__ */ jsx$1("br", {}),
            "作用范围: 推荐 / 热门 ",
            /* @__PURE__ */ jsx$1("br", {}),
            /* @__PURE__ */ jsxs("div", { className: "flex items-start mt-4px", children: [
              /* @__PURE__ */ jsx$1(IconForInfo, { className: "mt-3px" }),
              /* @__PURE__ */ jsxs("div", { className: "flex-1 ml-8px", children: [
                "B站官方支持黑名单, 对于不喜欢的 UP 可以直接拉黑 ",
                /* @__PURE__ */ jsx$1("br", {}),
                "黑名单无视此页开关, 总是会过滤掉 ",
                /* @__PURE__ */ jsx$1("br", {}),
                "这里是客户端过滤, 与黑名单功能重复, 优先使用黑名单功能 ",
                /* @__PURE__ */ jsx$1("br", {})
              ] })
            ] })
          ] }),
          /* @__PURE__ */ jsx$1(SwitchSettingItem, { configPath: "filter.byAuthor.enabled", disabled: !enabled, className: "ml-10px" })
        ] }),
        /* @__PURE__ */ jsx$1(EditableListSettingItem, { configPath: "filter.byAuthor.keywords", searchProps: {
          placeholder: "添加UP: 全名 / mid / mid(备注)"
        }, disabled: !enabled || !byAuthor.enabled })
      ] }),
      /* @__PURE__ */ jsxs("div", { className: "col", children: [
        /* @__PURE__ */ jsxs("div", { css: S$1.settingsGroupSubTitle, children: [
          /* @__PURE__ */ jsx$1("span", { children: "标题" }),
          /* @__PURE__ */ jsxs(HelpInfo, { children: [
            "根据标题关键词过滤视频 ",
            /* @__PURE__ */ jsx$1("br", {}),
            "支持正则(i), 语法：/abc|\\d+/ ",
            /* @__PURE__ */ jsx$1("br", {}),
            "作用范围: 推荐 / 热门"
          ] }),
          /* @__PURE__ */ jsx$1(SwitchSettingItem, { configPath: "filter.byTitle.enabled", disabled: !enabled, className: "ml-10px" })
        ] }),
        /* @__PURE__ */ jsx$1(EditableListSettingItem, { configPath: "filter.byTitle.keywords", searchProps: {
          placeholder: "添加过滤关键词"
        }, disabled: !enabled || !byTitle.enabled })
      ] })
    ] }) }) });
  }
  function useCombinedRefs() {
    for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) {
      refs[_key] = arguments[_key];
    }
    return H.useMemo(
      () => (node2) => {
        refs.forEach((ref) => ref(node2));
      },
      // eslint-disable-next-line react-hooks/exhaustive-deps
      refs
    );
  }
  const canUseDOM = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
  function isWindow(element) {
    const elementString = Object.prototype.toString.call(element);
    return elementString === "[object Window]" || // In Electron context the Window object serializes to [object global]
    elementString === "[object global]";
  }
  function isNode(node2) {
    return "nodeType" in node2;
  }
  function getWindow(target) {
    var _target$ownerDocument, _target$ownerDocument2;
    if (!target) {
      return window;
    }
    if (isWindow(target)) {
      return target;
    }
    if (!isNode(target)) {
      return window;
    }
    return (_target$ownerDocument = (_target$ownerDocument2 = target.ownerDocument) == null ? void 0 : _target$ownerDocument2.defaultView) != null ? _target$ownerDocument : window;
  }
  function isDocument(node2) {
    const {
      Document
    } = getWindow(node2);
    return node2 instanceof Document;
  }
  function isHTMLElement(node2) {
    if (isWindow(node2)) {
      return false;
    }
    return node2 instanceof getWindow(node2).HTMLElement;
  }
  function isSVGElement(node2) {
    return node2 instanceof getWindow(node2).SVGElement;
  }
  function getOwnerDocument(target) {
    if (!target) {
      return document;
    }
    if (isWindow(target)) {
      return target.document;
    }
    if (!isNode(target)) {
      return document;
    }
    if (isDocument(target)) {
      return target;
    }
    if (isHTMLElement(target) || isSVGElement(target)) {
      return target.ownerDocument;
    }
    return document;
  }
  const useIsomorphicLayoutEffect = canUseDOM ? H.useLayoutEffect : H.useEffect;
  function useEvent(handler) {
    const handlerRef = H.useRef(handler);
    useIsomorphicLayoutEffect(() => {
      handlerRef.current = handler;
    });
    return H.useCallback(function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return handlerRef.current == null ? void 0 : handlerRef.current(...args);
    }, []);
  }
  function useInterval() {
    const intervalRef = H.useRef(null);
    const set2 = H.useCallback((listener, duration2) => {
      intervalRef.current = setInterval(listener, duration2);
    }, []);
    const clear = H.useCallback(() => {
      if (intervalRef.current !== null) {
        clearInterval(intervalRef.current);
        intervalRef.current = null;
      }
    }, []);
    return [set2, clear];
  }
  function useLatestValue(value, dependencies) {
    if (dependencies === void 0) {
      dependencies = [value];
    }
    const valueRef = H.useRef(value);
    useIsomorphicLayoutEffect(() => {
      if (valueRef.current !== value) {
        valueRef.current = value;
      }
    }, dependencies);
    return valueRef;
  }
  function useLazyMemo(callback, dependencies) {
    const valueRef = H.useRef();
    return H.useMemo(
      () => {
        const newValue = callback(valueRef.current);
        valueRef.current = newValue;
        return newValue;
      },
      // eslint-disable-next-line react-hooks/exhaustive-deps
      [...dependencies]
    );
  }
  function useNodeRef(onChange) {
    const onChangeHandler = useEvent(onChange);
    const node2 = H.useRef(null);
    const setNodeRef = H.useCallback(
      (element) => {
        if (element !== node2.current) {
          onChangeHandler == null ? void 0 : onChangeHandler(element, node2.current);
        }
        node2.current = element;
      },
      //eslint-disable-next-line
      []
    );
    return [node2, setNodeRef];
  }
  function usePrevious(value) {
    const ref = H.useRef();
    H.useEffect(() => {
      ref.current = value;
    }, [value]);
    return ref.current;
  }
  let ids = {};
  function useUniqueId(prefix2, value) {
    return H.useMemo(() => {
      if (value) {
        return value;
      }
      const id = ids[prefix2] == null ? 0 : ids[prefix2] + 1;
      ids[prefix2] = id;
      return prefix2 + "-" + id;
    }, [prefix2, value]);
  }
  function createAdjustmentFn(modifier) {
    return function(object) {
      for (var _len = arguments.length, adjustments = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        adjustments[_key - 1] = arguments[_key];
      }
      return adjustments.reduce((accumulator, adjustment) => {
        const entries = Object.entries(adjustment);
        for (const [key, valueAdjustment] of entries) {
          const value = accumulator[key];
          if (value != null) {
            accumulator[key] = value + modifier * valueAdjustment;
          }
        }
        return accumulator;
      }, {
        ...object
      });
    };
  }
  const add = /* @__PURE__ */ createAdjustmentFn(1);
  const subtract = /* @__PURE__ */ createAdjustmentFn(-1);
  function hasViewportRelativeCoordinates(event) {
    return "clientX" in event && "clientY" in event;
  }
  function isKeyboardEvent(event) {
    if (!event) {
      return false;
    }
    const {
      KeyboardEvent
    } = getWindow(event.target);
    return KeyboardEvent && event instanceof KeyboardEvent;
  }
  function isTouchEvent(event) {
    if (!event) {
      return false;
    }
    const {
      TouchEvent
    } = getWindow(event.target);
    return TouchEvent && event instanceof TouchEvent;
  }
  function getEventCoordinates(event) {
    if (isTouchEvent(event)) {
      if (event.touches && event.touches.length) {
        const {
          clientX: x,
          clientY: y
        } = event.touches[0];
        return {
          x,
          y
        };
      } else if (event.changedTouches && event.changedTouches.length) {
        const {
          clientX: x,
          clientY: y
        } = event.changedTouches[0];
        return {
          x,
          y
        };
      }
    }
    if (hasViewportRelativeCoordinates(event)) {
      return {
        x: event.clientX,
        y: event.clientY
      };
    }
    return null;
  }
  const CSS = /* @__PURE__ */ Object.freeze({
    Translate: {
      toString(transform) {
        if (!transform) {
          return;
        }
        const {
          x,
          y
        } = transform;
        return "translate3d(" + (x ? Math.round(x) : 0) + "px, " + (y ? Math.round(y) : 0) + "px, 0)";
      }
    },
    Scale: {
      toString(transform) {
        if (!transform) {
          return;
        }
        const {
          scaleX,
          scaleY
        } = transform;
        return "scaleX(" + scaleX + ") scaleY(" + scaleY + ")";
      }
    },
    Transform: {
      toString(transform) {
        if (!transform) {
          return;
        }
        return [CSS.Translate.toString(transform), CSS.Scale.toString(transform)].join(" ");
      }
    },
    Transition: {
      toString(_ref7) {
        let {
          property,
          duration: duration2,
          easing
        } = _ref7;
        return property + " " + duration2 + "ms " + easing;
      }
    }
  });
  const SELECTOR = "a,frame,iframe,input:not([type=hidden]):not(:disabled),select:not(:disabled),textarea:not(:disabled),button:not(:disabled),*[tabindex]";
  function findFirstFocusableNode(element) {
    if (element.matches(SELECTOR)) {
      return element;
    }
    return element.querySelector(SELECTOR);
  }
  const hiddenStyles = {
    display: "none"
  };
  function HiddenText(_ref7) {
    let {
      id,
      value
    } = _ref7;
    return H.createElement("div", {
      id,
      style: hiddenStyles
    }, value);
  }
  function LiveRegion(_ref7) {
    let {
      id,
      announcement,
      ariaLiveType = "assertive"
    } = _ref7;
    const visuallyHidden = {
      position: "fixed",
      top: 0,
      left: 0,
      width: 1,
      height: 1,
      margin: -1,
      border: 0,
      padding: 0,
      overflow: "hidden",
      clip: "rect(0 0 0 0)",
      clipPath: "inset(100%)",
      whiteSpace: "nowrap"
    };
    return H.createElement("div", {
      id,
      style: visuallyHidden,
      role: "status",
      "aria-live": ariaLiveType,
      "aria-atomic": true
    }, announcement);
  }
  function useAnnouncement() {
    const [announcement, setAnnouncement] = H.useState("");
    const announce = H.useCallback((value) => {
      if (value != null) {
        setAnnouncement(value);
      }
    }, []);
    return {
      announce,
      announcement
    };
  }
  const DndMonitorContext = /* @__PURE__ */ H.createContext(null);
  function useDndMonitor(listener) {
    const registerListener = H.useContext(DndMonitorContext);
    H.useEffect(() => {
      if (!registerListener) {
        throw new Error("useDndMonitor must be used within a children of <DndContext>");
      }
      const unsubscribe = registerListener(listener);
      return unsubscribe;
    }, [listener, registerListener]);
  }
  function useDndMonitorProvider() {
    const [listeners2] = H.useState(() => /* @__PURE__ */ new Set());
    const registerListener = H.useCallback((listener) => {
      listeners2.add(listener);
      return () => listeners2.delete(listener);
    }, [listeners2]);
    const dispatch = H.useCallback((_ref7) => {
      let {
        type,
        event
      } = _ref7;
      listeners2.forEach((listener) => {
        var _listener$type;
        return (_listener$type = listener[type]) == null ? void 0 : _listener$type.call(listener, event);
      });
    }, [listeners2]);
    return [dispatch, registerListener];
  }
  const defaultScreenReaderInstructions = {
    draggable: "\n    To pick up a draggable item, press the space bar.\n    While dragging, use the arrow keys to move the item.\n    Press space again to drop the item in its new position, or press escape to cancel.\n  "
  };
  const defaultAnnouncements = {
    onDragStart(_ref7) {
      let {
        active
      } = _ref7;
      return "Picked up draggable item " + active.id + ".";
    },
    onDragOver(_ref22) {
      let {
        active,
        over
      } = _ref22;
      if (over) {
        return "Draggable item " + active.id + " was moved over droppable area " + over.id + ".";
      }
      return "Draggable item " + active.id + " is no longer over a droppable area.";
    },
    onDragEnd(_ref32) {
      let {
        active,
        over
      } = _ref32;
      if (over) {
        return "Draggable item " + active.id + " was dropped over droppable area " + over.id;
      }
      return "Draggable item " + active.id + " was dropped.";
    },
    onDragCancel(_ref42) {
      let {
        active
      } = _ref42;
      return "Dragging was cancelled. Draggable item " + active.id + " was dropped.";
    }
  };
  function Accessibility(_ref7) {
    let {
      announcements = defaultAnnouncements,
      container,
      hiddenTextDescribedById,
      screenReaderInstructions = defaultScreenReaderInstructions
    } = _ref7;
    const {
      announce,
      announcement
    } = useAnnouncement();
    const liveRegionId = useUniqueId("DndLiveRegion");
    const [mounted, setMounted] = H.useState(false);
    H.useEffect(() => {
      setMounted(true);
    }, []);
    useDndMonitor(H.useMemo(() => ({
      onDragStart(_ref22) {
        let {
          active
        } = _ref22;
        announce(announcements.onDragStart({
          active
        }));
      },
      onDragMove(_ref32) {
        let {
          active,
          over
        } = _ref32;
        if (announcements.onDragMove) {
          announce(announcements.onDragMove({
            active,
            over
          }));
        }
      },
      onDragOver(_ref42) {
        let {
          active,
          over
        } = _ref42;
        announce(announcements.onDragOver({
          active,
          over
        }));
      },
      onDragEnd(_ref52) {
        let {
          active,
          over
        } = _ref52;
        announce(announcements.onDragEnd({
          active,
          over
        }));
      },
      onDragCancel(_ref62) {
        let {
          active,
          over
        } = _ref62;
        announce(announcements.onDragCancel({
          active,
          over
        }));
      }
    }), [announce, announcements]));
    if (!mounted) {
      return null;
    }
    const markup = H.createElement(H.Fragment, null, H.createElement(HiddenText, {
      id: hiddenTextDescribedById,
      value: screenReaderInstructions.draggable
    }), H.createElement(LiveRegion, {
      id: liveRegionId,
      announcement
    }));
    return container ? require$$0.createPortal(markup, container) : markup;
  }
  var Action;
  (function(Action2) {
    Action2["DragStart"] = "dragStart";
    Action2["DragMove"] = "dragMove";
    Action2["DragEnd"] = "dragEnd";
    Action2["DragCancel"] = "dragCancel";
    Action2["DragOver"] = "dragOver";
    Action2["RegisterDroppable"] = "registerDroppable";
    Action2["SetDroppableDisabled"] = "setDroppableDisabled";
    Action2["UnregisterDroppable"] = "unregisterDroppable";
  })(Action || (Action = {}));
  function noop() {
  }
  function useSensor(sensor, options) {
    return H.useMemo(
      () => ({
        sensor,
        options: {}
      }),
      // eslint-disable-next-line react-hooks/exhaustive-deps
      [sensor, options]
    );
  }
  function useSensors() {
    for (var _len = arguments.length, sensors = new Array(_len), _key = 0; _key < _len; _key++) {
      sensors[_key] = arguments[_key];
    }
    return H.useMemo(
      () => [...sensors].filter((sensor) => sensor != null),
      // eslint-disable-next-line react-hooks/exhaustive-deps
      [...sensors]
    );
  }
  const defaultCoordinates = /* @__PURE__ */ Object.freeze({
    x: 0,
    y: 0
  });
  function distanceBetween(p1, p2) {
    return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
  }
  function sortCollisionsAsc(_ref7, _ref22) {
    let {
      data: {
        value: a2
      }
    } = _ref7;
    let {
      data: {
        value: b
      }
    } = _ref22;
    return a2 - b;
  }
  function sortCollisionsDesc(_ref32, _ref42) {
    let {
      data: {
        value: a2
      }
    } = _ref32;
    let {
      data: {
        value: b
      }
    } = _ref42;
    return b - a2;
  }
  function getFirstCollision(collisions, property) {
    if (!collisions || collisions.length === 0) {
      return null;
    }
    const [firstCollision] = collisions;
    return firstCollision[property];
  }
  function centerOfRectangle(rect, left, top) {
    if (left === void 0) {
      left = rect.left;
    }
    if (top === void 0) {
      top = rect.top;
    }
    return {
      x: left + rect.width * 0.5,
      y: top + rect.height * 0.5
    };
  }
  const closestCenter = (_ref7) => {
    let {
      collisionRect,
      droppableRects,
      droppableContainers
    } = _ref7;
    const centerRect = centerOfRectangle(collisionRect, collisionRect.left, collisionRect.top);
    const collisions = [];
    for (const droppableContainer of droppableContainers) {
      const {
        id
      } = droppableContainer;
      const rect = droppableRects.get(id);
      if (rect) {
        const distBetween = distanceBetween(centerOfRectangle(rect), centerRect);
        collisions.push({
          id,
          data: {
            droppableContainer,
            value: distBetween
          }
        });
      }
    }
    return collisions.sort(sortCollisionsAsc);
  };
  function getIntersectionRatio(entry, target) {
    const top = Math.max(target.top, entry.top);
    const left = Math.max(target.left, entry.left);
    const right = Math.min(target.left + target.width, entry.left + entry.width);
    const bottom = Math.min(target.top + target.height, entry.top + entry.height);
    const width = right - left;
    const height = bottom - top;
    if (left < right && top < bottom) {
      const targetArea = target.width * target.height;
      const entryArea = entry.width * entry.height;
      const intersectionArea = width * height;
      const intersectionRatio = intersectionArea / (targetArea + entryArea - intersectionArea);
      return Number(intersectionRatio.toFixed(4));
    }
    return 0;
  }
  const rectIntersection = (_ref7) => {
    let {
      collisionRect,
      droppableRects,
      droppableContainers
    } = _ref7;
    const collisions = [];
    for (const droppableContainer of droppableContainers) {
      const {
        id
      } = droppableContainer;
      const rect = droppableRects.get(id);
      if (rect) {
        const intersectionRatio = getIntersectionRatio(rect, collisionRect);
        if (intersectionRatio > 0) {
          collisions.push({
            id,
            data: {
              droppableContainer,
              value: intersectionRatio
            }
          });
        }
      }
    }
    return collisions.sort(sortCollisionsDesc);
  };
  function adjustScale(transform, rect1, rect2) {
    return {
      ...transform,
      scaleX: rect1 && rect2 ? rect1.width / rect2.width : 1,
      scaleY: rect1 && rect2 ? rect1.height / rect2.height : 1
    };
  }
  function getRectDelta(rect1, rect2) {
    return rect1 && rect2 ? {
      x: rect1.left - rect2.left,
      y: rect1.top - rect2.top
    } : defaultCoordinates;
  }
  function createRectAdjustmentFn(modifier) {
    return function adjustClientRect(rect) {
      for (var _len = arguments.length, adjustments = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        adjustments[_key - 1] = arguments[_key];
      }
      return adjustments.reduce((acc, adjustment) => ({
        ...acc,
        top: acc.top + modifier * adjustment.y,
        bottom: acc.bottom + modifier * adjustment.y,
        left: acc.left + modifier * adjustment.x,
        right: acc.right + modifier * adjustment.x
      }), {
        ...rect
      });
    };
  }
  const getAdjustedRect = /* @__PURE__ */ createRectAdjustmentFn(1);
  function parseTransform(transform) {
    if (transform.startsWith("matrix3d(")) {
      const transformArray = transform.slice(9, -1).split(/, /);
      return {
        x: +transformArray[12],
        y: +transformArray[13],
        scaleX: +transformArray[0],
        scaleY: +transformArray[5]
      };
    } else if (transform.startsWith("matrix(")) {
      const transformArray = transform.slice(7, -1).split(/, /);
      return {
        x: +transformArray[4],
        y: +transformArray[5],
        scaleX: +transformArray[0],
        scaleY: +transformArray[3]
      };
    }
    return null;
  }
  function inverseTransform(rect, transform, transformOrigin) {
    const parsedTransform = parseTransform(transform);
    if (!parsedTransform) {
      return rect;
    }
    const {
      scaleX,
      scaleY,
      x: translateX,
      y: translateY
    } = parsedTransform;
    const x = rect.left - translateX - (1 - scaleX) * parseFloat(transformOrigin);
    const y = rect.top - translateY - (1 - scaleY) * parseFloat(transformOrigin.slice(transformOrigin.indexOf(" ") + 1));
    const w = scaleX ? rect.width / scaleX : rect.width;
    const h = scaleY ? rect.height / scaleY : rect.height;
    return {
      width: w,
      height: h,
      top: y,
      right: x + w,
      bottom: y + h,
      left: x
    };
  }
  const defaultOptions = {
    ignoreTransform: false
  };
  function getClientRect(element, options) {
    if (options === void 0) {
      options = defaultOptions;
    }
    let rect = element.getBoundingClientRect();
    if (options.ignoreTransform) {
      const {
        transform,
        transformOrigin
      } = getWindow(element).getComputedStyle(element);
      if (transform) {
        rect = inverseTransform(rect, transform, transformOrigin);
      }
    }
    const {
      top,
      left,
      width,
      height,
      bottom,
      right
    } = rect;
    return {
      top,
      left,
      width,
      height,
      bottom,
      right
    };
  }
  function getTransformAgnosticClientRect(element) {
    return getClientRect(element, {
      ignoreTransform: true
    });
  }
  function getWindowClientRect(element) {
    const width = element.innerWidth;
    const height = element.innerHeight;
    return {
      top: 0,
      left: 0,
      right: width,
      bottom: height,
      width,
      height
    };
  }
  function isFixed(node2, computedStyle) {
    if (computedStyle === void 0) {
      computedStyle = getWindow(node2).getComputedStyle(node2);
    }
    return computedStyle.position === "fixed";
  }
  function isScrollable(element, computedStyle) {
    if (computedStyle === void 0) {
      computedStyle = getWindow(element).getComputedStyle(element);
    }
    const overflowRegex = /(auto|scroll|overlay)/;
    const properties2 = ["overflow", "overflowX", "overflowY"];
    return properties2.some((property) => {
      const value = computedStyle[property];
      return typeof value === "string" ? overflowRegex.test(value) : false;
    });
  }
  function getScrollableAncestors(element, limit2) {
    const scrollParents = [];
    function findScrollableAncestors(node2) {
      if (limit2 != null && scrollParents.length >= limit2) {
        return scrollParents;
      }
      if (!node2) {
        return scrollParents;
      }
      if (isDocument(node2) && node2.scrollingElement != null && !scrollParents.includes(node2.scrollingElement)) {
        scrollParents.push(node2.scrollingElement);
        return scrollParents;
      }
      if (!isHTMLElement(node2) || isSVGElement(node2)) {
        return scrollParents;
      }
      if (scrollParents.includes(node2)) {
        return scrollParents;
      }
      const computedStyle = getWindow(element).getComputedStyle(node2);
      if (node2 !== element) {
        if (isScrollable(node2, computedStyle)) {
          scrollParents.push(node2);
        }
      }
      if (isFixed(node2, computedStyle)) {
        return scrollParents;
      }
      return findScrollableAncestors(node2.parentNode);
    }
    if (!element) {
      return scrollParents;
    }
    return findScrollableAncestors(element);
  }
  function getFirstScrollableAncestor(node2) {
    const [firstScrollableAncestor] = getScrollableAncestors(node2, 1);
    return firstScrollableAncestor != null ? firstScrollableAncestor : null;
  }
  function getScrollableElement(element) {
    if (!canUseDOM || !element) {
      return null;
    }
    if (isWindow(element)) {
      return element;
    }
    if (!isNode(element)) {
      return null;
    }
    if (isDocument(element) || element === getOwnerDocument(element).scrollingElement) {
      return window;
    }
    if (isHTMLElement(element)) {
      return element;
    }
    return null;
  }
  function getScrollXCoordinate(element) {
    if (isWindow(element)) {
      return element.scrollX;
    }
    return element.scrollLeft;
  }
  function getScrollYCoordinate(element) {
    if (isWindow(element)) {
      return element.scrollY;
    }
    return element.scrollTop;
  }
  function getScrollCoordinates(element) {
    return {
      x: getScrollXCoordinate(element),
      y: getScrollYCoordinate(element)
    };
  }
  var Direction;
  (function(Direction2) {
    Direction2[Direction2["Forward"] = 1] = "Forward";
    Direction2[Direction2["Backward"] = -1] = "Backward";
  })(Direction || (Direction = {}));
  function isDocumentScrollingElement(element) {
    if (!canUseDOM || !element) {
      return false;
    }
    return element === document.scrollingElement;
  }
  function getScrollPosition(scrollingContainer) {
    const minScroll = {
      x: 0,
      y: 0
    };
    const dimensions = isDocumentScrollingElement(scrollingContainer) ? {
      height: window.innerHeight,
      width: window.innerWidth
    } : {
      height: scrollingContainer.clientHeight,
      width: scrollingContainer.clientWidth
    };
    const maxScroll = {
      x: scrollingContainer.scrollWidth - dimensions.width,
      y: scrollingContainer.scrollHeight - dimensions.height
    };
    const isTop = scrollingContainer.scrollTop <= minScroll.y;
    const isLeft = scrollingContainer.scrollLeft <= minScroll.x;
    const isBottom = scrollingContainer.scrollTop >= maxScroll.y;
    const isRight = scrollingContainer.scrollLeft >= maxScroll.x;
    return {
      isTop,
      isLeft,
      isBottom,
      isRight,
      maxScroll,
      minScroll
    };
  }
  const defaultThreshold = {
    x: 0.2,
    y: 0.2
  };
  function getScrollDirectionAndSpeed(scrollContainer, scrollContainerRect, _ref7, acceleration, thresholdPercentage) {
    let {
      top,
      left,
      right,
      bottom
    } = _ref7;
    if (acceleration === void 0) {
      acceleration = 10;
    }
    if (thresholdPercentage === void 0) {
      thresholdPercentage = defaultThreshold;
    }
    const {
      isTop,
      isBottom,
      isLeft,
      isRight
    } = getScrollPosition(scrollContainer);
    const direction = {
      x: 0,
      y: 0
    };
    const speed = {
      x: 0,
      y: 0
    };
    const threshold = {
      height: scrollContainerRect.height * thresholdPercentage.y,
      width: scrollContainerRect.width * thresholdPercentage.x
    };
    if (!isTop && top <= scrollContainerRect.top + threshold.height) {
      direction.y = Direction.Backward;
      speed.y = acceleration * Math.abs((scrollContainerRect.top + threshold.height - top) / threshold.height);
    } else if (!isBottom && bottom >= scrollContainerRect.bottom - threshold.height) {
      direction.y = Direction.Forward;
      speed.y = acceleration * Math.abs((scrollContainerRect.bottom - threshold.height - bottom) / threshold.height);
    }
    if (!isRight && right >= scrollContainerRect.right - threshold.width) {
      direction.x = Direction.Forward;
      speed.x = acceleration * Math.abs((scrollContainerRect.right - threshold.width - right) / threshold.width);
    } else if (!isLeft && left <= scrollContainerRect.left + threshold.width) {
      direction.x = Direction.Backward;
      speed.x = acceleration * Math.abs((scrollContainerRect.left + threshold.width - left) / threshold.width);
    }
    return {
      direction,
      speed
    };
  }
  function getScrollElementRect(element) {
    if (element === document.scrollingElement) {
      const {
        innerWidth,
        innerHeight
      } = window;
      return {
        top: 0,
        left: 0,
        right: innerWidth,
        bottom: innerHeight,
        width: innerWidth,
        height: innerHeight
      };
    }
    const {
      top,
      left,
      right,
      bottom
    } = element.getBoundingClientRect();
    return {
      top,
      left,
      right,
      bottom,
      width: element.clientWidth,
      height: element.clientHeight
    };
  }
  function getScrollOffsets(scrollableAncestors) {
    return scrollableAncestors.reduce((acc, node2) => {
      return add(acc, getScrollCoordinates(node2));
    }, defaultCoordinates);
  }
  function getScrollXOffset(scrollableAncestors) {
    return scrollableAncestors.reduce((acc, node2) => {
      return acc + getScrollXCoordinate(node2);
    }, 0);
  }
  function getScrollYOffset(scrollableAncestors) {
    return scrollableAncestors.reduce((acc, node2) => {
      return acc + getScrollYCoordinate(node2);
    }, 0);
  }
  function scrollIntoViewIfNeeded(element, measure) {
    if (measure === void 0) {
      measure = getClientRect;
    }
    if (!element) {
      return;
    }
    const {
      top,
      left,
      bottom,
      right
    } = measure(element);
    const firstScrollableAncestor = getFirstScrollableAncestor(element);
    if (!firstScrollableAncestor) {
      return;
    }
    if (bottom <= 0 || right <= 0 || top >= window.innerHeight || left >= window.innerWidth) {
      element.scrollIntoView({
        block: "center",
        inline: "center"
      });
    }
  }
  const properties = [["x", ["left", "right"], getScrollXOffset], ["y", ["top", "bottom"], getScrollYOffset]];
  class Rect {
    constructor(rect, element) {
      this.rect = void 0;
      this.width = void 0;
      this.height = void 0;
      this.top = void 0;
      this.bottom = void 0;
      this.right = void 0;
      this.left = void 0;
      const scrollableAncestors = getScrollableAncestors(element);
      const scrollOffsets = getScrollOffsets(scrollableAncestors);
      this.rect = {
        ...rect
      };
      this.width = rect.width;
      this.height = rect.height;
      for (const [axis, keys, getScrollOffset] of properties) {
        for (const key of keys) {
          Object.defineProperty(this, key, {
            get: () => {
              const currentOffsets = getScrollOffset(scrollableAncestors);
              const scrollOffsetsDeltla = scrollOffsets[axis] - currentOffsets;
              return this.rect[key] + scrollOffsetsDeltla;
            },
            enumerable: true
          });
        }
      }
      Object.defineProperty(this, "rect", {
        enumerable: false
      });
    }
  }
  class Listeners {
    constructor(target) {
      this.target = void 0;
      this.listeners = [];
      this.removeAll = () => {
        this.listeners.forEach((listener) => {
          var _this$target;
          return (_this$target = this.target) == null ? void 0 : _this$target.removeEventListener(...listener);
        });
      };
      this.target = target;
    }
    add(eventName, handler, options) {
      var _this$target2;
      (_this$target2 = this.target) == null ? void 0 : _this$target2.addEventListener(eventName, handler, options);
      this.listeners.push([eventName, handler, options]);
    }
  }
  function getEventListenerTarget(target) {
    const {
      EventTarget
    } = getWindow(target);
    return target instanceof EventTarget ? target : getOwnerDocument(target);
  }
  function hasExceededDistance(delta, measurement) {
    const dx = Math.abs(delta.x);
    const dy = Math.abs(delta.y);
    if (typeof measurement === "number") {
      return Math.sqrt(dx ** 2 + dy ** 2) > measurement;
    }
    if ("x" in measurement && "y" in measurement) {
      return dx > measurement.x && dy > measurement.y;
    }
    if ("x" in measurement) {
      return dx > measurement.x;
    }
    if ("y" in measurement) {
      return dy > measurement.y;
    }
    return false;
  }
  var EventName;
  (function(EventName2) {
    EventName2["Click"] = "click";
    EventName2["DragStart"] = "dragstart";
    EventName2["Keydown"] = "keydown";
    EventName2["ContextMenu"] = "contextmenu";
    EventName2["Resize"] = "resize";
    EventName2["SelectionChange"] = "selectionchange";
    EventName2["VisibilityChange"] = "visibilitychange";
  })(EventName || (EventName = {}));
  function preventDefault(event) {
    event.preventDefault();
  }
  function stopPropagation(event) {
    event.stopPropagation();
  }
  var KeyboardCode;
  (function(KeyboardCode2) {
    KeyboardCode2["Space"] = "Space";
    KeyboardCode2["Down"] = "ArrowDown";
    KeyboardCode2["Right"] = "ArrowRight";
    KeyboardCode2["Left"] = "ArrowLeft";
    KeyboardCode2["Up"] = "ArrowUp";
    KeyboardCode2["Esc"] = "Escape";
    KeyboardCode2["Enter"] = "Enter";
    KeyboardCode2["Tab"] = "Tab";
  })(KeyboardCode || (KeyboardCode = {}));
  const defaultKeyboardCodes = {
    start: [KeyboardCode.Space, KeyboardCode.Enter],
    cancel: [KeyboardCode.Esc],
    end: [KeyboardCode.Space, KeyboardCode.Enter, KeyboardCode.Tab]
  };
  const defaultKeyboardCoordinateGetter = (event, _ref7) => {
    let {
      currentCoordinates
    } = _ref7;
    switch (event.code) {
      case KeyboardCode.Right:
        return {
          ...currentCoordinates,
          x: currentCoordinates.x + 25
        };
      case KeyboardCode.Left:
        return {
          ...currentCoordinates,
          x: currentCoordinates.x - 25
        };
      case KeyboardCode.Down:
        return {
          ...currentCoordinates,
          y: currentCoordinates.y + 25
        };
      case KeyboardCode.Up:
        return {
          ...currentCoordinates,
          y: currentCoordinates.y - 25
        };
    }
    return void 0;
  };
  class KeyboardSensor {
    constructor(props) {
      this.props = void 0;
      this.autoScrollEnabled = false;
      this.referenceCoordinates = void 0;
      this.listeners = void 0;
      this.windowListeners = void 0;
      this.props = props;
      const {
        event: {
          target
        }
      } = props;
      this.props = props;
      this.listeners = new Listeners(getOwnerDocument(target));
      this.windowListeners = new Listeners(getWindow(target));
      this.handleKeyDown = this.handleKeyDown.bind(this);
      this.handleCancel = this.handleCancel.bind(this);
      this.attach();
    }
    attach() {
      this.handleStart();
      this.windowListeners.add(EventName.Resize, this.handleCancel);
      this.windowListeners.add(EventName.VisibilityChange, this.handleCancel);
      setTimeout(() => this.listeners.add(EventName.Keydown, this.handleKeyDown));
    }
    handleStart() {
      const {
        activeNode,
        onStart
      } = this.props;
      const node2 = activeNode.node.current;
      if (node2) {
        scrollIntoViewIfNeeded(node2);
      }
      onStart(defaultCoordinates);
    }
    handleKeyDown(event) {
      if (isKeyboardEvent(event)) {
        const {
          active,
          context,
          options
        } = this.props;
        const {
          keyboardCodes = defaultKeyboardCodes,
          coordinateGetter = defaultKeyboardCoordinateGetter,
          scrollBehavior = "smooth"
        } = options;
        const {
          code
        } = event;
        if (keyboardCodes.end.includes(code)) {
          this.handleEnd(event);
          return;
        }
        if (keyboardCodes.cancel.includes(code)) {
          this.handleCancel(event);
          return;
        }
        const {
          collisionRect
        } = context.current;
        const currentCoordinates = collisionRect ? {
          x: collisionRect.left,
          y: collisionRect.top
        } : defaultCoordinates;
        if (!this.referenceCoordinates) {
          this.referenceCoordinates = currentCoordinates;
        }
        const newCoordinates = coordinateGetter(event, {
          active,
          context: context.current,
          currentCoordinates
        });
        if (newCoordinates) {
          const coordinatesDelta = subtract(newCoordinates, currentCoordinates);
          const scrollDelta = {
            x: 0,
            y: 0
          };
          const {
            scrollableAncestors
          } = context.current;
          for (const scrollContainer of scrollableAncestors) {
            const direction = event.code;
            const {
              isTop,
              isRight,
              isLeft,
              isBottom,
              maxScroll,
              minScroll
            } = getScrollPosition(scrollContainer);
            const scrollElementRect = getScrollElementRect(scrollContainer);
            const clampedCoordinates = {
              x: Math.min(direction === KeyboardCode.Right ? scrollElementRect.right - scrollElementRect.width / 2 : scrollElementRect.right, Math.max(direction === KeyboardCode.Right ? scrollElementRect.left : scrollElementRect.left + scrollElementRect.width / 2, newCoordinates.x)),
              y: Math.min(direction === KeyboardCode.Down ? scrollElementRect.bottom - scrollElementRect.height / 2 : scrollElementRect.bottom, Math.max(direction === KeyboardCode.Down ? scrollElementRect.top : scrollElementRect.top + scrollElementRect.height / 2, newCoordinates.y))
            };
            const canScrollX = direction === KeyboardCode.Right && !isRight || direction === KeyboardCode.Left && !isLeft;
            const canScrollY = direction === KeyboardCode.Down && !isBottom || direction === KeyboardCode.Up && !isTop;
            if (canScrollX && clampedCoordinates.x !== newCoordinates.x) {
              const newScrollCoordinates = scrollContainer.scrollLeft + coordinatesDelta.x;
              const canScrollToNewCoordinates = direction === KeyboardCode.Right && newScrollCoordinates <= maxScroll.x || direction === KeyboardCode.Left && newScrollCoordinates >= minScroll.x;
              if (canScrollToNewCoordinates && !coordinatesDelta.y) {
                scrollContainer.scrollTo({
                  left: newScrollCoordinates,
                  behavior: scrollBehavior
                });
                return;
              }
              if (canScrollToNewCoordinates) {
                scrollDelta.x = scrollContainer.scrollLeft - newScrollCoordinates;
              } else {
                scrollDelta.x = direction === KeyboardCode.Right ? scrollContainer.scrollLeft - maxScroll.x : scrollContainer.scrollLeft - minScroll.x;
              }
              if (scrollDelta.x) {
                scrollContainer.scrollBy({
                  left: -scrollDelta.x,
                  behavior: scrollBehavior
                });
              }
              break;
            } else if (canScrollY && clampedCoordinates.y !== newCoordinates.y) {
              const newScrollCoordinates = scrollContainer.scrollTop + coordinatesDelta.y;
              const canScrollToNewCoordinates = direction === KeyboardCode.Down && newScrollCoordinates <= maxScroll.y || direction === KeyboardCode.Up && newScrollCoordinates >= minScroll.y;
              if (canScrollToNewCoordinates && !coordinatesDelta.x) {
                scrollContainer.scrollTo({
                  top: newScrollCoordinates,
                  behavior: scrollBehavior
                });
                return;
              }
              if (canScrollToNewCoordinates) {
                scrollDelta.y = scrollContainer.scrollTop - newScrollCoordinates;
              } else {
                scrollDelta.y = direction === KeyboardCode.Down ? scrollContainer.scrollTop - maxScroll.y : scrollContainer.scrollTop - minScroll.y;
              }
              if (scrollDelta.y) {
                scrollContainer.scrollBy({
                  top: -scrollDelta.y,
                  behavior: scrollBehavior
                });
              }
              break;
            }
          }
          this.handleMove(event, add(subtract(newCoordinates, this.referenceCoordinates), scrollDelta));
        }
      }
    }
    handleMove(event, coordinates) {
      const {
        onMove
      } = this.props;
      event.preventDefault();
      onMove(coordinates);
    }
    handleEnd(event) {
      const {
        onEnd
      } = this.props;
      event.preventDefault();
      this.detach();
      onEnd();
    }
    handleCancel(event) {
      const {
        onCancel
      } = this.props;
      event.preventDefault();
      this.detach();
      onCancel();
    }
    detach() {
      this.listeners.removeAll();
      this.windowListeners.removeAll();
    }
  }
  KeyboardSensor.activators = [{
    eventName: "onKeyDown",
    handler: (event, _ref7, _ref22) => {
      let {
        keyboardCodes = defaultKeyboardCodes,
        onActivation
      } = _ref7;
      let {
        active
      } = _ref22;
      const {
        code
      } = event.nativeEvent;
      if (keyboardCodes.start.includes(code)) {
        const activator = active.activatorNode.current;
        if (activator && event.target !== activator) {
          return false;
        }
        event.preventDefault();
        onActivation == null ? void 0 : onActivation({
          event: event.nativeEvent
        });
        return true;
      }
      return false;
    }
  }];
  function isDistanceConstraint(constraint) {
    return Boolean(constraint && "distance" in constraint);
  }
  function isDelayConstraint(constraint) {
    return Boolean(constraint && "delay" in constraint);
  }
  class AbstractPointerSensor {
    constructor(props, events2, listenerTarget) {
      var _getEventCoordinates;
      if (listenerTarget === void 0) {
        listenerTarget = getEventListenerTarget(props.event.target);
      }
      this.props = void 0;
      this.events = void 0;
      this.autoScrollEnabled = true;
      this.document = void 0;
      this.activated = false;
      this.initialCoordinates = void 0;
      this.timeoutId = null;
      this.listeners = void 0;
      this.documentListeners = void 0;
      this.windowListeners = void 0;
      this.props = props;
      this.events = events2;
      const {
        event
      } = props;
      const {
        target
      } = event;
      this.props = props;
      this.events = events2;
      this.document = getOwnerDocument(target);
      this.documentListeners = new Listeners(this.document);
      this.listeners = new Listeners(listenerTarget);
      this.windowListeners = new Listeners(getWindow(target));
      this.initialCoordinates = (_getEventCoordinates = getEventCoordinates(event)) != null ? _getEventCoordinates : defaultCoordinates;
      this.handleStart = this.handleStart.bind(this);
      this.handleMove = this.handleMove.bind(this);
      this.handleEnd = this.handleEnd.bind(this);
      this.handleCancel = this.handleCancel.bind(this);
      this.handleKeydown = this.handleKeydown.bind(this);
      this.removeTextSelection = this.removeTextSelection.bind(this);
      this.attach();
    }
    attach() {
      const {
        events: events2,
        props: {
          options: {
            activationConstraint,
            bypassActivationConstraint
          }
        }
      } = this;
      this.listeners.add(events2.move.name, this.handleMove, {
        passive: false
      });
      this.listeners.add(events2.end.name, this.handleEnd);
      if (events2.cancel) {
        this.listeners.add(events2.cancel.name, this.handleCancel);
      }
      this.windowListeners.add(EventName.Resize, this.handleCancel);
      this.windowListeners.add(EventName.DragStart, preventDefault);
      this.windowListeners.add(EventName.VisibilityChange, this.handleCancel);
      this.windowListeners.add(EventName.ContextMenu, preventDefault);
      this.documentListeners.add(EventName.Keydown, this.handleKeydown);
      if (activationConstraint) {
        if (bypassActivationConstraint != null && bypassActivationConstraint({
          event: this.props.event,
          activeNode: this.props.activeNode,
          options: this.props.options
        })) {
          return this.handleStart();
        }
        if (isDelayConstraint(activationConstraint)) {
          this.timeoutId = setTimeout(this.handleStart, activationConstraint.delay);
          this.handlePending(activationConstraint);
          return;
        }
        if (isDistanceConstraint(activationConstraint)) {
          this.handlePending(activationConstraint);
          return;
        }
      }
      this.handleStart();
    }
    detach() {
      this.listeners.removeAll();
      this.windowListeners.removeAll();
      setTimeout(this.documentListeners.removeAll, 50);
      if (this.timeoutId !== null) {
        clearTimeout(this.timeoutId);
        this.timeoutId = null;
      }
    }
    handlePending(constraint, offset) {
      const {
        active,
        onPending
      } = this.props;
      onPending(active, constraint, this.initialCoordinates, offset);
    }
    handleStart() {
      const {
        initialCoordinates
      } = this;
      const {
        onStart
      } = this.props;
      if (initialCoordinates) {
        this.activated = true;
        this.documentListeners.add(EventName.Click, stopPropagation, {
          capture: true
        });
        this.removeTextSelection();
        this.documentListeners.add(EventName.SelectionChange, this.removeTextSelection);
        onStart(initialCoordinates);
      }
    }
    handleMove(event) {
      var _getEventCoordinates2;
      const {
        activated,
        initialCoordinates,
        props
      } = this;
      const {
        onMove,
        options: {
          activationConstraint
        }
      } = props;
      if (!initialCoordinates) {
        return;
      }
      const coordinates = (_getEventCoordinates2 = getEventCoordinates(event)) != null ? _getEventCoordinates2 : defaultCoordinates;
      const delta = subtract(initialCoordinates, coordinates);
      if (!activated && activationConstraint) {
        if (isDistanceConstraint(activationConstraint)) {
          if (activationConstraint.tolerance != null && hasExceededDistance(delta, activationConstraint.tolerance)) {
            return this.handleCancel();
          }
          if (hasExceededDistance(delta, activationConstraint.distance)) {
            return this.handleStart();
          }
        }
        if (isDelayConstraint(activationConstraint)) {
          if (hasExceededDistance(delta, activationConstraint.tolerance)) {
            return this.handleCancel();
          }
        }
        this.handlePending(activationConstraint, delta);
        return;
      }
      if (event.cancelable) {
        event.preventDefault();
      }
      onMove(coordinates);
    }
    handleEnd() {
      const {
        onAbort,
        onEnd
      } = this.props;
      this.detach();
      if (!this.activated) {
        onAbort(this.props.active);
      }
      onEnd();
    }
    handleCancel() {
      const {
        onAbort,
        onCancel
      } = this.props;
      this.detach();
      if (!this.activated) {
        onAbort(this.props.active);
      }
      onCancel();
    }
    handleKeydown(event) {
      if (event.code === KeyboardCode.Esc) {
        this.handleCancel();
      }
    }
    removeTextSelection() {
      var _this$document$getSel;
      (_this$document$getSel = this.document.getSelection()) == null ? void 0 : _this$document$getSel.removeAllRanges();
    }
  }
  const events = {
    cancel: {
      name: "pointercancel"
    },
    move: {
      name: "pointermove"
    },
    end: {
      name: "pointerup"
    }
  };
  class PointerSensor extends AbstractPointerSensor {
    constructor(props) {
      const {
        event
      } = props;
      const listenerTarget = getOwnerDocument(event.target);
      super(props, events, listenerTarget);
    }
  }
  PointerSensor.activators = [{
    eventName: "onPointerDown",
    handler: (_ref7, _ref22) => {
      let {
        nativeEvent: event
      } = _ref7;
      let {
        onActivation
      } = _ref22;
      if (!event.isPrimary || event.button !== 0) {
        return false;
      }
      onActivation == null ? void 0 : onActivation({
        event
      });
      return true;
    }
  }];
  const events$1 = {
    move: {
      name: "mousemove"
    },
    end: {
      name: "mouseup"
    }
  };
  var MouseButton;
  (function(MouseButton2) {
    MouseButton2[MouseButton2["RightClick"] = 2] = "RightClick";
  })(MouseButton || (MouseButton = {}));
  class MouseSensor extends AbstractPointerSensor {
    constructor(props) {
      super(props, events$1, getOwnerDocument(props.event.target));
    }
  }
  MouseSensor.activators = [{
    eventName: "onMouseDown",
    handler: (_ref7, _ref22) => {
      let {
        nativeEvent: event
      } = _ref7;
      let {
        onActivation
      } = _ref22;
      if (event.button === MouseButton.RightClick) {
        return false;
      }
      onActivation == null ? void 0 : onActivation({
        event
      });
      return true;
    }
  }];
  const events$2 = {
    cancel: {
      name: "touchcancel"
    },
    move: {
      name: "touchmove"
    },
    end: {
      name: "touchend"
    }
  };
  class TouchSensor extends AbstractPointerSensor {
    constructor(props) {
      super(props, events$2);
    }
    static setup() {
      window.addEventListener(events$2.move.name, noop2, {
        capture: false,
        passive: false
      });
      return function teardown() {
        window.removeEventListener(events$2.move.name, noop2);
      };
      function noop2() {
      }
    }
  }
  TouchSensor.activators = [{
    eventName: "onTouchStart",
    handler: (_ref7, _ref22) => {
      let {
        nativeEvent: event
      } = _ref7;
      let {
        onActivation
      } = _ref22;
      const {
        touches
      } = event;
      if (touches.length > 1) {
        return false;
      }
      onActivation == null ? void 0 : onActivation({
        event
      });
      return true;
    }
  }];
  var AutoScrollActivator;
  (function(AutoScrollActivator2) {
    AutoScrollActivator2[AutoScrollActivator2["Pointer"] = 0] = "Pointer";
    AutoScrollActivator2[AutoScrollActivator2["DraggableRect"] = 1] = "DraggableRect";
  })(AutoScrollActivator || (AutoScrollActivator = {}));
  var TraversalOrder;
  (function(TraversalOrder2) {
    TraversalOrder2[TraversalOrder2["TreeOrder"] = 0] = "TreeOrder";
    TraversalOrder2[TraversalOrder2["ReversedTreeOrder"] = 1] = "ReversedTreeOrder";
  })(TraversalOrder || (TraversalOrder = {}));
  function useAutoScroller(_ref7) {
    let {
      acceleration,
      activator = AutoScrollActivator.Pointer,
      canScroll,
      draggingRect,
      enabled,
      interval = 5,
      order = TraversalOrder.TreeOrder,
      pointerCoordinates,
      scrollableAncestors,
      scrollableAncestorRects,
      delta,
      threshold
    } = _ref7;
    const scrollIntent = useScrollIntent({
      delta,
      disabled: !enabled
    });
    const [setAutoScrollInterval, clearAutoScrollInterval] = useInterval();
    const scrollSpeed = H.useRef({
      x: 0,
      y: 0
    });
    const scrollDirection = H.useRef({
      x: 0,
      y: 0
    });
    const rect = H.useMemo(() => {
      switch (activator) {
        case AutoScrollActivator.Pointer:
          return pointerCoordinates ? {
            top: pointerCoordinates.y,
            bottom: pointerCoordinates.y,
            left: pointerCoordinates.x,
            right: pointerCoordinates.x
          } : null;
        case AutoScrollActivator.DraggableRect:
          return draggingRect;
      }
    }, [activator, draggingRect, pointerCoordinates]);
    const scrollContainerRef = H.useRef(null);
    const autoScroll = H.useCallback(() => {
      const scrollContainer = scrollContainerRef.current;
      if (!scrollContainer) {
        return;
      }
      const scrollLeft = scrollSpeed.current.x * scrollDirection.current.x;
      const scrollTop = scrollSpeed.current.y * scrollDirection.current.y;
      scrollContainer.scrollBy(scrollLeft, scrollTop);
    }, []);
    const sortedScrollableAncestors = H.useMemo(() => order === TraversalOrder.TreeOrder ? [...scrollableAncestors].reverse() : scrollableAncestors, [order, scrollableAncestors]);
    H.useEffect(
      () => {
        if (!enabled || !scrollableAncestors.length || !rect) {
          clearAutoScrollInterval();
          return;
        }
        for (const scrollContainer of sortedScrollableAncestors) {
          if ((canScroll == null ? void 0 : canScroll(scrollContainer)) === false) {
            continue;
          }
          const index = scrollableAncestors.indexOf(scrollContainer);
          const scrollContainerRect = scrollableAncestorRects[index];
          if (!scrollContainerRect) {
            continue;
          }
          const {
            direction,
            speed
          } = getScrollDirectionAndSpeed(scrollContainer, scrollContainerRect, rect, acceleration, threshold);
          for (const axis of ["x", "y"]) {
            if (!scrollIntent[axis][direction[axis]]) {
              speed[axis] = 0;
              direction[axis] = 0;
            }
          }
          if (speed.x > 0 || speed.y > 0) {
            clearAutoScrollInterval();
            scrollContainerRef.current = scrollContainer;
            setAutoScrollInterval(autoScroll, interval);
            scrollSpeed.current = speed;
            scrollDirection.current = direction;
            return;
          }
        }
        scrollSpeed.current = {
          x: 0,
          y: 0
        };
        scrollDirection.current = {
          x: 0,
          y: 0
        };
        clearAutoScrollInterval();
      },
      // eslint-disable-next-line react-hooks/exhaustive-deps
      [
        acceleration,
        autoScroll,
        canScroll,
        clearAutoScrollInterval,
        enabled,
        interval,
        // eslint-disable-next-line react-hooks/exhaustive-deps
        JSON.stringify(rect),
        // eslint-disable-next-line react-hooks/exhaustive-deps
        JSON.stringify(scrollIntent),
        setAutoScrollInterval,
        scrollableAncestors,
        sortedScrollableAncestors,
        scrollableAncestorRects,
        // eslint-disable-next-line react-hooks/exhaustive-deps
        JSON.stringify(threshold)
      ]
    );
  }
  const defaultScrollIntent = {
    x: {
      [Direction.Backward]: false,
      [Direction.Forward]: false
    },
    y: {
      [Direction.Backward]: false,
      [Direction.Forward]: false
    }
  };
  function useScrollIntent(_ref22) {
    let {
      delta,
      disabled
    } = _ref22;
    const previousDelta = usePrevious(delta);
    return useLazyMemo((previousIntent) => {
      if (disabled || !previousDelta || !previousIntent) {
        return defaultScrollIntent;
      }
      const direction = {
        x: Math.sign(delta.x - previousDelta.x),
        y: Math.sign(delta.y - previousDelta.y)
      };
      return {
        x: {
          [Direction.Backward]: previousIntent.x[Direction.Backward] || direction.x === -1,
          [Direction.Forward]: previousIntent.x[Direction.Forward] || direction.x === 1
        },
        y: {
          [Direction.Backward]: previousIntent.y[Direction.Backward] || direction.y === -1,
          [Direction.Forward]: previousIntent.y[Direction.Forward] || direction.y === 1
        }
      };
    }, [disabled, delta, previousDelta]);
  }
  function useCachedNode(draggableNodes, id) {
    const draggableNode = id != null ? draggableNodes.get(id) : void 0;
    const node2 = draggableNode ? draggableNode.node.current : null;
    return useLazyMemo((cachedNode) => {
      var _ref7;
      if (id == null) {
        return null;
      }
      return (_ref7 = node2 != null ? node2 : cachedNode) != null ? _ref7 : null;
    }, [node2, id]);
  }
  function useCombineActivators(sensors, getSyntheticHandler) {
    return H.useMemo(() => sensors.reduce((accumulator, sensor) => {
      const {
        sensor: Sensor
      } = sensor;
      const sensorActivators = Sensor.activators.map((activator) => ({
        eventName: activator.eventName,
        handler: getSyntheticHandler(activator.handler, sensor)
      }));
      return [...accumulator, ...sensorActivators];
    }, []), [sensors, getSyntheticHandler]);
  }
  var MeasuringStrategy;
  (function(MeasuringStrategy2) {
    MeasuringStrategy2[MeasuringStrategy2["Always"] = 0] = "Always";
    MeasuringStrategy2[MeasuringStrategy2["BeforeDragging"] = 1] = "BeforeDragging";
    MeasuringStrategy2[MeasuringStrategy2["WhileDragging"] = 2] = "WhileDragging";
  })(MeasuringStrategy || (MeasuringStrategy = {}));
  var MeasuringFrequency;
  (function(MeasuringFrequency2) {
    MeasuringFrequency2["Optimized"] = "optimized";
  })(MeasuringFrequency || (MeasuringFrequency = {}));
  const defaultValue = /* @__PURE__ */ new Map();
  function useDroppableMeasuring(containers, _ref7) {
    let {
      dragging,
      dependencies,
      config
    } = _ref7;
    const [queue, setQueue] = H.useState(null);
    const {
      frequency,
      measure,
      strategy
    } = config;
    const containersRef = H.useRef(containers);
    const disabled = isDisabled();
    const disabledRef = useLatestValue(disabled);
    const measureDroppableContainers = H.useCallback(function(ids2) {
      if (ids2 === void 0) {
        ids2 = [];
      }
      if (disabledRef.current) {
        return;
      }
      setQueue((value) => {
        if (value === null) {
          return ids2;
        }
        return value.concat(ids2.filter((id) => !value.includes(id)));
      });
    }, [disabledRef]);
    const timeoutId = H.useRef(null);
    const droppableRects = useLazyMemo((previousValue) => {
      if (disabled && !dragging) {
        return defaultValue;
      }
      if (!previousValue || previousValue === defaultValue || containersRef.current !== containers || queue != null) {
        const map = /* @__PURE__ */ new Map();
        for (let container of containers) {
          if (!container) {
            continue;
          }
          if (queue && queue.length > 0 && !queue.includes(container.id) && container.rect.current) {
            map.set(container.id, container.rect.current);
            continue;
          }
          const node2 = container.node.current;
          const rect = node2 ? new Rect(measure(node2), node2) : null;
          container.rect.current = rect;
          if (rect) {
            map.set(container.id, rect);
          }
        }
        return map;
      }
      return previousValue;
    }, [containers, queue, dragging, disabled, measure]);
    H.useEffect(() => {
      containersRef.current = containers;
    }, [containers]);
    H.useEffect(
      () => {
        if (disabled) {
          return;
        }
        measureDroppableContainers();
      },
      // eslint-disable-next-line react-hooks/exhaustive-deps
      [dragging, disabled]
    );
    H.useEffect(
      () => {
        if (queue && queue.length > 0) {
          setQueue(null);
        }
      },
      //eslint-disable-next-line react-hooks/exhaustive-deps
      [JSON.stringify(queue)]
    );
    H.useEffect(
      () => {
        if (disabled || typeof frequency !== "number" || timeoutId.current !== null) {
          return;
        }
        timeoutId.current = setTimeout(() => {
          measureDroppableContainers();
          timeoutId.current = null;
        }, frequency);
      },
      // eslint-disable-next-line react-hooks/exhaustive-deps
      [frequency, disabled, measureDroppableContainers, ...dependencies]
    );
    return {
      droppableRects,
      measureDroppableContainers,
      measuringScheduled: queue != null
    };
    function isDisabled() {
      switch (strategy) {
        case MeasuringStrategy.Always:
          return false;
        case MeasuringStrategy.BeforeDragging:
          return dragging;
        default:
          return !dragging;
      }
    }
  }
  function useInitialValue(value, computeFn) {
    return useLazyMemo((previousValue) => {
      if (!value) {
        return null;
      }
      if (previousValue) {
        return previousValue;
      }
      return typeof computeFn === "function" ? computeFn(value) : value;
    }, [computeFn, value]);
  }
  function useInitialRect(node2, measure) {
    return useInitialValue(node2, measure);
  }
  function useMutationObserver(_ref7) {
    let {
      callback,
      disabled
    } = _ref7;
    const handleMutations = useEvent(callback);
    const mutationObserver = H.useMemo(() => {
      if (disabled || typeof window === "undefined" || typeof window.MutationObserver === "undefined") {
        return void 0;
      }
      const {
        MutationObserver: MutationObserver2
      } = window;
      return new MutationObserver2(handleMutations);
    }, [handleMutations, disabled]);
    H.useEffect(() => {
      return () => mutationObserver == null ? void 0 : mutationObserver.disconnect();
    }, [mutationObserver]);
    return mutationObserver;
  }
  function useResizeObserver(_ref7) {
    let {
      callback,
      disabled
    } = _ref7;
    const handleResize = useEvent(callback);
    const resizeObserver = H.useMemo(
      () => {
        if (disabled || typeof window === "undefined" || typeof window.ResizeObserver === "undefined") {
          return void 0;
        }
        const {
          ResizeObserver: ResizeObserver2
        } = window;
        return new ResizeObserver2(handleResize);
      },
      // eslint-disable-next-line react-hooks/exhaustive-deps
      [disabled]
    );
    H.useEffect(() => {
      return () => resizeObserver == null ? void 0 : resizeObserver.disconnect();
    }, [resizeObserver]);
    return resizeObserver;
  }
  function defaultMeasure(element) {
    return new Rect(getClientRect(element), element);
  }
  function useRect(element, measure, fallbackRect) {
    if (measure === void 0) {
      measure = defaultMeasure;
    }
    const [rect, setRect] = H.useState(null);
    function measureRect() {
      setRect((currentRect) => {
        if (!element) {
          return null;
        }
        if (element.isConnected === false) {
          var _ref7;
          return (_ref7 = currentRect != null ? currentRect : fallbackRect) != null ? _ref7 : null;
        }
        const newRect = measure(element);
        if (JSON.stringify(currentRect) === JSON.stringify(newRect)) {
          return currentRect;
        }
        return newRect;
      });
    }
    const mutationObserver = useMutationObserver({
      callback(records) {
        if (!element) {
          return;
        }
        for (const record of records) {
          const {
            type,
            target
          } = record;
          if (type === "childList" && target instanceof HTMLElement && target.contains(element)) {
            measureRect();
            break;
          }
        }
      }
    });
    const resizeObserver = useResizeObserver({
      callback: measureRect
    });
    useIsomorphicLayoutEffect(() => {
      measureRect();
      if (element) {
        resizeObserver == null ? void 0 : resizeObserver.observe(element);
        mutationObserver == null ? void 0 : mutationObserver.observe(document.body, {
          childList: true,
          subtree: true
        });
      } else {
        resizeObserver == null ? void 0 : resizeObserver.disconnect();
        mutationObserver == null ? void 0 : mutationObserver.disconnect();
      }
    }, [element]);
    return rect;
  }
  function useRectDelta(rect) {
    const initialRect = useInitialValue(rect);
    return getRectDelta(rect, initialRect);
  }
  const defaultValue$1 = [];
  function useScrollableAncestors(node2) {
    const previousNode = H.useRef(node2);
    const ancestors = useLazyMemo((previousValue) => {
      if (!node2) {
        return defaultValue$1;
      }
      if (previousValue && previousValue !== defaultValue$1 && node2 && previousNode.current && node2.parentNode === previousNode.current.parentNode) {
        return previousValue;
      }
      return getScrollableAncestors(node2);
    }, [node2]);
    H.useEffect(() => {
      previousNode.current = node2;
    }, [node2]);
    return ancestors;
  }
  function useScrollOffsets(elements) {
    const [scrollCoordinates, setScrollCoordinates] = H.useState(null);
    const prevElements = H.useRef(elements);
    const handleScroll = H.useCallback((event) => {
      const scrollingElement = getScrollableElement(event.target);
      if (!scrollingElement) {
        return;
      }
      setScrollCoordinates((scrollCoordinates2) => {
        if (!scrollCoordinates2) {
          return null;
        }
        scrollCoordinates2.set(scrollingElement, getScrollCoordinates(scrollingElement));
        return new Map(scrollCoordinates2);
      });
    }, []);
    H.useEffect(() => {
      const previousElements = prevElements.current;
      if (elements !== previousElements) {
        cleanup(previousElements);
        const entries = elements.map((element) => {
          const scrollableElement = getScrollableElement(element);
          if (scrollableElement) {
            scrollableElement.addEventListener("scroll", handleScroll, {
              passive: true
            });
            return [scrollableElement, getScrollCoordinates(scrollableElement)];
          }
          return null;
        }).filter((entry) => entry != null);
        setScrollCoordinates(entries.length ? new Map(entries) : null);
        prevElements.current = elements;
      }
      return () => {
        cleanup(elements);
        cleanup(previousElements);
      };
      function cleanup(elements2) {
        elements2.forEach((element) => {
          const scrollableElement = getScrollableElement(element);
          scrollableElement == null ? void 0 : scrollableElement.removeEventListener("scroll", handleScroll);
        });
      }
    }, [handleScroll, elements]);
    return H.useMemo(() => {
      if (elements.length) {
        return scrollCoordinates ? Array.from(scrollCoordinates.values()).reduce((acc, coordinates) => add(acc, coordinates), defaultCoordinates) : getScrollOffsets(elements);
      }
      return defaultCoordinates;
    }, [elements, scrollCoordinates]);
  }
  function useScrollOffsetsDelta(scrollOffsets, dependencies) {
    if (dependencies === void 0) {
      dependencies = [];
    }
    const initialScrollOffsets = H.useRef(null);
    H.useEffect(
      () => {
        initialScrollOffsets.current = null;
      },
      // eslint-disable-next-line react-hooks/exhaustive-deps
      dependencies
    );
    H.useEffect(() => {
      const hasScrollOffsets = scrollOffsets !== defaultCoordinates;
      if (hasScrollOffsets && !initialScrollOffsets.current) {
        initialScrollOffsets.current = scrollOffsets;
      }
      if (!hasScrollOffsets && initialScrollOffsets.current) {
        initialScrollOffsets.current = null;
      }
    }, [scrollOffsets]);
    return initialScrollOffsets.current ? subtract(scrollOffsets, initialScrollOffsets.current) : defaultCoordinates;
  }
  function useSensorSetup(sensors) {
    H.useEffect(
      () => {
        if (!canUseDOM) {
          return;
        }
        const teardownFns = sensors.map((_ref7) => {
          let {
            sensor
          } = _ref7;
          return sensor.setup == null ? void 0 : sensor.setup();
        });
        return () => {
          for (const teardown of teardownFns) {
            teardown == null ? void 0 : teardown();
          }
        };
      },
      // TO-DO: Sensors length could theoretically change which would not be a valid dependency
      // eslint-disable-next-line react-hooks/exhaustive-deps
      sensors.map((_ref22) => {
        let {
          sensor
        } = _ref22;
        return sensor;
      })
    );
  }
  function useSyntheticListeners(listeners2, id) {
    return H.useMemo(() => {
      return listeners2.reduce((acc, _ref7) => {
        let {
          eventName,
          handler
        } = _ref7;
        acc[eventName] = (event) => {
          handler(event, id);
        };
        return acc;
      }, {});
    }, [listeners2, id]);
  }
  function useWindowRect(element) {
    return H.useMemo(() => element ? getWindowClientRect(element) : null, [element]);
  }
  const defaultValue$2 = [];
  function useRects(elements, measure) {
    if (measure === void 0) {
      measure = getClientRect;
    }
    const [firstElement] = elements;
    const windowRect = useWindowRect(firstElement ? getWindow(firstElement) : null);
    const [rects, setRects] = H.useState(defaultValue$2);
    function measureRects() {
      setRects(() => {
        if (!elements.length) {
          return defaultValue$2;
        }
        return elements.map((element) => isDocumentScrollingElement(element) ? windowRect : new Rect(measure(element), element));
      });
    }
    const resizeObserver = useResizeObserver({
      callback: measureRects
    });
    useIsomorphicLayoutEffect(() => {
      resizeObserver == null ? void 0 : resizeObserver.disconnect();
      measureRects();
      elements.forEach((element) => resizeObserver == null ? void 0 : resizeObserver.observe(element));
    }, [elements]);
    return rects;
  }
  function getMeasurableNode(node2) {
    if (!node2) {
      return null;
    }
    if (node2.children.length > 1) {
      return node2;
    }
    const firstChild = node2.children[0];
    return isHTMLElement(firstChild) ? firstChild : node2;
  }
  function useDragOverlayMeasuring(_ref7) {
    let {
      measure
    } = _ref7;
    const [rect, setRect] = H.useState(null);
    const handleResize = H.useCallback((entries) => {
      for (const {
        target
      } of entries) {
        if (isHTMLElement(target)) {
          setRect((rect2) => {
            const newRect = measure(target);
            return rect2 ? {
              ...rect2,
              width: newRect.width,
              height: newRect.height
            } : newRect;
          });
          break;
        }
      }
    }, [measure]);
    const resizeObserver = useResizeObserver({
      callback: handleResize
    });
    const handleNodeChange = H.useCallback((element) => {
      const node2 = getMeasurableNode(element);
      resizeObserver == null ? void 0 : resizeObserver.disconnect();
      if (node2) {
        resizeObserver == null ? void 0 : resizeObserver.observe(node2);
      }
      setRect(node2 ? measure(node2) : null);
    }, [measure, resizeObserver]);
    const [nodeRef, setRef] = useNodeRef(handleNodeChange);
    return H.useMemo(() => ({
      nodeRef,
      rect,
      setRef
    }), [rect, nodeRef, setRef]);
  }
  const defaultSensors = [{
    sensor: PointerSensor,
    options: {}
  }, {
    sensor: KeyboardSensor,
    options: {}
  }];
  const defaultData = {
    current: {}
  };
  const defaultMeasuringConfiguration = {
    draggable: {
      measure: getTransformAgnosticClientRect
    },
    droppable: {
      measure: getTransformAgnosticClientRect,
      strategy: MeasuringStrategy.WhileDragging,
      frequency: MeasuringFrequency.Optimized
    },
    dragOverlay: {
      measure: getClientRect
    }
  };
  class DroppableContainersMap extends Map {
    get(id) {
      var _super$get;
      return id != null ? (_super$get = super.get(id)) != null ? _super$get : void 0 : void 0;
    }
    toArray() {
      return Array.from(this.values());
    }
    getEnabled() {
      return this.toArray().filter((_ref7) => {
        let {
          disabled
        } = _ref7;
        return !disabled;
      });
    }
    getNodeFor(id) {
      var _this$get$node$curren, _this$get;
      return (_this$get$node$curren = (_this$get = this.get(id)) == null ? void 0 : _this$get.node.current) != null ? _this$get$node$curren : void 0;
    }
  }
  const defaultPublicContext = {
    activatorEvent: null,
    active: null,
    activeNode: null,
    activeNodeRect: null,
    collisions: null,
    containerNodeRect: null,
    draggableNodes: /* @__PURE__ */ new Map(),
    droppableRects: /* @__PURE__ */ new Map(),
    droppableContainers: /* @__PURE__ */ new DroppableContainersMap(),
    over: null,
    dragOverlay: {
      nodeRef: {
        current: null
      },
      rect: null,
      setRef: noop
    },
    scrollableAncestors: [],
    scrollableAncestorRects: [],
    measuringConfiguration: defaultMeasuringConfiguration,
    measureDroppableContainers: noop,
    windowRect: null,
    measuringScheduled: false
  };
  const defaultInternalContext = {
    activatorEvent: null,
    activators: [],
    active: null,
    activeNodeRect: null,
    ariaDescribedById: {
      draggable: ""
    },
    dispatch: noop,
    draggableNodes: /* @__PURE__ */ new Map(),
    over: null,
    measureDroppableContainers: noop
  };
  const InternalContext = /* @__PURE__ */ H.createContext(defaultInternalContext);
  const PublicContext = /* @__PURE__ */ H.createContext(defaultPublicContext);
  function getInitialState() {
    return {
      draggable: {
        active: null,
        initialCoordinates: {
          x: 0,
          y: 0
        },
        nodes: /* @__PURE__ */ new Map(),
        translate: {
          x: 0,
          y: 0
        }
      },
      droppable: {
        containers: new DroppableContainersMap()
      }
    };
  }
  function reducer(state2, action2) {
    switch (action2.type) {
      case Action.DragStart:
        return {
          ...state2,
          draggable: {
            ...state2.draggable,
            initialCoordinates: action2.initialCoordinates,
            active: action2.active
          }
        };
      case Action.DragMove:
        if (state2.draggable.active == null) {
          return state2;
        }
        return {
          ...state2,
          draggable: {
            ...state2.draggable,
            translate: {
              x: action2.coordinates.x - state2.draggable.initialCoordinates.x,
              y: action2.coordinates.y - state2.draggable.initialCoordinates.y
            }
          }
        };
      case Action.DragEnd:
      case Action.DragCancel:
        return {
          ...state2,
          draggable: {
            ...state2.draggable,
            active: null,
            initialCoordinates: {
              x: 0,
              y: 0
            },
            translate: {
              x: 0,
              y: 0
            }
          }
        };
      case Action.RegisterDroppable: {
        const {
          element
        } = action2;
        const {
          id
        } = element;
        const containers = new DroppableContainersMap(state2.droppable.containers);
        containers.set(id, element);
        return {
          ...state2,
          droppable: {
            ...state2.droppable,
            containers
          }
        };
      }
      case Action.SetDroppableDisabled: {
        const {
          id,
          key,
          disabled
        } = action2;
        const element = state2.droppable.containers.get(id);
        if (!element || key !== element.key) {
          return state2;
        }
        const containers = new DroppableContainersMap(state2.droppable.containers);
        containers.set(id, {
          ...element,
          disabled
        });
        return {
          ...state2,
          droppable: {
            ...state2.droppable,
            containers
          }
        };
      }
      case Action.UnregisterDroppable: {
        const {
          id,
          key
        } = action2;
        const element = state2.droppable.containers.get(id);
        if (!element || key !== element.key) {
          return state2;
        }
        const containers = new DroppableContainersMap(state2.droppable.containers);
        containers.delete(id);
        return {
          ...state2,
          droppable: {
            ...state2.droppable,
            containers
          }
        };
      }
      default: {
        return state2;
      }
    }
  }
  function RestoreFocus(_ref7) {
    let {
      disabled
    } = _ref7;
    const {
      active,
      activatorEvent,
      draggableNodes
    } = H.useContext(InternalContext);
    const previousActivatorEvent = usePrevious(activatorEvent);
    const previousActiveId = usePrevious(active == null ? void 0 : active.id);
    H.useEffect(() => {
      if (disabled) {
        return;
      }
      if (!activatorEvent && previousActivatorEvent && previousActiveId != null) {
        if (!isKeyboardEvent(previousActivatorEvent)) {
          return;
        }
        if (document.activeElement === previousActivatorEvent.target) {
          return;
        }
        const draggableNode = draggableNodes.get(previousActiveId);
        if (!draggableNode) {
          return;
        }
        const {
          activatorNode,
          node: node2
        } = draggableNode;
        if (!activatorNode.current && !node2.current) {
          return;
        }
        requestAnimationFrame(() => {
          for (const element of [activatorNode.current, node2.current]) {
            if (!element) {
              continue;
            }
            const focusableNode = findFirstFocusableNode(element);
            if (focusableNode) {
              focusableNode.focus();
              break;
            }
          }
        });
      }
    }, [activatorEvent, disabled, draggableNodes, previousActiveId, previousActivatorEvent]);
    return null;
  }
  function applyModifiers(modifiers, _ref7) {
    let {
      transform,
      ...args
    } = _ref7;
    return modifiers != null && modifiers.length ? modifiers.reduce((accumulator, modifier) => {
      return modifier({
        transform: accumulator,
        ...args
      });
    }, transform) : transform;
  }
  function useMeasuringConfiguration(config) {
    return H.useMemo(
      () => ({
        draggable: {
          ...defaultMeasuringConfiguration.draggable,
          ...config == null ? void 0 : config.draggable
        },
        droppable: {
          ...defaultMeasuringConfiguration.droppable,
          ...config == null ? void 0 : config.droppable
        },
        dragOverlay: {
          ...defaultMeasuringConfiguration.dragOverlay,
          ...config == null ? void 0 : config.dragOverlay
        }
      }),
      // eslint-disable-next-line react-hooks/exhaustive-deps
      [config == null ? void 0 : config.draggable, config == null ? void 0 : config.droppable, config == null ? void 0 : config.dragOverlay]
    );
  }
  function useLayoutShiftScrollCompensation(_ref7) {
    let {
      activeNode,
      measure,
      initialRect,
      config = true
    } = _ref7;
    const initialized = H.useRef(false);
    const {
      x,
      y
    } = typeof config === "boolean" ? {
      x: config,
      y: config
    } : config;
    useIsomorphicLayoutEffect(() => {
      const disabled = !x && !y;
      if (disabled || !activeNode) {
        initialized.current = false;
        return;
      }
      if (initialized.current || !initialRect) {
        return;
      }
      const node2 = activeNode == null ? void 0 : activeNode.node.current;
      if (!node2 || node2.isConnected === false) {
        return;
      }
      const rect = measure(node2);
      const rectDelta = getRectDelta(rect, initialRect);
      if (!x) {
        rectDelta.x = 0;
      }
      if (!y) {
        rectDelta.y = 0;
      }
      initialized.current = true;
      if (Math.abs(rectDelta.x) > 0 || Math.abs(rectDelta.y) > 0) {
        const firstScrollableAncestor = getFirstScrollableAncestor(node2);
        if (firstScrollableAncestor) {
          firstScrollableAncestor.scrollBy({
            top: rectDelta.y,
            left: rectDelta.x
          });
        }
      }
    }, [activeNode, x, y, initialRect, measure]);
  }
  const ActiveDraggableContext = /* @__PURE__ */ H.createContext({
    ...defaultCoordinates,
    scaleX: 1,
    scaleY: 1
  });
  var Status;
  (function(Status2) {
    Status2[Status2["Uninitialized"] = 0] = "Uninitialized";
    Status2[Status2["Initializing"] = 1] = "Initializing";
    Status2[Status2["Initialized"] = 2] = "Initialized";
  })(Status || (Status = {}));
  const DndContext = /* @__PURE__ */ H.memo(function DndContext2(_ref7) {
    var _sensorContext$curren, _dragOverlay$nodeRef$, _dragOverlay$rect, _over$rect;
    let {
      id,
      accessibility,
      autoScroll = true,
      children,
      sensors = defaultSensors,
      collisionDetection = rectIntersection,
      measuring,
      modifiers,
      ...props
    } = _ref7;
    const store2 = H.useReducer(reducer, void 0, getInitialState);
    const [state2, dispatch] = store2;
    const [dispatchMonitorEvent, registerMonitorListener] = useDndMonitorProvider();
    const [status, setStatus] = H.useState(Status.Uninitialized);
    const isInitialized = status === Status.Initialized;
    const {
      draggable: {
        active: activeId,
        nodes: draggableNodes,
        translate
      },
      droppable: {
        containers: droppableContainers
      }
    } = state2;
    const node2 = activeId != null ? draggableNodes.get(activeId) : null;
    const activeRects = H.useRef({
      initial: null,
      translated: null
    });
    const active = H.useMemo(() => {
      var _node$data;
      return activeId != null ? {
        id: activeId,
        // It's possible for the active node to unmount while dragging
        data: (_node$data = node2 == null ? void 0 : node2.data) != null ? _node$data : defaultData,
        rect: activeRects
      } : null;
    }, [activeId, node2]);
    const activeRef = H.useRef(null);
    const [activeSensor, setActiveSensor] = H.useState(null);
    const [activatorEvent, setActivatorEvent] = H.useState(null);
    const latestProps = useLatestValue(props, Object.values(props));
    const draggableDescribedById = useUniqueId("DndDescribedBy", id);
    const enabledDroppableContainers = H.useMemo(() => droppableContainers.getEnabled(), [droppableContainers]);
    const measuringConfiguration = useMeasuringConfiguration(measuring);
    const {
      droppableRects,
      measureDroppableContainers,
      measuringScheduled
    } = useDroppableMeasuring(enabledDroppableContainers, {
      dragging: isInitialized,
      dependencies: [translate.x, translate.y],
      config: measuringConfiguration.droppable
    });
    const activeNode = useCachedNode(draggableNodes, activeId);
    const activationCoordinates = H.useMemo(() => activatorEvent ? getEventCoordinates(activatorEvent) : null, [activatorEvent]);
    const autoScrollOptions = getAutoScrollerOptions();
    const initialActiveNodeRect = useInitialRect(activeNode, measuringConfiguration.draggable.measure);
    useLayoutShiftScrollCompensation({
      activeNode: activeId != null ? draggableNodes.get(activeId) : null,
      config: autoScrollOptions.layoutShiftCompensation,
      initialRect: initialActiveNodeRect,
      measure: measuringConfiguration.draggable.measure
    });
    const activeNodeRect = useRect(activeNode, measuringConfiguration.draggable.measure, initialActiveNodeRect);
    const containerNodeRect = useRect(activeNode ? activeNode.parentElement : null);
    const sensorContext = H.useRef({
      activatorEvent: null,
      active: null,
      activeNode,
      collisionRect: null,
      collisions: null,
      droppableRects,
      draggableNodes,
      draggingNode: null,
      draggingNodeRect: null,
      droppableContainers,
      over: null,
      scrollableAncestors: [],
      scrollAdjustedTranslate: null
    });
    const overNode = droppableContainers.getNodeFor((_sensorContext$curren = sensorContext.current.over) == null ? void 0 : _sensorContext$curren.id);
    const dragOverlay = useDragOverlayMeasuring({
      measure: measuringConfiguration.dragOverlay.measure
    });
    const draggingNode = (_dragOverlay$nodeRef$ = dragOverlay.nodeRef.current) != null ? _dragOverlay$nodeRef$ : activeNode;
    const draggingNodeRect = isInitialized ? (_dragOverlay$rect = dragOverlay.rect) != null ? _dragOverlay$rect : activeNodeRect : null;
    const usesDragOverlay = Boolean(dragOverlay.nodeRef.current && dragOverlay.rect);
    const nodeRectDelta = useRectDelta(usesDragOverlay ? null : activeNodeRect);
    const windowRect = useWindowRect(draggingNode ? getWindow(draggingNode) : null);
    const scrollableAncestors = useScrollableAncestors(isInitialized ? overNode != null ? overNode : activeNode : null);
    const scrollableAncestorRects = useRects(scrollableAncestors);
    const modifiedTranslate = applyModifiers(modifiers, {
      transform: {
        x: translate.x - nodeRectDelta.x,
        y: translate.y - nodeRectDelta.y,
        scaleX: 1,
        scaleY: 1
      },
      activatorEvent,
      active,
      activeNodeRect,
      containerNodeRect,
      draggingNodeRect,
      over: sensorContext.current.over,
      overlayNodeRect: dragOverlay.rect,
      scrollableAncestors,
      scrollableAncestorRects,
      windowRect
    });
    const pointerCoordinates = activationCoordinates ? add(activationCoordinates, translate) : null;
    const scrollOffsets = useScrollOffsets(scrollableAncestors);
    const scrollAdjustment = useScrollOffsetsDelta(scrollOffsets);
    const activeNodeScrollDelta = useScrollOffsetsDelta(scrollOffsets, [activeNodeRect]);
    const scrollAdjustedTranslate = add(modifiedTranslate, scrollAdjustment);
    const collisionRect = draggingNodeRect ? getAdjustedRect(draggingNodeRect, modifiedTranslate) : null;
    const collisions = active && collisionRect ? collisionDetection({
      active,
      collisionRect,
      droppableRects,
      droppableContainers: enabledDroppableContainers,
      pointerCoordinates
    }) : null;
    const overId = getFirstCollision(collisions, "id");
    const [over, setOver] = H.useState(null);
    const appliedTranslate = usesDragOverlay ? modifiedTranslate : add(modifiedTranslate, activeNodeScrollDelta);
    const transform = adjustScale(appliedTranslate, (_over$rect = over == null ? void 0 : over.rect) != null ? _over$rect : null, activeNodeRect);
    const activeSensorRef = H.useRef(null);
    const instantiateSensor = H.useCallback(
      (event, _ref22) => {
        let {
          sensor: Sensor,
          options
        } = _ref22;
        if (activeRef.current == null) {
          return;
        }
        const activeNode2 = draggableNodes.get(activeRef.current);
        if (!activeNode2) {
          return;
        }
        const activatorEvent2 = event.nativeEvent;
        const sensorInstance = new Sensor({
          active: activeRef.current,
          activeNode: activeNode2,
          event: activatorEvent2,
          options,
          // Sensors need to be instantiated with refs for arguments that change over time
          // otherwise they are frozen in time with the stale arguments
          context: sensorContext,
          onAbort(id2) {
            const draggableNode = draggableNodes.get(id2);
            if (!draggableNode) {
              return;
            }
            const {
              onDragAbort
            } = latestProps.current;
            const event2 = {
              id: id2
            };
            onDragAbort == null ? void 0 : onDragAbort(event2);
            dispatchMonitorEvent({
              type: "onDragAbort",
              event: event2
            });
          },
          onPending(id2, constraint, initialCoordinates, offset) {
            const draggableNode = draggableNodes.get(id2);
            if (!draggableNode) {
              return;
            }
            const {
              onDragPending
            } = latestProps.current;
            const event2 = {
              id: id2,
              constraint,
              initialCoordinates,
              offset
            };
            onDragPending == null ? void 0 : onDragPending(event2);
            dispatchMonitorEvent({
              type: "onDragPending",
              event: event2
            });
          },
          onStart(initialCoordinates) {
            const id2 = activeRef.current;
            if (id2 == null) {
              return;
            }
            const draggableNode = draggableNodes.get(id2);
            if (!draggableNode) {
              return;
            }
            const {
              onDragStart
            } = latestProps.current;
            const event2 = {
              activatorEvent: activatorEvent2,
              active: {
                id: id2,
                data: draggableNode.data,
                rect: activeRects
              }
            };
            require$$0.unstable_batchedUpdates(() => {
              onDragStart == null ? void 0 : onDragStart(event2);
              setStatus(Status.Initializing);
              dispatch({
                type: Action.DragStart,
                initialCoordinates,
                active: id2
              });
              dispatchMonitorEvent({
                type: "onDragStart",
                event: event2
              });
              setActiveSensor(activeSensorRef.current);
              setActivatorEvent(activatorEvent2);
            });
          },
          onMove(coordinates) {
            dispatch({
              type: Action.DragMove,
              coordinates
            });
          },
          onEnd: createHandler2(Action.DragEnd),
          onCancel: createHandler2(Action.DragCancel)
        });
        activeSensorRef.current = sensorInstance;
        function createHandler2(type) {
          return async function handler() {
            const {
              active: active2,
              collisions: collisions2,
              over: over2,
              scrollAdjustedTranslate: scrollAdjustedTranslate2
            } = sensorContext.current;
            let event2 = null;
            if (active2 && scrollAdjustedTranslate2) {
              const {
                cancelDrop
              } = latestProps.current;
              event2 = {
                activatorEvent: activatorEvent2,
                active: active2,
                collisions: collisions2,
                delta: scrollAdjustedTranslate2,
                over: over2
              };
              if (type === Action.DragEnd && typeof cancelDrop === "function") {
                const shouldCancel = await Promise.resolve(cancelDrop(event2));
                if (shouldCancel) {
                  type = Action.DragCancel;
                }
              }
            }
            activeRef.current = null;
            require$$0.unstable_batchedUpdates(() => {
              dispatch({
                type
              });
              setStatus(Status.Uninitialized);
              setOver(null);
              setActiveSensor(null);
              setActivatorEvent(null);
              activeSensorRef.current = null;
              const eventName = type === Action.DragEnd ? "onDragEnd" : "onDragCancel";
              if (event2) {
                const handler2 = latestProps.current[eventName];
                handler2 == null ? void 0 : handler2(event2);
                dispatchMonitorEvent({
                  type: eventName,
                  event: event2
                });
              }
            });
          };
        }
      },
      // eslint-disable-next-line react-hooks/exhaustive-deps
      [draggableNodes]
    );
    const bindActivatorToSensorInstantiator = H.useCallback((handler, sensor) => {
      return (event, active2) => {
        const nativeEvent = event.nativeEvent;
        const activeDraggableNode = draggableNodes.get(active2);
        if (
          // Another sensor is already instantiating
          activeRef.current !== null || // No active draggable
          !activeDraggableNode || // Event has already been captured
          nativeEvent.dndKit || nativeEvent.defaultPrevented
        ) {
          return;
        }
        const activationContext = {
          active: activeDraggableNode
        };
        const shouldActivate = handler(event, sensor.options, activationContext);
        if (shouldActivate === true) {
          nativeEvent.dndKit = {
            capturedBy: sensor.sensor
          };
          activeRef.current = active2;
          instantiateSensor(event, sensor);
        }
      };
    }, [draggableNodes, instantiateSensor]);
    const activators = useCombineActivators(sensors, bindActivatorToSensorInstantiator);
    useSensorSetup(sensors);
    useIsomorphicLayoutEffect(() => {
      if (activeNodeRect && status === Status.Initializing) {
        setStatus(Status.Initialized);
      }
    }, [activeNodeRect, status]);
    H.useEffect(
      () => {
        const {
          onDragMove
        } = latestProps.current;
        const {
          active: active2,
          activatorEvent: activatorEvent2,
          collisions: collisions2,
          over: over2
        } = sensorContext.current;
        if (!active2 || !activatorEvent2) {
          return;
        }
        const event = {
          active: active2,
          activatorEvent: activatorEvent2,
          collisions: collisions2,
          delta: {
            x: scrollAdjustedTranslate.x,
            y: scrollAdjustedTranslate.y
          },
          over: over2
        };
        require$$0.unstable_batchedUpdates(() => {
          onDragMove == null ? void 0 : onDragMove(event);
          dispatchMonitorEvent({
            type: "onDragMove",
            event
          });
        });
      },
      // eslint-disable-next-line react-hooks/exhaustive-deps
      [scrollAdjustedTranslate.x, scrollAdjustedTranslate.y]
    );
    H.useEffect(
      () => {
        const {
          active: active2,
          activatorEvent: activatorEvent2,
          collisions: collisions2,
          droppableContainers: droppableContainers2,
          scrollAdjustedTranslate: scrollAdjustedTranslate2
        } = sensorContext.current;
        if (!active2 || activeRef.current == null || !activatorEvent2 || !scrollAdjustedTranslate2) {
          return;
        }
        const {
          onDragOver
        } = latestProps.current;
        const overContainer = droppableContainers2.get(overId);
        const over2 = overContainer && overContainer.rect.current ? {
          id: overContainer.id,
          rect: overContainer.rect.current,
          data: overContainer.data,
          disabled: overContainer.disabled
        } : null;
        const event = {
          active: active2,
          activatorEvent: activatorEvent2,
          collisions: collisions2,
          delta: {
            x: scrollAdjustedTranslate2.x,
            y: scrollAdjustedTranslate2.y
          },
          over: over2
        };
        require$$0.unstable_batchedUpdates(() => {
          setOver(over2);
          onDragOver == null ? void 0 : onDragOver(event);
          dispatchMonitorEvent({
            type: "onDragOver",
            event
          });
        });
      },
      // eslint-disable-next-line react-hooks/exhaustive-deps
      [overId]
    );
    useIsomorphicLayoutEffect(() => {
      sensorContext.current = {
        activatorEvent,
        active,
        activeNode,
        collisionRect,
        collisions,
        droppableRects,
        draggableNodes,
        draggingNode,
        draggingNodeRect,
        droppableContainers,
        over,
        scrollableAncestors,
        scrollAdjustedTranslate
      };
      activeRects.current = {
        initial: draggingNodeRect,
        translated: collisionRect
      };
    }, [active, activeNode, collisions, collisionRect, draggableNodes, draggingNode, draggingNodeRect, droppableRects, droppableContainers, over, scrollableAncestors, scrollAdjustedTranslate]);
    useAutoScroller({
      ...autoScrollOptions,
      delta: translate,
      draggingRect: collisionRect,
      pointerCoordinates,
      scrollableAncestors,
      scrollableAncestorRects
    });
    const publicContext = H.useMemo(() => {
      const context = {
        active,
        activeNode,
        activeNodeRect,
        activatorEvent,
        collisions,
        containerNodeRect,
        dragOverlay,
        draggableNodes,
        droppableContainers,
        droppableRects,
        over,
        measureDroppableContainers,
        scrollableAncestors,
        scrollableAncestorRects,
        measuringConfiguration,
        measuringScheduled,
        windowRect
      };
      return context;
    }, [active, activeNode, activeNodeRect, activatorEvent, collisions, containerNodeRect, dragOverlay, draggableNodes, droppableContainers, droppableRects, over, measureDroppableContainers, scrollableAncestors, scrollableAncestorRects, measuringConfiguration, measuringScheduled, windowRect]);
    const internalContext = H.useMemo(() => {
      const context = {
        activatorEvent,
        activators,
        active,
        activeNodeRect,
        ariaDescribedById: {
          draggable: draggableDescribedById
        },
        dispatch,
        draggableNodes,
        over,
        measureDroppableContainers
      };
      return context;
    }, [activatorEvent, activators, active, activeNodeRect, dispatch, draggableDescribedById, draggableNodes, over, measureDroppableContainers]);
    return H.createElement(DndMonitorContext.Provider, {
      value: registerMonitorListener
    }, H.createElement(InternalContext.Provider, {
      value: internalContext
    }, H.createElement(PublicContext.Provider, {
      value: publicContext
    }, H.createElement(ActiveDraggableContext.Provider, {
      value: transform
    }, children)), H.createElement(RestoreFocus, {
      disabled: (accessibility == null ? void 0 : accessibility.restoreFocus) === false
    })), H.createElement(Accessibility, {
      ...accessibility,
      hiddenTextDescribedById: draggableDescribedById
    }));
    function getAutoScrollerOptions() {
      const activeSensorDisablesAutoscroll = (activeSensor == null ? void 0 : activeSensor.autoScrollEnabled) === false;
      const autoScrollGloballyDisabled = typeof autoScroll === "object" ? autoScroll.enabled === false : autoScroll === false;
      const enabled = isInitialized && !activeSensorDisablesAutoscroll && !autoScrollGloballyDisabled;
      if (typeof autoScroll === "object") {
        return {
          ...autoScroll,
          enabled
        };
      }
      return {
        enabled
      };
    }
  });
  const NullContext = /* @__PURE__ */ H.createContext(null);
  const defaultRole = "button";
  const ID_PREFIX$1 = "Draggable";
  function useDraggable(_ref7) {
    let {
      id,
      data: data2,
      disabled = false,
      attributes
    } = _ref7;
    const key = useUniqueId(ID_PREFIX$1);
    const {
      activators,
      activatorEvent,
      active,
      activeNodeRect,
      ariaDescribedById,
      draggableNodes,
      over
    } = H.useContext(InternalContext);
    const {
      role = defaultRole,
      roleDescription = "draggable",
      tabIndex = 0
    } = attributes != null ? attributes : {};
    const isDragging = (active == null ? void 0 : active.id) === id;
    const transform = H.useContext(isDragging ? ActiveDraggableContext : NullContext);
    const [node2, setNodeRef] = useNodeRef();
    const [activatorNode, setActivatorNodeRef] = useNodeRef();
    const listeners2 = useSyntheticListeners(activators, id);
    const dataRef = useLatestValue(data2);
    useIsomorphicLayoutEffect(
      () => {
        draggableNodes.set(id, {
          id,
          key,
          node: node2,
          activatorNode,
          data: dataRef
        });
        return () => {
          const node3 = draggableNodes.get(id);
          if (node3 && node3.key === key) {
            draggableNodes.delete(id);
          }
        };
      },
      // eslint-disable-next-line react-hooks/exhaustive-deps
      [draggableNodes, id]
    );
    const memoizedAttributes = H.useMemo(() => ({
      role,
      tabIndex,
      "aria-disabled": disabled,
      "aria-pressed": isDragging && role === defaultRole ? true : void 0,
      "aria-roledescription": roleDescription,
      "aria-describedby": ariaDescribedById.draggable
    }), [disabled, role, tabIndex, isDragging, roleDescription, ariaDescribedById.draggable]);
    return {
      active,
      activatorEvent,
      activeNodeRect,
      attributes: memoizedAttributes,
      isDragging,
      listeners: disabled ? void 0 : listeners2,
      node: node2,
      over,
      setNodeRef,
      setActivatorNodeRef,
      transform
    };
  }
  function useDndContext() {
    return H.useContext(PublicContext);
  }
  const ID_PREFIX$1$1 = "Droppable";
  const defaultResizeObserverConfig = {
    timeout: 25
  };
  function useDroppable(_ref7) {
    let {
      data: data2,
      disabled = false,
      id,
      resizeObserverConfig
    } = _ref7;
    const key = useUniqueId(ID_PREFIX$1$1);
    const {
      active,
      dispatch,
      over,
      measureDroppableContainers
    } = H.useContext(InternalContext);
    const previous = H.useRef({
      disabled
    });
    const resizeObserverConnected = H.useRef(false);
    const rect = H.useRef(null);
    const callbackId = H.useRef(null);
    const {
      disabled: resizeObserverDisabled,
      updateMeasurementsFor,
      timeout: resizeObserverTimeout
    } = {
      ...defaultResizeObserverConfig,
      ...resizeObserverConfig
    };
    const ids2 = useLatestValue(updateMeasurementsFor != null ? updateMeasurementsFor : id);
    const handleResize = H.useCallback(
      () => {
        if (!resizeObserverConnected.current) {
          resizeObserverConnected.current = true;
          return;
        }
        if (callbackId.current != null) {
          clearTimeout(callbackId.current);
        }
        callbackId.current = setTimeout(() => {
          measureDroppableContainers(Array.isArray(ids2.current) ? ids2.current : [ids2.current]);
          callbackId.current = null;
        }, resizeObserverTimeout);
      },
      //eslint-disable-next-line react-hooks/exhaustive-deps
      [resizeObserverTimeout]
    );
    const resizeObserver = useResizeObserver({
      callback: handleResize,
      disabled: resizeObserverDisabled || !active
    });
    const handleNodeChange = H.useCallback((newElement, previousElement) => {
      if (!resizeObserver) {
        return;
      }
      if (previousElement) {
        resizeObserver.unobserve(previousElement);
        resizeObserverConnected.current = false;
      }
      if (newElement) {
        resizeObserver.observe(newElement);
      }
    }, [resizeObserver]);
    const [nodeRef, setNodeRef] = useNodeRef(handleNodeChange);
    const dataRef = useLatestValue(data2);
    H.useEffect(() => {
      if (!resizeObserver || !nodeRef.current) {
        return;
      }
      resizeObserver.disconnect();
      resizeObserverConnected.current = false;
      resizeObserver.observe(nodeRef.current);
    }, [nodeRef, resizeObserver]);
    H.useEffect(
      () => {
        dispatch({
          type: Action.RegisterDroppable,
          element: {
            id,
            key,
            disabled,
            node: nodeRef,
            rect,
            data: dataRef
          }
        });
        return () => dispatch({
          type: Action.UnregisterDroppable,
          key,
          id
        });
      },
      // eslint-disable-next-line react-hooks/exhaustive-deps
      [id]
    );
    H.useEffect(() => {
      if (disabled !== previous.current.disabled) {
        dispatch({
          type: Action.SetDroppableDisabled,
          id,
          key,
          disabled
        });
        previous.current.disabled = disabled;
      }
    }, [id, key, disabled, dispatch]);
    return {
      active,
      rect,
      isOver: (over == null ? void 0 : over.id) === id,
      node: nodeRef,
      over,
      setNodeRef
    };
  }
  function restrictToBoundingRect(transform, rect, boundingRect) {
    const value = {
      ...transform
    };
    if (rect.top + transform.y <= boundingRect.top) {
      value.y = boundingRect.top - rect.top;
    } else if (rect.bottom + transform.y >= boundingRect.top + boundingRect.height) {
      value.y = boundingRect.top + boundingRect.height - rect.bottom;
    }
    if (rect.left + transform.x <= boundingRect.left) {
      value.x = boundingRect.left - rect.left;
    } else if (rect.right + transform.x >= boundingRect.left + boundingRect.width) {
      value.x = boundingRect.left + boundingRect.width - rect.right;
    }
    return value;
  }
  const restrictToParentElement = (_ref7) => {
    let {
      containerNodeRect,
      draggingNodeRect,
      transform
    } = _ref7;
    if (!draggingNodeRect || !containerNodeRect) {
      return transform;
    }
    return restrictToBoundingRect(transform, draggingNodeRect, containerNodeRect);
  };
  const restrictToVerticalAxis = (_ref7) => {
    let {
      transform
    } = _ref7;
    return {
      ...transform,
      x: 0
    };
  };
  function arrayMove(array, from2, to) {
    const newArray = array.slice();
    newArray.splice(to < 0 ? newArray.length + to : to, 0, newArray.splice(from2, 1)[0]);
    return newArray;
  }
  function getSortedRects(items, rects) {
    return items.reduce((accumulator, id, index) => {
      const rect = rects.get(id);
      if (rect) {
        accumulator[index] = rect;
      }
      return accumulator;
    }, Array(items.length));
  }
  function isValidIndex(index) {
    return index !== null && index >= 0;
  }
  function itemsEqual(a2, b) {
    if (a2 === b) {
      return true;
    }
    if (a2.length !== b.length) {
      return false;
    }
    for (let i2 = 0; i2 < a2.length; i2++) {
      if (a2[i2] !== b[i2]) {
        return false;
      }
    }
    return true;
  }
  function normalizeDisabled(disabled) {
    if (typeof disabled === "boolean") {
      return {
        draggable: disabled,
        droppable: disabled
      };
    }
    return disabled;
  }
  const rectSortingStrategy = (_ref7) => {
    let {
      rects,
      activeIndex,
      overIndex,
      index
    } = _ref7;
    const newRects = arrayMove(rects, overIndex, activeIndex);
    const oldRect = rects[index];
    const newRect = newRects[index];
    if (!newRect || !oldRect) {
      return null;
    }
    return {
      x: newRect.left - oldRect.left,
      y: newRect.top - oldRect.top,
      scaleX: newRect.width / oldRect.width,
      scaleY: newRect.height / oldRect.height
    };
  };
  const defaultScale$1 = {
    scaleX: 1,
    scaleY: 1
  };
  const verticalListSortingStrategy = (_ref7) => {
    var _rects$activeIndex;
    let {
      activeIndex,
      activeNodeRect: fallbackActiveRect,
      index,
      rects,
      overIndex
    } = _ref7;
    const activeNodeRect = (_rects$activeIndex = rects[activeIndex]) != null ? _rects$activeIndex : fallbackActiveRect;
    if (!activeNodeRect) {
      return null;
    }
    if (index === activeIndex) {
      const overIndexRect = rects[overIndex];
      if (!overIndexRect) {
        return null;
      }
      return {
        x: 0,
        y: activeIndex < overIndex ? overIndexRect.top + overIndexRect.height - (activeNodeRect.top + activeNodeRect.height) : overIndexRect.top - activeNodeRect.top,
        ...defaultScale$1
      };
    }
    const itemGap = getItemGap$1(rects, index, activeIndex);
    if (index > activeIndex && index <= overIndex) {
      return {
        x: 0,
        y: -activeNodeRect.height - itemGap,
        ...defaultScale$1
      };
    }
    if (index < activeIndex && index >= overIndex) {
      return {
        x: 0,
        y: activeNodeRect.height + itemGap,
        ...defaultScale$1
      };
    }
    return {
      x: 0,
      y: 0,
      ...defaultScale$1
    };
  };
  function getItemGap$1(clientRects, index, activeIndex) {
    const currentRect = clientRects[index];
    const previousRect = clientRects[index - 1];
    const nextRect = clientRects[index + 1];
    if (!currentRect) {
      return 0;
    }
    if (activeIndex < index) {
      return previousRect ? currentRect.top - (previousRect.top + previousRect.height) : nextRect ? nextRect.top - (currentRect.top + currentRect.height) : 0;
    }
    return nextRect ? nextRect.top - (currentRect.top + currentRect.height) : previousRect ? currentRect.top - (previousRect.top + previousRect.height) : 0;
  }
  const ID_PREFIX = "Sortable";
  const Context = /* @__PURE__ */ H.createContext({
    activeIndex: -1,
    containerId: ID_PREFIX,
    disableTransforms: false,
    items: [],
    overIndex: -1,
    useDragOverlay: false,
    sortedRects: [],
    strategy: rectSortingStrategy,
    disabled: {
      draggable: false,
      droppable: false
    }
  });
  function SortableContext(_ref7) {
    let {
      children,
      id,
      items: userDefinedItems,
      strategy = rectSortingStrategy,
      disabled: disabledProp = false
    } = _ref7;
    const {
      active,
      dragOverlay,
      droppableRects,
      over,
      measureDroppableContainers
    } = useDndContext();
    const containerId = useUniqueId(ID_PREFIX, id);
    const useDragOverlay = Boolean(dragOverlay.rect !== null);
    const items = H.useMemo(() => userDefinedItems.map((item) => typeof item === "object" && "id" in item ? item.id : item), [userDefinedItems]);
    const isDragging = active != null;
    const activeIndex = active ? items.indexOf(active.id) : -1;
    const overIndex = over ? items.indexOf(over.id) : -1;
    const previousItemsRef = H.useRef(items);
    const itemsHaveChanged = !itemsEqual(items, previousItemsRef.current);
    const disableTransforms = overIndex !== -1 && activeIndex === -1 || itemsHaveChanged;
    const disabled = normalizeDisabled(disabledProp);
    useIsomorphicLayoutEffect(() => {
      if (itemsHaveChanged && isDragging) {
        measureDroppableContainers(items);
      }
    }, [itemsHaveChanged, items, isDragging, measureDroppableContainers]);
    H.useEffect(() => {
      previousItemsRef.current = items;
    }, [items]);
    const contextValue = H.useMemo(
      () => ({
        activeIndex,
        containerId,
        disabled,
        disableTransforms,
        items,
        overIndex,
        useDragOverlay,
        sortedRects: getSortedRects(items, droppableRects),
        strategy
      }),
      // eslint-disable-next-line react-hooks/exhaustive-deps
      [activeIndex, containerId, disabled.draggable, disabled.droppable, disableTransforms, items, overIndex, droppableRects, useDragOverlay, strategy]
    );
    return H.createElement(Context.Provider, {
      value: contextValue
    }, children);
  }
  const defaultNewIndexGetter = (_ref7) => {
    let {
      id,
      items,
      activeIndex,
      overIndex
    } = _ref7;
    return arrayMove(items, activeIndex, overIndex).indexOf(id);
  };
  const defaultAnimateLayoutChanges = (_ref22) => {
    let {
      containerId,
      isSorting,
      wasDragging,
      index,
      items,
      newIndex,
      previousItems,
      previousContainerId,
      transition
    } = _ref22;
    if (!transition || !wasDragging) {
      return false;
    }
    if (previousItems !== items && index === newIndex) {
      return false;
    }
    if (isSorting) {
      return true;
    }
    return newIndex !== index && containerId === previousContainerId;
  };
  const defaultTransition = {
    duration: 200,
    easing: "ease"
  };
  const transitionProperty = "transform";
  const disabledTransition = /* @__PURE__ */ CSS.Transition.toString({
    property: transitionProperty,
    duration: 0,
    easing: "linear"
  });
  const defaultAttributes = {
    roleDescription: "sortable"
  };
  function useDerivedTransform(_ref7) {
    let {
      disabled,
      index,
      node: node2,
      rect
    } = _ref7;
    const [derivedTransform, setDerivedtransform] = H.useState(null);
    const previousIndex = H.useRef(index);
    useIsomorphicLayoutEffect(() => {
      if (!disabled && index !== previousIndex.current && node2.current) {
        const initial = rect.current;
        if (initial) {
          const current = getClientRect(node2.current, {
            ignoreTransform: true
          });
          const delta = {
            x: initial.left - current.left,
            y: initial.top - current.top,
            scaleX: initial.width / current.width,
            scaleY: initial.height / current.height
          };
          if (delta.x || delta.y) {
            setDerivedtransform(delta);
          }
        }
      }
      if (index !== previousIndex.current) {
        previousIndex.current = index;
      }
    }, [disabled, index, node2, rect]);
    H.useEffect(() => {
      if (derivedTransform) {
        setDerivedtransform(null);
      }
    }, [derivedTransform]);
    return derivedTransform;
  }
  function useSortable(_ref7) {
    let {
      animateLayoutChanges = defaultAnimateLayoutChanges,
      attributes: userDefinedAttributes,
      disabled: localDisabled,
      data: customData,
      getNewIndex = defaultNewIndexGetter,
      id,
      strategy: localStrategy,
      resizeObserverConfig,
      transition = defaultTransition
    } = _ref7;
    const {
      items,
      containerId,
      activeIndex,
      disabled: globalDisabled,
      disableTransforms,
      sortedRects,
      overIndex,
      useDragOverlay,
      strategy: globalStrategy
    } = H.useContext(Context);
    const disabled = normalizeLocalDisabled(localDisabled, globalDisabled);
    const index = items.indexOf(id);
    const data2 = H.useMemo(() => ({
      sortable: {
        containerId,
        index,
        items
      },
      ...customData
    }), [containerId, customData, index, items]);
    const itemsAfterCurrentSortable = H.useMemo(() => items.slice(items.indexOf(id)), [items, id]);
    const {
      rect,
      node: node2,
      isOver,
      setNodeRef: setDroppableNodeRef
    } = useDroppable({
      id,
      data: data2,
      disabled: disabled.droppable,
      resizeObserverConfig: {
        updateMeasurementsFor: itemsAfterCurrentSortable,
        ...resizeObserverConfig
      }
    });
    const {
      active,
      activatorEvent,
      activeNodeRect,
      attributes,
      setNodeRef: setDraggableNodeRef,
      listeners: listeners2,
      isDragging,
      over,
      setActivatorNodeRef,
      transform
    } = useDraggable({
      id,
      data: data2,
      attributes: {
        ...defaultAttributes,
        ...userDefinedAttributes
      },
      disabled: disabled.draggable
    });
    const setNodeRef = useCombinedRefs(setDroppableNodeRef, setDraggableNodeRef);
    const isSorting = Boolean(active);
    const displaceItem = isSorting && !disableTransforms && isValidIndex(activeIndex) && isValidIndex(overIndex);
    const shouldDisplaceDragSource = !useDragOverlay && isDragging;
    const dragSourceDisplacement = shouldDisplaceDragSource && displaceItem ? transform : null;
    const strategy = localStrategy != null ? localStrategy : globalStrategy;
    const finalTransform = displaceItem ? dragSourceDisplacement != null ? dragSourceDisplacement : strategy({
      rects: sortedRects,
      activeNodeRect,
      activeIndex,
      overIndex,
      index
    }) : null;
    const newIndex = isValidIndex(activeIndex) && isValidIndex(overIndex) ? getNewIndex({
      id,
      items,
      activeIndex,
      overIndex
    }) : index;
    const activeId = active == null ? void 0 : active.id;
    const previous = H.useRef({
      activeId,
      items,
      newIndex,
      containerId
    });
    const itemsHaveChanged = items !== previous.current.items;
    const shouldAnimateLayoutChanges = animateLayoutChanges({
      active,
      containerId,
      isDragging,
      isSorting,
      id,
      index,
      items,
      newIndex: previous.current.newIndex,
      previousItems: previous.current.items,
      previousContainerId: previous.current.containerId,
      transition,
      wasDragging: previous.current.activeId != null
    });
    const derivedTransform = useDerivedTransform({
      disabled: !shouldAnimateLayoutChanges,
      index,
      node: node2,
      rect
    });
    H.useEffect(() => {
      if (isSorting && previous.current.newIndex !== newIndex) {
        previous.current.newIndex = newIndex;
      }
      if (containerId !== previous.current.containerId) {
        previous.current.containerId = containerId;
      }
      if (items !== previous.current.items) {
        previous.current.items = items;
      }
    }, [isSorting, newIndex, containerId, items]);
    H.useEffect(() => {
      if (activeId === previous.current.activeId) {
        return;
      }
      if (activeId != null && previous.current.activeId == null) {
        previous.current.activeId = activeId;
        return;
      }
      const timeoutId = setTimeout(() => {
        previous.current.activeId = activeId;
      }, 50);
      return () => clearTimeout(timeoutId);
    }, [activeId]);
    return {
      active,
      activeIndex,
      attributes,
      data: data2,
      rect,
      index,
      newIndex,
      items,
      isOver,
      isSorting,
      isDragging,
      listeners: listeners2,
      node: node2,
      overIndex,
      over,
      setNodeRef,
      setActivatorNodeRef,
      setDroppableNodeRef,
      setDraggableNodeRef,
      transform: derivedTransform != null ? derivedTransform : finalTransform,
      transition: getTransition()
    };
    function getTransition() {
      if (
        // Temporarily disable transitions for a single frame to set up derived transforms
        derivedTransform || // Or to prevent items jumping to back to their "new" position when items change
        itemsHaveChanged && previous.current.newIndex === index
      ) {
        return disabledTransition;
      }
      if (shouldDisplaceDragSource && !isKeyboardEvent(activatorEvent) || !transition) {
        return void 0;
      }
      if (isSorting || shouldAnimateLayoutChanges) {
        return CSS.Transition.toString({
          ...transition,
          property: transitionProperty
        });
      }
      return void 0;
    }
  }
  function normalizeLocalDisabled(localDisabled, globalDisabled) {
    var _localDisabled$dragga, _localDisabled$droppa;
    if (typeof localDisabled === "boolean") {
      return {
        draggable: localDisabled,
        // Backwards compatibility
        droppable: false
      };
    }
    return {
      draggable: (_localDisabled$dragga = localDisabled == null ? void 0 : localDisabled.draggable) != null ? _localDisabled$dragga : globalDisabled.draggable,
      droppable: (_localDisabled$droppa = localDisabled == null ? void 0 : localDisabled.droppable) != null ? _localDisabled$droppa : globalDisabled.droppable
    };
  }
  [KeyboardCode.Down, KeyboardCode.Right, KeyboardCode.Up, KeyboardCode.Left];
  const iconParkOutlineDrag = (props, ref) => /* @__PURE__ */ jsx$1("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref, ...props, children: /* @__PURE__ */ jsx$1("path", { fill: "currentColor", fillRule: "evenodd", d: "M19 10a4 4 0 1 1-8 0a4 4 0 0 1 8 0m-4 18a4 4 0 1 0 0-8a4 4 0 0 0 0 8m0 14a4 4 0 1 0 0-8a4 4 0 0 0 0 8m22-32a4 4 0 1 1-8 0a4 4 0 0 1 8 0m-4 18a4 4 0 1 0 0-8a4 4 0 0 0 0 8m0 14a4 4 0 1 0 0-8a4 4 0 0 0 0 8", clipRule: "evenodd" }) });
  const ForwardRef$3 = H.forwardRef(iconParkOutlineDrag);
  var _ref2$2 = {
    name: "1js6ety",
    styles: "display:grid;grid-template-columns:250px 1fr;column-gap:50px"
  };
  function TabPaneRecTabsConfig() {
    const {
      dynamicFeed,
      appRecommend
    } = useSettingsSnapshot();
    const sortedTabKeys = useSortedTabKeys();
    const getCssOrderStyle = (tab2) => {
      return {
        order: sortedTabKeys.indexOf(tab2) + 1
      };
    };
    return /* @__PURE__ */ jsx$1("div", { css: S$1.tabPane, children: /* @__PURE__ */ jsxs("div", { css: _ref2$2, children: [
      /* @__PURE__ */ jsx$1(SettingsGroup, { title: /* @__PURE__ */ jsxs(Fragment, { children: [
        "Tab 设置",
        /* @__PURE__ */ jsx$1(HelpInfo, { className: "ml-5px", children: "勾选显示, 拖动排序" }),
        /* @__PURE__ */ jsx$1("span", { className: "flex-1" }),
        /* @__PURE__ */ jsx$1(ResetPartialSettingsButton, { paths: ["hidingTabKeys", "customTabKeysOrder"] })
      ] }), children: /* @__PURE__ */ jsx$1(VideoSourceTabOrder, {}) }),
      /* @__PURE__ */ jsxs(SettingsGroup, { title: "更多设置", contentClassName: "gap-y-15px", children: [
        /* @__PURE__ */ jsxs("div", { style: getCssOrderStyle(ETab.Watchlater), children: [
          /* @__PURE__ */ jsxs("div", { className: "flex items-center text-size-1.3em", children: [
            /* @__PURE__ */ jsx$1(TabIcon, { tabKey: ETab.Watchlater, className: "mr-5px mt--1px" }),
            "稍后再看"
          ] }),
          /* @__PURE__ */ jsx$1(antd.Space, { size: 10, children: /* @__PURE__ */ jsx$1(CheckboxSettingItem, { configPath: "watchlaterAddSeparator", label: "添加分割线", tooltip: "添加「近期」「更早」分割线" }) })
        ] }),
        /* @__PURE__ */ jsxs("div", { style: getCssOrderStyle(ETab.Fav), children: [
          /* @__PURE__ */ jsxs("div", { className: "flex items-center text-size-1.3em", children: [
            /* @__PURE__ */ jsx$1(TabIcon, { tabKey: ETab.Fav, className: "mr-5px mt--2px" }),
            "收藏"
          ] }),
          /* @__PURE__ */ jsx$1(antd.Space, { size: 10, children: /* @__PURE__ */ jsx$1(CheckboxSettingItem, { configPath: "fav.addSeparator", label: "添加分割线", tooltip: "顺序显示时, 按收藏夹添加分割线" }) })
        ] }),
        /* @__PURE__ */ jsxs("div", { style: getCssOrderStyle(ETab.DynamicFeed), children: [
          /* @__PURE__ */ jsxs("div", { className: "flex items-center text-size-1.3em", children: [
            /* @__PURE__ */ jsx$1(TabIcon, { tabKey: ETab.DynamicFeed, className: "mr-5px mt--2px" }),
            "动态"
          ] }),
          /* @__PURE__ */ jsxs("div", { className: "flex flex-wrap  gap-x-10px gap-y-10px", children: [
            /* @__PURE__ */ jsx$1(CheckboxSettingItem, { configPath: "dynamicFeed.followGroup.enabled", label: "启用分组筛选", tooltip: /* @__PURE__ */ jsxs(Fragment, { children: [
              "动态 Tab 启用分组筛选 ",
              /* @__PURE__ */ jsx$1("br", {}),
              /* @__PURE__ */ jsx$1(FollowGroupMechanismNote, {})
            ] }) }),
            /* @__PURE__ */ jsx$1(CheckboxSettingItem, { configPath: "dynamicFeed.showLive", label: "在动态中显示直播", tooltip: /* @__PURE__ */ jsxs(Fragment, { children: [
              "动态里显示正在直播的 UP",
              /* @__PURE__ */ jsx$1("br", {}),
              "P.S 仅在选择「全部」时展示"
            ] }) }),
            /* @__PURE__ */ jsx$1(CheckboxSettingItem, { configPath: "dynamicFeed.whenViewAll.enableHideSomeContents", label: "「全部」动态过滤", tooltip: /* @__PURE__ */ jsxs(Fragment, { children: [
              "查看「全部」动态时 ",
              /* @__PURE__ */ jsx$1("br", {}),
              explainForFlag("将添加右键菜单, 点击可添加到「全部」动态的过滤列表", "关闭此功能")
            ] }) }),
            dynamicFeed.whenViewAll.enableHideSomeContents && /* @__PURE__ */ jsx$1(antd.Collapse, { size: "small", className: "w-full", items: [{
              key: "1",
              label: "在「全部」动态中隐藏 UP/分组 的动态",
              children: /* @__PURE__ */ jsx$1(DynamicFeedWhenViewAllHideIdsPanel, {})
            }] })
          ] })
        ] }),
        /* @__PURE__ */ jsxs("div", { style: getCssOrderStyle(ETab.AppRecommend), children: [
          /* @__PURE__ */ jsxs("div", { className: "flex items-center text-size-1.3em", children: [
            /* @__PURE__ */ jsx$1(TabIcon, { tabKey: ETab.AppRecommend, className: "mr-5px" }),
            "App 推荐"
          ] }),
          /* @__PURE__ */ jsxs("div", { className: "flex flex-col gap-y-5px", children: [
            /* @__PURE__ */ jsxs("div", { className: "flex items-center", children: [
              "App API 设备类型",
              /* @__PURE__ */ jsxs(HelpInfo, { className: "ml-5px mr-10px", children: [
                "默认 ipad, 视频有 头像/日期 等信息",
                /* @__PURE__ */ jsx$1("br", {}),
                "可选 android, 有图文类型的推荐"
              ] }),
              /* @__PURE__ */ jsx$1(antd.Radio.Group, { optionType: "button", buttonStyle: "solid", size: "small", options: [EAppApiDevice.ipad, EAppApiDevice.android], value: appRecommend.deviceParamForApi, onChange: (e2) => void (settings.appRecommend.deviceParamForApi = e2.target.value) })
            ] }),
            /* @__PURE__ */ jsx$1("div", { className: "flex items-center", children: appRecShowContentFromOtherTabEl() })
          ] })
        ] })
      ] })
    ] }) });
  }
  function useCurrentShowingTabKeys() {
    const {
      hidingTabKeys
    } = useSettingsSnapshot();
    return H.useMemo(() => CONFIGURABLE_TAB_KEYS.filter((key) => !hidingTabKeys.includes(key)), [hidingTabKeys]);
  }
  function VideoSourceTabOrder({
    className,
    style
  }) {
    const currentShowingTabKeys = useCurrentShowingTabKeys();
    const sortedTabKeys = useSortedTabKeys();
    const sensors = useSensors(useSensor(PointerSensor));
    const handleDragEnd = useMemoizedFn((e2) => {
      const {
        over,
        active
      } = e2;
      if (!(over == null ? void 0 : over.id) || over.id === active.id) return;
      const oldIndex = sortedTabKeys.indexOf(active.id.toString());
      const newIndex = sortedTabKeys.indexOf(over.id.toString());
      const newList = arrayMove(sortedTabKeys, oldIndex, newIndex);
      updateSettings({
        customTabKeysOrder: newList
      });
    });
    return /* @__PURE__ */ jsx$1("div", { ...{
      className,
      style
    }, children: /* @__PURE__ */ jsx$1(antd.Checkbox.Group, { className: "block line-height-[unset]", value: currentShowingTabKeys, onChange: (newVal) => {
      if (!newVal.length) {
        return antMessage.error("至少选择一项!");
      }
      updateSettings({
        hidingTabKeys: CONFIGURABLE_TAB_KEYS.filter((k) => !newVal.includes(k))
      });
    }, children: /* @__PURE__ */ jsx$1(DndContext, { sensors, collisionDetection: closestCenter, onDragEnd: handleDragEnd, modifiers: [restrictToVerticalAxis, restrictToParentElement], children: /* @__PURE__ */ jsx$1(SortableContext, { items: sortedTabKeys, strategy: verticalListSortingStrategy, children: sortedTabKeys.map((key) => /* @__PURE__ */ jsx$1(VideoSourceTabSortableItem, { id: key }, key)) }) }) }) });
  }
  var _ref$4 = {
    name: "oa9msk",
    styles: ".ant-checkbox+span{user-select:none;display:inline-flex;align-items:center;}"
  };
  function VideoSourceTabSortableItem({
    id
  }) {
    const {
      attributes,
      listeners: listeners2,
      setNodeRef,
      transform,
      transition,
      setActivatorNodeRef
    } = useSortable({
      id
    });
    const style = {
      transform: CSS.Transform.toString(transform),
      transition
    };
    const {
      label,
      desc
    } = TabConfig[id];
    return /* @__PURE__ */ jsxs("div", { ref: setNodeRef, style, ...attributes, css: /* @__PURE__ */ css("display:flex;align-items:center;justify-content:space-between;height:35px;padding-left:10px;padding-right:6px;border:1px solid ", bgLv2Value, ";border-radius:6px;margin-top:8px;", ""), children: [
      /* @__PURE__ */ jsxs(antd.Checkbox, { value: id, className: "inline-flex items-center", css: _ref$4, children: [
        /* @__PURE__ */ jsx$1(TabIcon, { tabKey: id, className: "mr-5px" }),
        /* @__PURE__ */ jsx$1(AntdTooltip, { align: {
          offset: [0, -6]
        }, title: desc, children: label })
      ] }),
      /* @__PURE__ */ jsx$1("div", { ...listeners2, ref: setActivatorNodeRef, css: /* @__PURE__ */ css("cursor:grab;font-size:0;padding:3px 5px;border-radius:5px;&:hover{background-color:", bgLv3Value, ";}", ""), children: /* @__PURE__ */ jsx$1(ForwardRef$3, { className: "size-18px" }) })
    ] }, id);
  }
  function DynamicFeedWhenViewAllHideIdsPanel() {
    const {
      hideIds
    } = useSnapshot(settings.dynamicFeed.whenViewAll);
    const onDelete = useMemoizedFn(async (mid) => {
      await updateSettingsInnerArray("dynamicFeed.whenViewAll.hideIds", {
        remove: [mid]
      });
    });
    const {
      groups
    } = useSnapshot(dfStore);
    useMount(() => {
      dfStore.updateGroups();
    });
    const empty = !hideIds.length;
    if (empty) {
      return /* @__PURE__ */ jsx$1("div", { className: "flex items-center justify-center", children: /* @__PURE__ */ jsx$1(antd.Empty, {}) });
    }
    return /* @__PURE__ */ jsx$1("div", { className: "flex flex-wrap gap-10px max-h-250px overflow-y-scroll", children: hideIds.map((tag) => {
      return /* @__PURE__ */ jsx$1(TagItemDisplay, { tag, onDelete, renderTag: (t2) => /* @__PURE__ */ jsx$1(DynamicFeedWhenViewAllHideIdTag, { tag: t2, followGroups: groups }) }, tag);
    }) });
  }
  function DynamicFeedWhenViewAllHideIdTag({
    tag,
    followGroups
  }) {
    let mid;
    let followGroupId;
    if (tag.startsWith(DF_SELECTED_KEY_PREFIX_UP)) {
      mid = tag.slice(DF_SELECTED_KEY_PREFIX_UP.length);
    } else if (tag.startsWith(DF_SELECTED_KEY_PREFIX_GROUP)) {
      followGroupId = tag.slice(DF_SELECTED_KEY_PREFIX_GROUP.length);
    } else ;
    const [upNickname, setUpNickname] = H.useState(void 0);
    useMount(async () => {
      if (!mid) return;
      const nickname = await getUserNickname(mid);
      if (nickname) setUpNickname(nickname);
    });
    const [followGroupName, setFollowGroupName] = H.useState(void 0);
    useMount(async () => {
      var _a2;
      if (!followGroupId) return;
      const groupName = (_a2 = followGroups == null ? void 0 : followGroups.find((g) => g.tagid.toString() === followGroupId)) == null ? void 0 : _a2.name;
      if (groupName) setFollowGroupName(groupName);
    });
    const label = H.useMemo(() => mid ? upNickname || mid : followGroupId ? followGroupName || followGroupId : "无效数据", [mid, upNickname, followGroupId, followGroupName]);
    const tooltip = H.useMemo(() => mid ? `mid: ${mid}` : followGroupId ? `分组: ${followGroupId}` : `Tag: ${tag}`, [mid, followGroupId, tag]);
    const icon = H.useMemo(() => mid ? /* @__PURE__ */ jsx$1(IconForUp, { className: "size-12px mr-2px" }) : followGroupId ? /* @__PURE__ */ jsx$1(IconForGroup, { className: "size-16px mr-2px" }) : void 0, [mid, followGroupId]);
    const href = H.useMemo(() => mid ? formatSpaceUrl(mid) : followGroupId ? formatFollowGroupUrl(followGroupId) : void 0, [mid, followGroupId]);
    return /* @__PURE__ */ jsx$1(Fragment, { children: /* @__PURE__ */ jsx$1(AntdTooltip, { title: tooltip, children: /* @__PURE__ */ jsxs("span", { className: clsx("inline-flex items-center", mid ? "cursor-pointer" : "cursor-text"), children: [
      icon,
      href ? /* @__PURE__ */ jsx$1("a", { href, target: "_blank", children: label }) : label
    ] }) }) });
  }
  function ThemesSelect() {
    const activeId = useCurrentTheme().id;
    const prevActiveId = usePrevious$1(activeId);
    const {
      colorPickerThemeSelectedColor
    } = useSettingsSnapshot();
    const [customColor, setCustomColor] = H.useState(colorPickerThemeSelectedColor || DEFAULT_BILI_PINK_THEME.colorPrimary);
    const customColorHex = H.useMemo(() => {
      return typeof customColor === "string" ? customColor : customColor.toHexString();
    }, [customColor]);
    useMount(() => {
      $evolvedThemeColor.updateThrottled();
    });
    return /* @__PURE__ */ jsx$1("div", { children: ThemeGroups.map(({
      name,
      themes,
      tooltip
    }) => {
      return /* @__PURE__ */ jsxs(H.Fragment, { children: [
        /* @__PURE__ */ jsxs("div", { className: "flex items-center mt-10px text-size-1.5em", children: [
          name,
          /* @__PURE__ */ jsx$1(
            HelpInfo,
            {
              className: "size-16px",
              tooltipProps: {
                color: "rgba(0, 0, 0, 0.85)"
              },
              children: tooltip
            }
          )
        ] }),
        /* @__PURE__ */ jsx$1("div", { className: "flex flex-wrap gap-y-2px gap-x-8px", children: themes.map((t2) => {
          const isActive = activeId === t2.id;
          const isCustom = t2.isCustom;
          const useAnimation = !!prevActiveId && prevActiveId !== t2.id;
          const innerSize = 30;
          const outerSize = innerSize + 8;
          let previewWrapper = /* @__PURE__ */ jsx$1("div", { "data-role": "preview-wrapper", style: {
            width: outerSize
          }, className: clsx("aspect-1 b-solid b-2px rounded-full my-0 mx-auto", isActive ? "b-gate-primary" : "b-transparent", "flex items-center justify-center text-size-0"), children: /* @__PURE__ */ jsx$1("div", { "data-role": "preview", className: "aspect-1 rounded-full flex items-center justify-center text-white", css: /* @__PURE__ */ css("width:", innerSize, "px;background-color:", isCustom ? customColorHex : t2.colorPrimary, ";", ""), children: isActive && /* @__PURE__ */ jsx$1(IconAnimatedChecked, { size: 18, useAnimation }) }) });
          if (t2.isCustom) {
            previewWrapper = /* @__PURE__ */ jsx$1(
              antd.ColorPicker,
              {
                value: customColor,
                onChange: (c2) => setCustomColor(c2),
                onOpenChange: (open) => {
                  if (!open) {
                    updateSettings({
                      colorPickerThemeSelectedColor: customColorHex
                    });
                  }
                },
                children: previewWrapper
              }
            );
          }
          let el = /* @__PURE__ */ jsxs("div", { className: "min-w-60px text-center cursor-pointer", onClick: (e2) => {
            updateSettings({
              theme: t2.id
            });
          }, children: [
            previewWrapper,
            t2.name
          ] });
          if (t2.tooltip) {
            el = /* @__PURE__ */ jsx$1(AntdTooltip, { title: t2.tooltip, children: el });
          }
          el = /* @__PURE__ */ jsx$1(H.Fragment, { children: el }, t2.id);
          return el;
        }) })
      ] }, name);
    }) });
  }
  function useHotkeyForConfig(hotkey, configPath, label) {
    return useKeyPress(hotkey, (e2) => {
      if (shouldDisableShortcut()) return;
      const current = Boolean(get(settings, configPath));
      const newValue = !current;
      set(settings, configPath, newValue);
      antMessage.success(`已${newValue ? "启用" : "禁用"}「${label}」`);
    }, {
      exactMatch: true
    });
  }
  const tab = "basic";
  const modalSettingsStore = proxy({
    tab
  });
  function ModalSettingsHotkey() {
    useHotkeyForConfig(["shift.p"], "autoPreviewWhenKeyboardSelect", "键盘选中后自动开始预览");
    useHotkeyForConfig(["shift.m"], "autoPreviewWhenHover", "鼠标悬浮后自动开始预览");
    useHotkeyForConfig(["shift.c"], "useNarrowMode", "居中模式");
    useHotkeyForConfigBorder();
    useHotkeyForToggleEvolvedDarkMode();
    return null;
  }
  var _ref$3 = {
    name: "4k370z",
    styles: "&.ant-tabs{.ant-tabs-tab{justify-content:end;padding-inline:5px 15px;}.ant-tabs-nav-operations{display:none;}}"
  };
  var _ref2$1 = {
    name: "mbnpfd",
    styles: "width:900px;max-height:unset"
  };
  function ModalSettings({
    show,
    onHide: onHide2
  }) {
    const {
      tab: tab2
    } = useSnapshot(modalSettingsStore);
    return /* @__PURE__ */ jsxs(BaseModal, { ...{
      show,
      onHide: onHide2,
      hideWhenMaskOnClick: true,
      hideWhenEsc: true,
      cssModal: _ref2$1
    }, children: [
      /* @__PURE__ */ jsxs("div", { css: BaseModalStyle.modalHeader, children: [
        /* @__PURE__ */ jsxs("div", { css: BaseModalStyle.modalTitle, children: [
          /* @__PURE__ */ jsx$1(IconForConfig, { className: "size-26px mr-4px mt--2px" }),
          "设置"
        ] }),
        /* @__PURE__ */ jsx$1("div", { className: "space", style: {
          flex: 1
        } }),
        /* @__PURE__ */ jsx$1(ModalClose, { onClick: onHide2 })
      ] }),
      /* @__PURE__ */ jsx$1("main", { css: BaseModalStyle.modalBody, style: {
        overflow: "hidden"
      }, children: /* @__PURE__ */ jsx$1(antd.Tabs, { tabPosition: "left", size: "middle", css: _ref$3, activeKey: tab2, onChange: (tab3) => modalSettingsStore.tab = tab3, items: [{
        label: "常规设置",
        key: "basic",
        children: /* @__PURE__ */ jsx$1(TabPaneBasic, {})
      }, {
        label: "内容过滤",
        key: "filter",
        children: /* @__PURE__ */ jsx$1(TabPaneFilter, {})
      }, {
        label: "主题选择",
        key: "theme-select",
        children: /* @__PURE__ */ jsx$1("div", { css: S$1.tabPane, children: /* @__PURE__ */ jsx$1(SettingsGroup, { title: "主题选择", children: /* @__PURE__ */ jsx$1(ThemesSelect, {}) }) })
      }, {
        label: "样式自定",
        key: "custom-ui",
        children: /* @__PURE__ */ jsx$1(TabPaneCustomUI, {})
      }, {
        label: "Tab 设置",
        key: "video-source-tab-config",
        children: /* @__PURE__ */ jsx$1(TabPaneRecTabsConfig, {})
      }, {
        label: "高级设置",
        key: "advance",
        children: /* @__PURE__ */ jsx$1(TabPaneAdvance, {})
      }] }) })
    ] });
  }
  var _ref$2 = {
    name: "1soazqj",
    styles: "&.ant-btn:not(:disabled):focus-visible{outline:none;}"
  };
  const RefreshButton = H.forwardRef(function({
    onRefresh,
    className = "",
    style,
    refreshHotkeyEnabled,
    refreshing
  }, ref) {
    refreshHotkeyEnabled ?? (refreshHotkeyEnabled = true);
    const [deg, setDeg] = H.useState(0);
    const btn = H.useRef(null);
    const click = useMemoizedFn(() => {
      if (!btn.current) return;
      if (btn.current.disabled) return;
      btn.current.click();
    });
    H.useImperativeHandle(ref, () => ({
      click
    }), []);
    useKeyPress("r", () => {
      if (shouldDisableShortcut()) return;
      if (!refreshHotkeyEnabled) return;
      click();
    }, {
      exactMatch: true
    });
    const tab2 = useCurrentUsingTab();
    const {
      watchlaterItemsOrder,
      popularWeeklyUseShuffle
    } = useSettingsSnapshot();
    const {
      usingShuffle: favUsingShuffle
    } = useSnapshot(favStore);
    const text = tab2 === ETab.AppRecommend || tab2 === ETab.PcRecommend || tab2 === ETab.KeepFollowOnly || tab2 === ETab.Watchlater && watchlaterItemsOrder === WatchlaterItemsOrder.Shuffle || tab2 === ETab.Fav && favUsingShuffle || tab2 === ETab.Hot && isHotTabUsingShuffle(popularWeeklyUseShuffle) ? "换一换" : "刷新";
    const [scope, animate] = framerMotion.useAnimate();
    const onClick = useMemoizedFn((e2) => {
      animate(scope.current, {
        rotate: [0, 360]
      }, {
        duration: 0.5,
        type: "tween"
      });
      onRefresh == null ? void 0 : onRefresh();
    });
    return /* @__PURE__ */ jsxs(antd.Button, { disabled: refreshing, className: clsx(className, "flex items-center gap-x-4px"), style, css: _ref$2, ref: btn, onClick, children: [
      /* @__PURE__ */ jsx$1(IconForRoll, { ref: scope, className: "size-14px" }),
      text
    ] });
  });
  const headerState = proxy({
    modalFeedVisible: false,
    modalSettingsVisible: false
  });
  function useHeaderState() {
    return useSnapshot(headerState);
  }
  const iconParkOutlineRight = (props, ref) => /* @__PURE__ */ jsx$1("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref, ...props, children: /* @__PURE__ */ jsx$1("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 4, d: "m19 12l12 12l-12 12" }) });
  const ForwardRef$2 = H.forwardRef(iconParkOutlineRight);
  const CollapseBtn = H.forwardRef(function CollapseBtn2({
    children,
    initialOpen = false
  }, ref) {
    const [buttonsExpanded, buttonsExpandedActions] = useToggle(initialOpen);
    H.useImperativeHandle(ref, () => buttonsExpandedActions, [buttonsExpandedActions]);
    const btn = /* @__PURE__ */ jsx$1(antd.Button, { onClick: buttonsExpandedActions.toggle, className: "icon-only-round-button", children: /* @__PURE__ */ jsx$1(ForwardRef$2, { className: clsx("size-13px", buttonsExpanded ? "rotate-z-0" : "rotate-z-180deg") }) });
    return /* @__PURE__ */ jsxs(Fragment, { children: [
      btn,
      buttonsExpanded && children
    ] });
  });
  var _ref4 = {
    name: "1k6795t",
    styles: "width:100vw;height:100vh"
  };
  var _ref5 = {
    name: "m77sh5",
    styles: "width:calc(100vw - 30px);height:calc(100vh - 30px);max-height:unset;padding-right:0"
  };
  var _ref6 = {
    name: "x7zn3p",
    styles: "background-color:rgba(0, 0, 0, 0.9)"
  };
  const S = {
    modalMask: (narrowMode2) => narrowMode2 && _ref6,
    modal: (narrowMode2, fullScreenMode) => [_ref5, narrowMode2 && /* @__PURE__ */ css("width:", 325 * 2 + 40, "px;height:calc(100vh - 10px);border:none;:global(", appClsDarkSelector, ") &{border:none;}", ""), fullScreenMode && _ref4],
    // 滚动条右移
    modalHeader: {
      name: "kftco8",
      styles: "padding-right:15px"
    },
    modalBody: {
      name: "kftco8",
      styles: "padding-right:15px"
    },
    btnRefresh: /* @__PURE__ */ css(appClsDarkSelector, " &{color:#eee!important;background-color:#333!important;border-color:transparent!important;height:auto;padding:8px 12px;line-height:16px;font-size:13px;}", "")
  };
  var _ref2 = {
    name: "cx5ruc",
    styles: "flex-shrink:1;display:flex;align-items:center;flex-wrap:wrap;row-gap:4px;column-gap:15px"
  };
  var _ref3 = {
    name: "15gpyv7",
    styles: "display:flex;align-items:center;justify-content:space-between;column-gap:20px"
  };
  const ModalFeed = H.memo(function ModalFeed2({
    show,
    onHide: onHide2
  }) {
    const scrollerRef = H.useRef(null);
    const {
      // 双列模式
      useNarrowMode,
      // 全屏模式
      modalFeedFullScreen
    } = useSettingsSnapshot();
    const useFullScreen = !useNarrowMode && modalFeedFullScreen;
    const modalBorderCss = H.useMemo(() => {
      const borderWidth = useFullScreen ? 5 : 1;
      return /* @__PURE__ */ css("border:", borderWidth, "px solid ", colorPrimaryValue, ";", "");
    }, [useFullScreen]);
    const onScrollToTop = useMemoizedFn(() => {
      if (scrollerRef.current) {
        scrollerRef.current.scrollTop = 0;
      }
    });
    const [headerState2, setHeaderState] = H.useState(initHeaderState);
    const renderHeader = () => {
      const {
        refreshing,
        onRefresh,
        extraInfo
      } = headerState2;
      return /* @__PURE__ */ jsx$1(OnRefreshContext.Provider, { value: onRefresh, children: /* @__PURE__ */ jsxs("div", { css: [BaseModalStyle.modalHeader, S.modalHeader, _ref3, "", ""], children: [
        /* @__PURE__ */ jsxs("div", { className: "left", css: _ref2, children: [
          /* @__PURE__ */ jsx$1(VideoSourceTab, { onRefresh }),
          extraInfo
        ] }),
        /* @__PURE__ */ jsxs("div", { className: "right flex-shrink-0 flex items-center", children: [
          useNarrowMode ? null : useFullScreen ? /* @__PURE__ */ jsx$1(ModalFeedConfigChecks, {}) : /* @__PURE__ */ jsx$1(CollapseBtn, { initialOpen: true, children: /* @__PURE__ */ jsx$1(ModalFeedConfigChecks, {}) }),
          /* @__PURE__ */ jsx$1(RefreshButton, { css: /* @__PURE__ */ css(S.btnRefresh, " margin-left:8px;", ""), refreshing, onRefresh, refreshHotkeyEnabled: show }),
          /* @__PURE__ */ jsx$1(ModalClose, { onClick: onHide2 })
        ] })
      ] }) });
    };
    return /* @__PURE__ */ jsxs(BaseModal, { ...{
      show,
      onHide: onHide2
    }, cssModalMask: S.modalMask(useNarrowMode), cssModal: [S.modal(useNarrowMode, useFullScreen), modalBorderCss], children: [
      renderHeader(),
      /* @__PURE__ */ jsx$1("div", { css: [BaseModalStyle.modalBody, S.modalBody, "", ""], ref: scrollerRef, children: /* @__PURE__ */ jsx$1(RecGrid, { shortcutEnabled: show, onScrollToTop, infiniteScrollUseWindow: false, scrollerRef, onSyncHeaderState: setHeaderState }) })
    ] });
  });
  var _ref$1 = {
    name: "1qkltea",
    styles: "margin-left:5px"
  };
  function ModalFeedConfigChecks() {
    const inModalFeedStyle = _ref$1;
    return /* @__PURE__ */ jsxs(Fragment, { children: [
      /* @__PURE__ */ jsx$1(CheckboxSettingItem, { configPath: "showModalFeedOnLoad", label: "自动查看更多", tooltip: "打开首页时默认打开推荐弹窗", css: inModalFeedStyle, extraAction: (val) => {
        if (val) {
          antMessage.success("已开启自动查看更多: 下次打开首页时将直接展示推荐弹窗");
        }
      } }),
      /* @__PURE__ */ jsx$1(CheckboxSettingItem, { configPath: "modalFeedFullScreen", label: "全屏", tooltip: "世界清净了~", css: inModalFeedStyle })
    ] });
  }
  function showModalFeed() {
    renderOnce();
    headerState.modalFeedVisible = true;
  }
  function hideModalFeed() {
    headerState.modalFeedVisible = false;
  }
  if (IN_BILIBILI_HOMEPAGE && settings.showModalFeedOnLoad) {
    setTimeout(showModalFeed);
  }
  function toggleModalSettings() {
    if (headerState.modalSettingsVisible) {
      hideModalSettings();
    } else {
      showModalSettings();
    }
  }
  function showModalSettings() {
    renderOnce();
    headerState.modalSettingsVisible = true;
  }
  function hideModalSettings() {
    headerState.modalSettingsVisible = false;
  }
  function registerSettingsGmCommand() {
    var _a2;
    (_a2 = GM.registerMenuCommand) == null ? void 0 : _a2.call(GM, "⚙️ 设置", showModalSettings);
  }
  const renderOnce = once(function render4() {
    const container = document.createElement("div");
    container.classList.add("modals-container", APP_CLS_ROOT);
    document.body.appendChild(container);
    const r2 = clientExports.createRoot(container);
    r2.render(/* @__PURE__ */ jsx$1(AppRoot, { children: /* @__PURE__ */ jsx$1(ModalsContainer, {}) }));
  });
  function ModalsContainer() {
    const {
      modalFeedVisible,
      modalSettingsVisible
    } = useHeaderState();
    return /* @__PURE__ */ jsxs(Fragment, { children: [
      /* @__PURE__ */ jsx$1(ModalFeed, { show: modalFeedVisible, onHide: hideModalFeed }),
      /* @__PURE__ */ jsx$1(ModalSettings, { show: modalSettingsVisible, onHide: hideModalSettings })
    ] });
  }
  const tablerLayoutGrid = (props, ref) => /* @__PURE__ */ jsx$1("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref, ...props, children: /* @__PURE__ */ jsx$1("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M4 5a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v4a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1zm10 0a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v4a1 1 0 0 1-1 1h-4a1 1 0 0 1-1-1zM4 15a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v4a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1zm10 0a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v4a1 1 0 0 1-1 1h-4a1 1 0 0 1-1-1z" }) });
  const ForwardRef$1 = H.forwardRef(tablerLayoutGrid);
  const tablerListDetails = (props, ref) => /* @__PURE__ */ jsx$1("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref, ...props, children: /* @__PURE__ */ jsx$1("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M13 5h8m-8 4h5m-5 6h8m-8 4h5M3 5a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v4a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1zm0 10a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v4a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1z" }) });
  const ForwardRef = H.forwardRef(tablerListDetails);
  const debug$2 = baseDebug.extend("RecHeader");
  const RecHeader = H.forwardRef(function RecHeader2({
    onRefresh,
    refreshing,
    leftSlot,
    rightSlot
  }, ref) {
    const {
      modalFeedVisible,
      modalSettingsVisible
    } = useSnapshot(headerState);
    const {
      accessKey,
      pureRecommend,
      showModalFeedEntry,
      style,
      __internalShowGridListSwitcher,
      multiSelect: {
        showIcon: multiSelectShowIcon
      }
    } = useSettingsSnapshot();
    const {
      cardDisplay,
      useStickyTabbar
    } = style.pureRecommend;
    useKeyPress(["shift.comma"], (e2) => {
      if (shouldDisableShortcut()) return;
      toggleModalSettings();
    }, {
      exactMatch: true,
      useCapture: true
    });
    const [stickyRef, sticky] = useSticky();
    const scrollToTop = useMemoizedFn(() => {
      var _a2;
      if (!pureRecommend) return;
      const container = (_a2 = stickyRef.current) == null ? void 0 : _a2.parentElement;
      if (!container) return;
      const rect = container.getBoundingClientRect();
      const headerHeight2 = $headerHeight.get();
      if (rect.top < headerHeight2) {
        const yOffset = getElementOffset(container).top;
        debug$2("[refresh:scroll] rect.top = %s, headerHeight = %s", rect.top, headerHeight2);
        document.documentElement.scrollTop = yOffset - headerHeight2 + 2;
      }
    });
    H.useImperativeHandle(ref, () => ({
      scrollToTop
    }));
    const headerHeight = $headerHeight.use();
    const showAccessKeyManage = useShouldShowAccessKeyManage();
    const usingEvolevdHeader = $usingEvolevdHeader.use();
    const dark = useIsDarkMode();
    const boxShadow = (() => {
      if (usingEvolevdHeader) {
        return dark ? "rgba(0, 0, 0, 26%) 0px 2px 10px 1px" : "rgba(0, 0, 0, 13%) 0 1px 10px 1px;";
      } else {
        return `0 2px 4px ${dark ? "rgb(255 255 255 / 5%)" : "rgb(0 0 0 / 8%)"}`;
      }
    })();
    const expandToFullWidthCss = useExpandToFullWidthCss();
    const toggleCardDisplay = useMemoizedFn(() => {
      const list2 = [ECardDisplay.Grid, ECardDisplay.List];
      const index = list2.indexOf(settings.style.pureRecommend.cardDisplay);
      const nextIndex = (index + 1) % list2.length;
      settings.style.pureRecommend.cardDisplay = list2[nextIndex];
    });
    return /* @__PURE__ */ jsx$1(Fragment, { children: /* @__PURE__ */ jsx$1(OnRefreshContext.Provider, { value: onRefresh, children: /* @__PURE__ */ jsx$1("div", { ref: stickyRef, className: clsx("area-header-wrapper", {
      sticky
    }), css: pureRecommend && useStickyTabbar && [/* @__PURE__ */ css("position:sticky;top:", headerHeight - 1, "px;z-index:", zIndexRecHeader, ";margin-bottom:10px;transition:background-color 0.3s ease-in-out,box-shadow 0.3s ease-in-out,margin-bottom 0.3s ease-in-out;", ""), sticky && [/* @__PURE__ */ css("border-bottom:1px solid oklch(from ", bgValue, " calc(l + ", dark ? 0.15 : -0.15, ") c h / 50%);background-color:var(--bg1_float);box-shadow:", boxShadow, ";", ""), expandToFullWidthCss]], children: /* @__PURE__ */ jsxs("div", { "data-raw-class": "area-header", className: clsx(
      APP_CLS_TAB_BAR,
      "relative",
      "flex flex-row items-center justify-between gap-x-20px",
      // gap between left & right
      "h-auto px-0 py-8px mb-0"
    ), children: [
      /* @__PURE__ */ jsxs("div", { "data-class-name": "left", className: "flex-shrink-1 h-full flex items-center flex-wrap gap-y-8px gap-x-15px", children: [
        /* @__PURE__ */ jsx$1(VideoSourceTab, { onRefresh }),
        leftSlot
      ] }),
      /* @__PURE__ */ jsxs("div", { "data-class-name": "right", className: "h-full flex-shrink-0 flex items-center gap-x-8px", children: [
        rightSlot,
        !accessKey && showAccessKeyManage && /* @__PURE__ */ jsx$1(AccessKeyManage, { style: {
          marginLeft: 5
        } }),
        __internalShowGridListSwitcher && /* @__PURE__ */ jsx$1(AntdTooltip, { title: "切换卡片显示模式", arrow: false, children: /* @__PURE__ */ jsx$1(antd.Button, { className: "icon-only-round-button", onClick: toggleCardDisplay, children: cardDisplay === ECardDisplay.Grid ? /* @__PURE__ */ jsx$1(ForwardRef$1, { className: "cursor-pointer size-14px" }) : /* @__PURE__ */ jsx$1(ForwardRef, { className: "cursor-pointer size-14px" }) }) }),
        multiSelectShowIcon && /* @__PURE__ */ jsx$1(MultiSelectButton, { iconOnly: true, addCopyActions: true }),
        /* @__PURE__ */ jsx$1(AntdTooltip, { title: "设置", arrow: false, children: /* @__PURE__ */ jsxs(antd.Button, { onClick: showModalSettings, className: "icon-only-round-button", children: [
          /* @__PURE__ */ jsx$1(ModalSettingsHotkey, {}),
          /* @__PURE__ */ jsx$1(IconForConfig, { className: "size-14px" })
        ] }) }),
        /* @__PURE__ */ jsx$1(RefreshButton, { refreshing, onRefresh, refreshHotkeyEnabled: !(modalSettingsVisible || modalFeedVisible) }),
        showModalFeedEntry && /* @__PURE__ */ jsxs(antd.Button, { onClick: showModalFeed, className: "gap-0", children: [
          /* @__PURE__ */ jsx$1("span", { className: "relative top-1px", children: "查看更多" }),
          /* @__PURE__ */ jsx$1(ForwardRef$2, {})
        ] })
      ] })
    ] }) }) }) });
  });
  function useExpandToFullWidthCss() {
    const {
      xScrolling,
      bodyWidth
    } = useSizeExpression(document.body, (entry) => {
      const width = entry.contentRect.width;
      const xScrolling2 = !!(width && Math.round(width) > Math.round(window.innerWidth));
      if (!xScrolling2) {
        return {
          xScrolling: xScrolling2
        };
      } else {
        return {
          xScrolling: xScrolling2,
          bodyWidth: width
        };
      }
    }, () => ({
      xScrolling: false
    }));
    return H.useMemo(() => {
      if (!xScrolling) {
        const scrollbarWidth = isMac || isSafari ? "0px" : "20px";
        return /* @__PURE__ */ css("margin-inline:calc((100% - 100vw + ", scrollbarWidth, ") / 2);padding-inline:calc((100vw - ", scrollbarWidth, " - 100%) / 2);", "");
      } else {
        const w = Math.floor(bodyWidth);
        return /* @__PURE__ */ css("margin-inline:calc((100% - ", w, "px) / 2);padding-inline:calc((", w, "px - 100%) / 2);", "");
      }
    }, [xScrolling, bodyWidth]);
  }
  function useShouldShowAccessKeyManage() {
    const tab2 = useCurrentUsingTab();
    return tab2 === ETab.AppRecommend;
  }
  const narrowStyle = {
    grid: /* @__PURE__ */ css("width:", 360 * 2 + 20, "px;margin:0 auto;", "")
  };
  function PureRecommend() {
    const {
      useNarrowMode
    } = useSettingsSnapshot();
    const {
      modalFeedVisible,
      modalSettingsVisible
    } = useHeaderState();
    const recHeaderRef = H.useRef(null);
    const onScrollToTop = useMemoizedFn(() => {
      var _a2;
      (_a2 = recHeaderRef.current) == null ? void 0 : _a2.scrollToTop();
    });
    const [headerState2, setHeaderState] = H.useState(initHeaderState);
    return /* @__PURE__ */ jsxs(Fragment, { children: [
      /* @__PURE__ */ jsx$1(RecHeader, { ref: recHeaderRef, refreshing: headerState2.refreshing, onRefresh: headerState2.onRefresh, leftSlot: headerState2.extraInfo }),
      /* @__PURE__ */ jsx$1(RecGrid, { css: [useNarrowMode && narrowStyle.grid, "", ""], shortcutEnabled: !(modalFeedVisible || modalSettingsVisible), infiniteScrollUseWindow: true, onScrollToTop, onSyncHeaderState: setHeaderState })
    ] });
  }
  const debug$1 = baseDebug.extend("components:SectionRecommend");
  function SectionRecommend() {
    const tab2 = H.useDeferredValue(useCurrentUsingTab());
    const servicesRegistry = useRefStateBox(() => ({}));
    return /* @__PURE__ */ jsx$1(TabContent, { tab: tab2, servicesRegistry }, tab2);
  }
  const TabContent = H.memo(function TabContent2({
    tab: tab2,
    servicesRegistry
  }) {
    const skeletonPlaceholders = H.useMemo(() => range(20).map(() => crypto.randomUUID()), []);
    const {
      refreshingBox,
      itemsBox,
      refresh,
      error: refreshError,
      showSkeleton
    } = useRefresh({
      tab: tab2,
      debug: debug$1,
      fetcher: refreshForHome,
      servicesRegistry
    });
    const refreshing = refreshingBox.state;
    const items = itemsBox.state;
    const displaySkeleton = !items.length || refreshError || refreshing && showSkeleton;
    const cardBorderCss = useCardBorderCss();
    return /* @__PURE__ */ jsxs("section", { "data-area": "推荐", children: [
      /* @__PURE__ */ jsx$1(RecHeader, { refreshing, onRefresh: refresh }),
      /* @__PURE__ */ jsx$1("div", { className: clsx(videoGrid, limitTwoLines, videoGridBiliFeed4), style: {
        marginBottom: 30
      }, children: displaySkeleton ? skeletonPlaceholders.map((id) => /* @__PURE__ */ jsx$1(VideoCard, { tab: tab2 }, id)) : items.map((item) => {
        return item.api === EApiType.Separator ? null : /* @__PURE__ */ jsx$1(VideoCard, { item, tab: tab2, baseCss: cardBorderCss }, item.uniqId);
      }) })
    ] });
  });
  const isHashEntry = (location.hash || "").startsWith(`#/${APP_NAMESPACE}/`);
  const bewlyEnabledSelector = "html.bewly-design:not(:has(#i_cecream))";
  function hasBewlyBewly() {
    return !isHashEntry && !!document.querySelector(bewlyEnabledSelector);
  }
  async function tryDetectBewlyBewly() {
    return tryAction(bewlyEnabledSelector, () => {
      appWarn(`unmount for using bewly-design`);
      root == null ? void 0 : root.unmount();
    }, {
      pollTimeout: 5e3,
      warnOnTimeout: false
    });
  }
  let root;
  async function initHomepage() {
    tryToRemove(".adblock-tips");
    tryAction("html.gray", (el) => el.classList.remove("gray"));
    tryToRemove(".vip-login-tip");
    registerSettingsGmCommand();
    if (hasBewlyBewly()) {
      appWarn(`quit for using bewly-design`);
      return;
    }
    if (settings.pureRecommend) {
      await initHomepagePureRecommend();
    } else {
      await initHomepageSection();
    }
    tryDetectBewlyBewly();
  }
  async function initHomepageSection() {
    const timeout = 10 * 1e3;
    const timeoutAt = Date.now() + timeout;
    let insert;
    while (Date.now() <= timeoutAt) {
      if (document.querySelector(".bili-feed4-layout")) {
        insert = (reactNode) => {
          var _a2;
          return (_a2 = document.querySelector(".bili-feed4-layout")) == null ? void 0 : _a2.insertAdjacentElement("afterbegin", reactNode);
        };
        break;
      }
      await delay(200);
    }
    if (!insert) {
      appWarn(`init fail`);
      return;
    }
    const container = document.createElement("section");
    container.classList.add(APP_CLS_ROOT);
    insert(container);
    root = clientExports.createRoot(container);
    root.render(/* @__PURE__ */ jsx$1(AppRoot, { injectGlobalStyle: true, antdSetup: true, children: /* @__PURE__ */ jsx$1(SectionRecommend, {}) }));
    tryToRemove(".bili-feed4 .header-channel");
  }
  async function initHomepagePureRecommend() {
    if (isSafari) await delay(500);
    tryToRemove("#i_cecream .bili-feed4-layout");
    tryToRemove(".bili-feed4 .header-channel");
    tryToRemove(".palette-button-wrap");
    const biliLayout = document.createElement("div");
    biliLayout.classList.add("bili-feed4-layout", "pure-recommend");
    document.body.appendChild(biliLayout);
    const container = document.createElement("section");
    container.classList.add(APP_CLS_ROOT);
    biliLayout.appendChild(container);
    root = clientExports.createRoot(container);
    root.render(/* @__PURE__ */ jsxs(AppRoot, { injectGlobalStyle: true, antdSetup: true, children: [
      /* @__PURE__ */ jsx$1(PureRecommend, {}),
      /* @__PURE__ */ jsx$1(antd.FloatButton.BackTop, { style: {
        // right
        insetInlineEnd: "var(--back-top-right, 24px)"
      } })
    ] }));
  }
  function setupForNoneHomepage() {
    setupAppRootForNoneHomepage();
    registerSettingsGmCommand();
  }
  const _setupOnce = once(() => {
    const container = document.createElement("div");
    document.body.appendChild(container);
    const root2 = clientExports.createRoot(container);
    root2.render(/* @__PURE__ */ jsx$1(AppRoot, { injectGlobalStyle: true, antdSetup: true }));
  });
  function setupAppRootForNoneHomepage() {
    _setupOnce();
  }
  function isInIframe() {
    try {
      return window.self !== window.top;
    } catch (e2) {
      return true;
    }
  }
  async function initSearchPage() {
    if (isInIframe()) return;
    setupForNoneHomepage();
    if (settings.videoCard.actions.showLargePreview && settings.videoCard.videoPreview.addTo.searchPage) {
      addLargePreviewForSearchResults();
    }
  }
  async function addLargePreviewForSearchResults() {
    const run = limitFunction(() => {
      const itemsSelector = ".video-list-item:has(> .bili-video-card),div:has(> .bili-video-card)";
      const list2 = Array.from(document.querySelectorAll(itemsSelector));
      for (const el of list2) addLargePreview(el);
    }, {
      concurrency: 1
    });
    run();
    const ob2 = new MutationObserver(run);
    ob2.observe(document.body, {
      childList: true,
      subtree: true
    });
  }
  const processed = /* @__PURE__ */ new WeakSet();
  const processedAttr = `${APP_NAMESPACE}-add-large-preview-processed`;
  function addLargePreview(el) {
    if (processed.has(el)) return;
    if (el.getAttribute(processedAttr)) return;
    const prevEl = el.querySelector(".bili-watch-later--wrap");
    if (!prevEl) return;
    const container = document.createElement("div");
    prevEl.insertAdjacentElement("afterend", container);
    processed.add(el);
    el.setAttribute(processedAttr, "true");
    const root2 = clientExports.createRoot(container);
    root2.render(/* @__PURE__ */ jsx$1(AppRoot, { children: /* @__PURE__ */ jsx$1(LargePreviewSetup, { el }) }));
  }
  function LargePreviewSetup({
    el
  }) {
    const {
      bvid = "",
      cover
    } = H.useMemo(() => parseCardInfo(el), [el]);
    const card = H.useMemo(() => el.querySelector(".bili-video-card") ?? el, [el]);
    const hovering = useHover(card);
    const {
      largePreviewActionButtonEl,
      largePreviewEl
    } = useLargePreviewRelated({
      shouldFetchPreviewData: !!bvid,
      hasLargePreviewActionButton: true,
      actionButtonVisible: hovering,
      actionButtonProps: {
        useMotion: true,
        motionProps: {
          initial: {
            opacity: 0
          },
          animate: {
            opacity: 1
          },
          exit: {
            opacity: 0,
            transition: {
              delay: 0
            }
          },
          transition: {
            duration: 0.2,
            ease: "linear",
            delay: 0.2
          }
        }
      },
      // required
      bvid,
      cid: void 0,
      uniqId: bvid,
      sharedEmitter: defaultSharedEmitter,
      // optional
      cover
    });
    return /* @__PURE__ */ jsxs(Fragment, { children: [
      /* @__PURE__ */ jsx$1("div", { css: [S$5.top("right"), /* @__PURE__ */ css("right:", 8 + 28 + 5, "px;", ""), "", ""], children: largePreviewActionButtonEl }),
      require$$0.createPortal(largePreviewEl, card)
    ] });
  }
  function parseCardInfo(el) {
    var _a2, _b2, _c2, _d2;
    let bvid;
    {
      const link = (_a2 = el.querySelector(".bili-video-card__wrap > a")) == null ? void 0 : _a2.href;
      if (link) {
        bvid = (_c2 = (_b2 = /^\/video\/(?<bvid>BV\w+)\//i.exec(new URL(link).pathname)) == null ? void 0 : _b2.groups) == null ? void 0 : _c2.bvid;
      }
    }
    const cover = (_d2 = el.querySelector("picture.v-img.bili-video-card__cover img")) == null ? void 0 : _d2.currentSrc;
    return {
      bvid,
      cover
    };
  }
  async function initSpacePage() {
    setupForNoneHomepage();
    addDynEntry();
  }
  const rootElId = `${APP_NAMESPACE}-${crypto.randomUUID()}`;
  async function addDynEntry() {
    if (!state.mid) return;
    const oldSelector = ".h-action";
    const newSelector = ".upinfo .operations";
    await tryAction([oldSelector, newSelector].join(","), (container) => {
      state.href = location.href;
      state.usingNewSpacePage = container.matches(newSelector);
      getFollowedStatus();
      const rootEl = document.createElement("span");
      rootEl.id = rootElId;
      rootEl.classList.add("mr-24px");
      container.insertAdjacentElement("afterbegin", rootEl);
      const root2 = clientExports.createRoot(rootEl);
      root2.render(/* @__PURE__ */ jsx$1(AppRoot, { injectGlobalStyle: true, children: /* @__PURE__ */ jsx$1(ActionButtons, {}) }));
    }, {
      pollTimeout: 1e4,
      pollInterval: 1e3
    });
  }
  const state = proxy({
    href: location.href,
    usingNewSpacePage: false,
    followed: false,
    get mid() {
      return parseMid(this.href);
    },
    get collectionId() {
      var _a2, _b2, _c2;
      {
        const reg = new RegExp(String.raw`https://space.bilibili.com\/(?<mid>\d+)\/lists\/(?<collectionId>\d+)(?:\?type=season)?`);
        const match2 = this.href.match(reg);
        if ((_a2 = match2 == null ? void 0 : match2.groups) == null ? void 0 : _a2.collectionId) {
          return Number((_b2 = match2 == null ? void 0 : match2.groups) == null ? void 0 : _b2.collectionId);
        }
      }
      {
        const reg = new RegExp(String.raw`https://space.bilibili.com\/(?<mid>\d+)\/channel\/collectiondetail\?`);
        if (reg.test(this.href)) {
          const u2 = new URL(this.href);
          const collectionId = (_c2 = u2.searchParams.get("sid")) == null ? void 0 : _c2.trim();
          if (collectionId) {
            return Number(collectionId);
          }
        }
      }
    },
    get isCollectionPage() {
      return typeof this.collectionId === "number";
    },
    get searchKeyword() {
      const reg = new RegExp(String.raw`https://space.bilibili.com\/(?<mid>\d+)\/search`);
      if (!reg.test(this.href)) return void 0;
      const searchParams2 = new URLSearchParams(location.search);
      const keyword = searchParams2.get("keyword");
      return keyword ?? void 0;
    },
    get isSearching() {
      var _a2;
      return !!((_a2 = this.searchKeyword) == null ? void 0 : _a2.trim());
    }
  });
  const getFollowedStatus = reusePendingPromise(async () => {
    const followed = await poll$1(() => {
      const list2 = Array.from(document.querySelectorAll(".space-follow-btn")).filter((el) => {
        var _a2;
        return ((_a2 = el.textContent) == null ? void 0 : _a2.trim()) === "已关注";
      });
      if (list2.length > 0) return true;
    }, {
      interval: 100,
      timeout: 5e3
    });
    state.followed = !!followed;
  });
  if (typeof window.navigation !== "undefined") {
    (_e = (_d = window.navigation).addEventListener) == null ? void 0 : _e.call(_d, "navigatesuccess", () => {
      state.href = location.href;
      getFollowedStatus();
    });
  }
  function ActionButtons() {
    const {
      mid,
      collectionId,
      followed,
      isSearching,
      searchKeyword
    } = useSnapshot(state);
    if (!mid) return;
    const btnClassName = "w-34px rounded-full";
    const btnCss = /* @__PURE__ */ css("border-color:rgb(255 255 255 / 33%);&:hover{border-color:", colorPrimaryValue, ";background-color:", colorPrimaryValue, ";}", "");
    let btnSpaceUpload;
    {
      let href = `https://www.bilibili.com/?${SpaceUploadQueryKey.Mid}=${mid}`;
      if (isSearching && searchKeyword) {
        href += "&" + SpaceUploadQueryKey.SearchText + "=" + searchKeyword;
      }
      btnSpaceUpload = /* @__PURE__ */ jsx$1(ActionButton, { className: btnClassName, css: btnCss, href, tooltip: `在「${APP_NAME}」中查看 UP 的投稿`, children: /* @__PURE__ */ jsx$1(IconForSpaceUpload, {}) }, "btnSpaceUpload");
    }
    let btnDynamicFeed;
    if (followed) {
      const href = `https://www.bilibili.com/?${DynamicFeedQueryKey.Mid}=${mid}`;
      btnDynamicFeed = /* @__PURE__ */ jsx$1(ActionButton, { className: btnClassName, css: btnCss, href, tooltip: `在「${APP_NAME}」中查看 UP 的动态`, children: /* @__PURE__ */ jsx$1(IconForDynamicFeed, {}) }, "btnDynamicFeed");
    }
    let btnViewCollection;
    if (typeof collectionId === "number") {
      btnViewCollection = /* @__PURE__ */ jsx$1(ActionButton, { className: btnClassName, css: btnCss, href: `https://www.bilibili.com/?${FavQueryKey.CollectionIdFull}=${collectionId}`, target: "_blank", tooltip: `在「${APP_NAME}」中查看合集`, children: /* @__PURE__ */ jsx$1(IconForCollection, {}) }, "btnViewCollection");
    }
    return /* @__PURE__ */ jsxs("span", { className: "inline-flex items-center gap-x-8px", children: [
      btnViewCollection,
      btnSpaceUpload,
      btnDynamicFeed
    ] });
  }
  var _ref = {
    name: "17w0g8o",
    styles: "cursor:pointer;display:flex;justify-content:center;align-items:center;height:34px;font-size:14px;font-weight:700;color:var(--text_white);transition:all 0.3s;border:1px solid rgb(255 255 255 / 20%);background-color:rgb(255 255 255 / 14%);&:hover{background-color:rgb(255 255 255 / 40%);}"
  };
  function ActionButton({
    href,
    children,
    className,
    style,
    tooltip,
    ...restProps
  }) {
    const {
      usingNewSpacePage
    } = useSnapshot(state);
    const _className = n("w-150px rounded-6px", className);
    const btn = usingNewSpacePage ? /* @__PURE__ */ jsx$1("a", { href, className: _className, style, ...restProps, css: _ref, children }) : /* @__PURE__ */ jsx$1("a", { href, className: clsx("h-f-btn", className), style: {
      width: "auto",
      paddingInline: "15px",
      ...style
    }, ...restProps, children });
    if (tooltip) {
      return /* @__PURE__ */ jsx$1(AntdTooltip, { title: tooltip, children: btn });
    } else {
      return btn;
    }
  }
  function parseMid(href = location.href) {
    const url = new URL(href);
    const mid = url.pathname.split("/").map((x) => x.trim()).filter((x) => x)[0];
    if (!mid || !/^\d+$/.test(mid)) return;
    return mid;
  }
  function getBiliPlayer() {
    if (typeof unsafeWindow === "undefined") return;
    return unsafeWindow.player;
  }
  const debug = baseDebug.extend("main:video-play-page");
  async function initVideoPlayPage() {
    setupAppRootForNoneHomepage();
    registerGmCommands();
    await handleFullscreen();
    await handleForceAutoPlay();
  }
  function registerGmCommands() {
    registerOpenInPipCommand();
    registerOpenInIinaCommand();
  }
  function registerOpenInPipCommand() {
    var _a2;
    if (!hasDocumentPictureInPicture) return;
    (_a2 = GM.registerMenuCommand) == null ? void 0 : _a2.call(GM, "🎦 小窗打开", () => {
      pausePlayingVideo();
      openInPipWindow();
    });
  }
  function registerOpenInIinaCommand() {
    var _a2;
    if (!isMac) return;
    (_a2 = GM.registerMenuCommand) == null ? void 0 : _a2.call(GM, "▶️ IINA 打开", () => {
      pausePlayingVideo();
      openInIina();
    });
  }
  async function handleFullscreen() {
    const targetMode = new URL(location.href).searchParams.get(QueryKey.PlayerScreenMode);
    const next2 = targetMode === PlayerScreenMode.WebFullscreen || targetMode === PlayerScreenMode.Fullscreen;
    if (!next2) return;
    let action2;
    if (targetMode === PlayerScreenMode.WebFullscreen) {
      action2 = () => {
        var _a2;
        return (_a2 = document.querySelector('[role="button"][aria-label="网页全屏"]')) == null ? void 0 : _a2.click();
      };
    }
    if (targetMode === PlayerScreenMode.Fullscreen) {
      action2 = () => {
        var _a2;
        return (_a2 = document.querySelector('[role="button"][aria-label="全屏"]')) == null ? void 0 : _a2.click();
      };
    }
    const getCurrentMode = () => {
      var _a2;
      return ((_a2 = document.querySelector("#bilibili-player .bpx-player-container")) == null ? void 0 : _a2.dataset.screen) || PlayerScreenMode.Normal;
    };
    const timeoutAt = Date.now() + ms("30s");
    while (getCurrentMode() !== targetMode && Date.now() <= timeoutAt) {
      debug("current mode: %s", getCurrentMode());
      action2 == null ? void 0 : action2();
      await delay(100);
    }
    debug("handleFullscreen to %s complete", targetMode);
  }
  async function handleForceAutoPlay() {
    var _a2;
    if (getBiliPlayerConfigAutoPlay()) return;
    const isON = new URL(location.href).searchParams.get(QueryKey.ForceAutoPlay) === ForceAutoPlay.ON;
    if (!isON) return;
    const playing = () => {
      const player = getBiliPlayer();
      return !!player && !player.isPaused();
    };
    const timeoutAt = Date.now() + ms("30s");
    while (Date.now() <= timeoutAt && !playing()) {
      (_a2 = getBiliPlayer()) == null ? void 0 : _a2.play();
      await delay(1e3);
    }
    debug("handleForceAutoPlay complete, playing = %s", playing());
  }
  function pausePlayingVideo() {
    const player = getBiliPlayer();
    if (player && !player.isPaused()) {
      player.pause();
    }
  }
  function openInPipWindow() {
    const u2 = new URL(location.href);
    u2.searchParams.set(QueryKey.PlayerScreenMode, PlayerScreenMode.WebFullscreen);
    const newHref = u2.href;
    openInPipOrPopup(newHref, "");
  }
  function openInIina() {
    const iinaUrl = `iina://open?url=${encodeURIComponent(location.href)}`;
    window.open(iinaUrl, "_self");
  }
  dayjs.extend(duration);
  void function main() {
    if (IN_BILIBILI_HOMEPAGE) return initHomepage();
    if (IN_BILIBILI_VIDEO_PLAY_PAGE) return initVideoPlayPage();
    if (IN_BILIBILI_SPACE_PAGE) return initSpacePage();
    if (IN_BILIBILI_SEARCH_PAGE) return initSearchPage();
  }();

})(dayjs, dayjs_plugin_duration, React, UAParser, antd, axios, antdCssinjs, antd.locales.zh_CN, ReactDOM, Motion, localforage);
